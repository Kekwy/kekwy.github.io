{"meta":{"title":"铃的杂货铺","subtitle":"二阶铃图","description":"喜欢夏天的无名之辈","author":"可弟WZ铃号机","url":"http://blog.kekwy.com","root":"/"},"pages":[{"title":"404 Not Found","date":"2022-07-30T02:45:25.000Z","updated":"2022-07-30T02:57:34.055Z","comments":true,"path":"404.html","permalink":"http://blog.kekwy.com/404.html","excerpt":"","text":"404"},{"title":"关于","date":"2022-07-31T13:41:20.153Z","updated":"2022-07-31T11:25:31.267Z","comments":false,"path":"about/index.html","permalink":"http://blog.kekwy.com/about/index.html","excerpt":"","text":"喜欢夏天的社畜程序猿，南京大学计算机系本科生，我的世界建筑玩家。 B站: 可弟WZ柒号机 知乎: 可弟岭冬 GitHub: Kekwy 近期计划： 文章：《从继承开始的Java应用笔记》 视频：《我的世界·水星生存指南》 项目：一个3D联机小游戏"},{"title":"文章合集","date":"2022-07-31T13:04:10.582Z","updated":"2022-07-31T13:04:10.582Z","comments":true,"path":"categories/index.html","permalink":"http://blog.kekwy.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-31T13:03:54.437Z","updated":"2022-07-31T13:03:54.437Z","comments":true,"path":"comments/index.html","permalink":"http://blog.kekwy.com/comments/index.html","excerpt":"","text":"也可以是聊天室（"},{"title":"记录生活","date":"2022-07-31T11:26:11.263Z","updated":"2022-07-31T11:26:11.263Z","comments":false,"path":"recordings/index.html","permalink":"http://blog.kekwy.com/recordings/index.html","excerpt":"","text":"2022七月7.31 网站功能初步竣工，将在使用过程中调整或完善。"},{"title":"大伙儿","date":"2022-07-30T15:17:01.000Z","updated":"2022-07-31T13:04:48.714Z","comments":false,"path":"friends/index.html","permalink":"http://blog.kekwy.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"类的高级特性","slug":"javaNotes-2","date":"2022-08-01T11:50:13.000Z","updated":"2022-08-03T15:24:54.678Z","comments":true,"path":"javaNotes-2/","link":"","permalink":"http://blog.kekwy.com/javaNotes-2/","excerpt":"","text":"I. Java类包 类名冲突： 任何类与接口都需要隶属于某一个类包。可以通过将两个同名类定义在不同的类包中解决类名冲突的问题。 类的路径： 同一个类包中的类相互访问时，可以不指定包名； 同一个包中的类不必存放在同一个位置，只要将CLASSPATH分别指向这两个位置即可。 指定包与导入包： 将 package 表达式作为文件中的第一行非注释代码，java包名必须全部使用小写字母。 1package 包名; 导入包： 123import 包名.*import 包名.类名import 包名.静态方法名 tips: 使用 import 关键字指定一个包中的所有类时，并不会指定这个包的子包中的类，如需使用需要对子包作单独引用。 II. final 关键字 变量： 修饰常量变量； 对象引用被 final 修饰后无法使其指向另一个对象； Java中定义全局变量，通常使用 public static final 修饰，是能在定义时被赋值。 方法： 被 final 修饰的方法不能被重写； private 方法隐式被指定为 final 类型。 类： 被修饰的类不能被继承。 III. 内部类成员内部类 基础用法： 成员内部类的定义：（非内部类不能被声明为private或protected访问类型） 12345public class OuterClass &#123; // 外部类 private class InnerClass &#123; // 内部类 //... &#125;&#125; 内部类中可以访问外部类的所有成员变量和方法，外部类只能通过实例化内部类对象访问内部类成员（受权限修饰关键字限制）； 内部类中的变量与外部类变量同名时，可以使用 this 指针加以区分： 1234// 若内部类与外部类中均有变量xthis.x; // 内部类的xOuterClass.this.x; // 外部类的xx; // 同名局部变量、形参（若有） 在外部类和非静态方法之外实例化内部类对象，需要使用外部类： 12OuterClass out = = new OuterClass();OuterClass.innerClass in = out.new innerClass(); 内部类对象会依赖于外部类对象。只有存在外部类对象，才能实例化内部类对象。 内部类向上转型为接口; 将一个权限修饰符为 private 的内部类向上转型为一个接口，就可以完全隐藏内部类的具体实现过程； 对于一个外部接口中的方法，可以通过在一个类中定义多个内部类，每个内部类分别实现该方法的方式，实现在类中多次实现接口中的同一个方法； 12345678910111213141516171819202122interface OutInterface &#123; public void f();&#125;class OuterClass &#123; // 定义一个外部不可访问的内部类 private class InnerClass implements OutInterface &#123; // 实现接口方法 public void f() &#123; // do something... &#125; &#125; public OutInterface doit &#123; return new InnerClass(); // 将内部类向上转型为外部接口 &#125;&#125;...OuterClass out = new OuterClass();OutInterface outinter = out.doit();outinter.f();... 外部不可直接访问内部类中的 f() 方法但是可以访问接口中的，通过将内部类向上转型执行内部类中定义的方法，对继承外部类的子类隐藏了实现细节。（向外提供外部类和接口） 局部内部类 内部类可以在类的局部位置定义（如方法） 在方法中定义的内部类只能使用方法中被 final 修饰的变量。因为内部类对象的生存期超出方法运行的生存期，导致方法中的一般局部变量比内部类对象的生存期短，而被final型变量被视为常量，其生存期同样比方法运行的生存期长。 匿名内部类123return new A() &#123; ...//内部类体&#125;; 匿名内部类编译以后，产生以“外部类名$序号”为名称的.class文件，序号以1~n排列。 静态内部类 创建静态内部类的对象不需要其外部类的对象； 静态内部类的对象中不能访问非静态外部类的对象。 内部类的继承1234567891011public class OutputInnerClass extends ClassA.ClassB &#123; public OutputInnerClass(classA a) &#123; a.super(); // 生成B类的外部类对象 &#125;&#125;class ClassA &#123; class ClassB &#123; &#125;&#125; 考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"},{"title":"接口、继承与多态","slug":"javaNotes-1","date":"2022-07-30T07:00:16.000Z","updated":"2022-08-01T11:51:42.005Z","comments":true,"path":"javaNotes-1/","link":"","permalink":"http://blog.kekwy.com/javaNotes-1/","excerpt":"","text":"I. 类的继承权限修饰关键字： private 外部以及子类均不可访问 public 外部以及子类均不可访问 protected 外部不可，但子类可以访问 定义类时通过关键字extends + 父类类名定义继承； 子类方法中可以通过super关键字调用父类方法（受权限修饰关键字约束）； 子类中可以通过定义与父类某一方法名称相同的函数实现对父类中该方法的重写（覆盖）； 重写时如修改方法的权限范围，只能从小到大； 重写时返回值必须与父类中同名函数返回值相同或为其子类； 子类实例化时会自动调用父类的无参构造方法，但若需调用有参构造方法需要通过super关键字手动调用； 子类finalize()方法需要保证最后一个动作是调用父类的finalize()方法； 1234567891011121314151617181920212223242526272829303132333435class Test &#123; public Test() &#123; //do something &#125; public void doSomething1() &#123; //do something &#125; private void doSomething2() &#123; //do something &#125; protected void doSomething3() &#123; //do something &#125; public Test doTest() &#123; //do something &#125;&#125;class Test1 extends Test&#123; public Test() &#123; super(); //调用父类构造方法 super.doSomething1(); &#125; public void doSomething3() &#123; //do something &#125; /* private void doSomething3() &#123; //do something &#125; 写法错误 */ public Test1 doTest() &#123; //do something &#125;&#125; II. Object类 Objcect 类是所有Java类的父类。 tips：Object 类中的 getClass() 、notify() 、notifyAll() 、wait() 等方法不能在子类中重写。（被定义为final类型） Object 类中的重要方法： getClass()：返回对象执行时的Class实例。（Unity的getObejct） toString()：将一个对象返回为字符串，一般需要根据需要在子类中重写. tips：将对象打印时将自动调用该方法。 equals()：默认使用“&#x3D;&#x3D;”运算符根据对象的引用（地址）判断是否相等。故一般需要按需重写。 III. 对象类型的转换 向上转型：将子类对象视为父类对象。由具体到抽象，总是安全的。 1Quadrangle obj = new Patallelogram(); // 平行四边形是四边形的子类 向下转型：将父类对象转换为子类对象，必须通过强制类型转换，且必须保证当前父类对象是目标子类对象的实例。 12Quadrangle p = new Patallelogram();Patallelogram q = (Patallelogram)p; IV. 使用instanceof操作符判断对象类型可用于实现向下转换时对父类对象实例类型的判断。 语法格式：（返回值为布尔型） 12myobject instanceof ExampleClass;// myobject对象是否为ExampleClass类的实例 V. 方法的重载同过定义同名方法但参数不完全相同的方式实现方法的重载，但单单返回值不同不能实现重载。 编译器利用方法名、方法各参数类型和参数的个数以及参数的顺序来确定类中的方法是否唯一。 不定长参数也可以参与实现重载： 12int add(int a);int add(int... a); VI. 抽象类与接口 抽象类 tips： 抽象类不能实例化对象； 只有抽象类才可以承载抽象方法； 抽象方法在其子类中必须被重写。 定义抽象类的关键字 abstract 。 123public abstract class Test &#123; abstract void testAbstract();&#125; 接口： 定义接口使用关键字 interface ： 1234public interface 接口名 &#123; void doSomething(); // 自动虚方法，可以省略abstract关键字&#125; public：接口可以像类一样被权限修饰符修饰，但public关键字仅限于接口在与其同名的文件中被定义时； 接口中的方法必须被定义为public或abstract形式。 实现接口使用关键字 implements ： tips：Java中不许出现多继承但是可以通过同一个类实现许多接口来实现多继承，一个接口也可以继承另一个接口。 123456789101112#1class 类名 implements 接口1，接口2, ... &#123; &#125;#2interface intf1 &#123; &#125;interface intf2 extends intf1 &#123; &#125; 参考资料《Java从入门到精通（第5版）》","categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}],"author":"Ke_DiWZ"}],"categories":[{"name":"从继承开始的Java应用笔记","slug":"从继承开始的Java应用笔记","permalink":"http://blog.kekwy.com/categories/%E4%BB%8E%E7%BB%A7%E6%89%BF%E5%BC%80%E5%A7%8B%E7%9A%84Java%E5%BA%94%E7%94%A8%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.kekwy.com/tags/Java/"},{"name":"学习","slug":"学习","permalink":"http://blog.kekwy.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"编程","slug":"编程","permalink":"http://blog.kekwy.com/tags/%E7%BC%96%E7%A8%8B/"}]}